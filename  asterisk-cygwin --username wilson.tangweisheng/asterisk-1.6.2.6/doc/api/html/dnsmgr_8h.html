<HTML>
    <HEAD>
      <TITLE>Asterisk.org: Developer Documentation (5 May 2010)</TITLE>
      <LINK HREF="doxygen.css" REL="stylesheet" TYPE="text/css">
    </HEAD>
    <BODY BGCOLOR="#FFFFFF">
<div><font size="2" align="right">Wed May 5 15:21:59 2010</font></div>

<h2>Asterisk developer's documentation</h2>
<hr/>
<!-- Generated by Doxygen 1.6.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
  <div class="navpath"><a class="el" href="dir_1ab815038f534adda65c8b4ae4993449.html">include</a>&nbsp;&raquo&nbsp;<a class="el" href="dir_16d825f1fa9ecca2e70b1a8d9256d0e6.html">asterisk</a>
  </div>
</div>
<div class="contents">
<h1>dnsmgr.h File Reference</h1>
<p>Background DNS update manager.  
<a href="#_details">More...</a></p>
<code>#include &quot;<a class="el" href="network_8h_source.html">asterisk/network.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="srv_8h_source.html">asterisk/srv.h</a>&quot;</code><br/>

<p><a href="dnsmgr_8h_source.html">Go to the source code of this file.</a></p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dnsmgr_8h.html#ad43ae5f58db3498b5b1830bd98677117">ast_dnsmgr_changed</a> (struct <a class="el" href="structast__dnsmgr__entry.html">ast_dnsmgr_entry</a> *entry)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Check is see if a dnsmgr entry has changed.  <a href="#ad43ae5f58db3498b5b1830bd98677117"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structast__dnsmgr__entry.html">ast_dnsmgr_entry</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dnsmgr_8h.html#a984d70d01632590958b00f14e33962bb">ast_dnsmgr_get</a> (const char *<a class="el" href="channel_8c.html#a8f8f80d37794cde9472343e4487ba3eb">name</a>, struct sockaddr_in *result, const char *<a class="el" href="adsistub_8c.html#ad61354ac038c6aaed26fded971a8843b">service</a>)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Allocate a new DNS manager entry.  <a href="#a984d70d01632590958b00f14e33962bb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dnsmgr_8h.html#a281a512e7dbfb3ca5875c1a4d08ac0d6">ast_dnsmgr_lookup</a> (const char *<a class="el" href="channel_8c.html#a8f8f80d37794cde9472343e4487ba3eb">name</a>, struct sockaddr_in *result, struct <a class="el" href="structast__dnsmgr__entry.html">ast_dnsmgr_entry</a> **dnsmgr, const char *<a class="el" href="adsistub_8c.html#ad61354ac038c6aaed26fded971a8843b">service</a>)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Allocate and initialize a DNS manager entry.  <a href="#a281a512e7dbfb3ca5875c1a4d08ac0d6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dnsmgr_8h.html#add74c87320b8447b69e776931520e994">ast_dnsmgr_refresh</a> (struct <a class="el" href="structast__dnsmgr__entry.html">ast_dnsmgr_entry</a> *entry)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Force a refresh of a dnsmgr entry.  <a href="#add74c87320b8447b69e776931520e994"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dnsmgr_8h.html#a0255399a507b71ae563fc2caf94d749c">ast_dnsmgr_release</a> (struct <a class="el" href="structast__dnsmgr__entry.html">ast_dnsmgr_entry</a> *entry)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Free a DNS manager entry.  <a href="#a0255399a507b71ae563fc2caf94d749c"></a><br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>Background DNS update manager. </p>

<p>Definition in file <a class="el" href="dnsmgr_8h_source.html">dnsmgr.h</a>.</p>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="ad43ae5f58db3498b5b1830bd98677117"></a><!-- doxytag: member="dnsmgr.h::ast_dnsmgr_changed" ref="ad43ae5f58db3498b5b1830bd98677117" args="(struct ast_dnsmgr_entry *entry)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ast_dnsmgr_changed </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structast__dnsmgr__entry.html">ast_dnsmgr_entry</a> *&nbsp;</td>
          <td class="paramname"> <em>entry</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Check is see if a dnsmgr entry has changed. </p>
<dl><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>non-zero</em>&nbsp;</td><td>if the dnsmgr entry has changed since the last call to this function </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>zero</em>&nbsp;</td><td>if the dnsmgr entry has not changed since the last call to this function </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="dnsmgr_8c_source.html#l00191">191</a> of file <a class="el" href="dnsmgr_8c_source.html">dnsmgr.c</a>.</p>

<p>References <a class="el" href="lock_8h_source.html#l01717">ast_mutex_lock()</a>, <a class="el" href="lock_8h_source.html#l01707">ast_mutex_unlock()</a>, <a class="el" href="dnsmgr_8c_source.html#l00060">ast_dnsmgr_entry::changed</a>, and <a class="el" href="dnsmgr_8c_source.html#l00061">ast_dnsmgr_entry::lock</a>.</p>

<p>Referenced by <a class="el" href="chan__iax2_8c_source.html#l11265">iax2_do_register()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00192"></a>00192 {
<a name="l00193"></a>00193    <span class="keywordtype">int</span> <a class="code" href="structast__dnsmgr__entry.html#af28d4213d4bda49ab19d2451ec6da277">changed</a>;
<a name="l00194"></a>00194 
<a name="l00195"></a>00195    <a class="code" href="lock_8h.html#ad941566de4050aa7358493af94d2ba4d">ast_mutex_lock</a>(&amp;entry-&gt;<a class="code" href="structast__dnsmgr__entry.html#adf04f66344e3fb0a6f6a69bf39d19902">lock</a>);
<a name="l00196"></a>00196 
<a name="l00197"></a>00197    changed = entry-&gt;<a class="code" href="structast__dnsmgr__entry.html#af28d4213d4bda49ab19d2451ec6da277">changed</a>;
<a name="l00198"></a>00198    entry-&gt;<a class="code" href="structast__dnsmgr__entry.html#af28d4213d4bda49ab19d2451ec6da277">changed</a> = 0;
<a name="l00199"></a>00199 
<a name="l00200"></a>00200    <a class="code" href="lock_8h.html#aa9b39f0e22f44a7e7f587d4252e41a0b">ast_mutex_unlock</a>(&amp;entry-&gt;<a class="code" href="structast__dnsmgr__entry.html#adf04f66344e3fb0a6f6a69bf39d19902">lock</a>);
<a name="l00201"></a>00201    
<a name="l00202"></a>00202    <span class="keywordflow">return</span> changed;
<a name="l00203"></a>00203 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a984d70d01632590958b00f14e33962bb"></a><!-- doxytag: member="dnsmgr.h::ast_dnsmgr_get" ref="a984d70d01632590958b00f14e33962bb" args="(const char *name, struct sockaddr_in *result, const char *service)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structast__dnsmgr__entry.html">ast_dnsmgr_entry</a>* ast_dnsmgr_get </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct sockaddr_in *&nbsp;</td>
          <td class="paramname"> <em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>service</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [read]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Allocate a new DNS manager entry. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td>the hostname </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>result</em>&nbsp;</td><td>where the DNS manager should store the IP address as it refreshes it. it.</td></tr>
  </table>
  </dd>
</dl>
<p>This function allocates a new DNS manager entry object, and fills it with the provided hostname and IP address. This function does not force an initial lookup of the IP address. So, generally, this should be used when the initial address is already known.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>a DNS manager entry </dd></dl>
<dl class="version"><dt><b>Version:</b></dt><dd>1.6.1 result changed from struct in_addr to struct sockaddr_in to store port <a class="el" href="structnumber.html" title="Number structure.">number</a> </dd></dl>

<p>Definition at line <a class="el" href="dnsmgr_8c_source.html#l00088">88</a> of file <a class="el" href="dnsmgr_8c_source.html">dnsmgr.c</a>.</p>

<p>References <a class="el" href="astmm_8h_source.html#l00072">ast_calloc</a>, <a class="el" href="lock_8h_source.html#l01692">ast_mutex_init()</a>, <a class="el" href="linkedlists_8h_source.html#l00702">AST_RWLIST_INSERT_HEAD</a>, <a class="el" href="linkedlists_8h_source.html#l00150">AST_RWLIST_UNLOCK</a>, <a class="el" href="linkedlists_8h_source.html#l00051">AST_RWLIST_WRLOCK</a>, <a class="el" href="strings_8h_source.html#l00063">ast_strlen_zero()</a>, <a class="el" href="dnsmgr_8c_source.html#l00056">ast_dnsmgr_entry::last</a>, <a class="el" href="dnsmgr_8c_source.html#l00061">ast_dnsmgr_entry::lock</a>, <a class="el" href="dnsmgr_8c_source.html#l00064">ast_dnsmgr_entry::name</a>, <a class="el" href="dnsmgr_8c_source.html#l00054">ast_dnsmgr_entry::result</a>, and <a class="el" href="dnsmgr_8c_source.html#l00058">ast_dnsmgr_entry::service</a>.</p>

<p>Referenced by <a class="el" href="dnsmgr_8c_source.html#l00126">ast_dnsmgr_lookup()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00089"></a>00089 {
<a name="l00090"></a>00090    <span class="keyword">struct </span><a class="code" href="structast__dnsmgr__entry.html">ast_dnsmgr_entry</a> *entry;
<a name="l00091"></a>00091    <span class="keywordtype">int</span> total_size = <span class="keyword">sizeof</span>(*entry) + strlen(<a class="code" href="cdr__adaptive__odbc_8c.html#a5ac083a645d964373f022d03df4849c8">name</a>) + (<a class="code" href="adsistub_8c.html#ad61354ac038c6aaed26fded971a8843b">service</a> ? strlen(<a class="code" href="adsistub_8c.html#ad61354ac038c6aaed26fded971a8843b">service</a>) + 1 : 0);
<a name="l00092"></a>00092 
<a name="l00093"></a>00093    <span class="keywordflow">if</span> (!<a class="code" href="structast__dnsmgr__entry.html#a7eeb286de7c2b82381f8d0ffbc910d64">result</a> || <a class="code" href="strings_8h.html#a5c8aa5212ecb665fb072eac00c799da6">ast_strlen_zero</a>(<a class="code" href="cdr__adaptive__odbc_8c.html#a5ac083a645d964373f022d03df4849c8">name</a>) || !(entry = <a class="code" href="astmm_8h.html#a1cb33b63d94fbbde94234b062249e015">ast_calloc</a>(1, total_size)))
<a name="l00094"></a>00094       <span class="keywordflow">return</span> NULL;
<a name="l00095"></a>00095 
<a name="l00096"></a>00096    entry-&gt;<a class="code" href="structast__dnsmgr__entry.html#a7eeb286de7c2b82381f8d0ffbc910d64">result</a> = <a class="code" href="structast__dnsmgr__entry.html#a7eeb286de7c2b82381f8d0ffbc910d64">result</a>;
<a name="l00097"></a>00097    <a class="code" href="lock_8h.html#a5dc895fe6e8c089175159fc22e33fc3b">ast_mutex_init</a>(&amp;entry-&gt;<a class="code" href="structast__dnsmgr__entry.html#adf04f66344e3fb0a6f6a69bf39d19902">lock</a>);
<a name="l00098"></a>00098    strcpy(entry-&gt;<a class="code" href="structast__dnsmgr__entry.html#ac8b44a387cf3da062c4a32316b43962c">name</a>, <a class="code" href="cdr__adaptive__odbc_8c.html#a5ac083a645d964373f022d03df4849c8">name</a>);
<a name="l00099"></a>00099    memcpy(&amp;entry-&gt;<a class="code" href="structast__dnsmgr__entry.html#a8f560e4877f6a2c9fb75a68df1b0c2e6">last</a>, <a class="code" href="structast__dnsmgr__entry.html#a7eeb286de7c2b82381f8d0ffbc910d64">result</a>, <span class="keyword">sizeof</span>(entry-&gt;<a class="code" href="structast__dnsmgr__entry.html#a8f560e4877f6a2c9fb75a68df1b0c2e6">last</a>));
<a name="l00100"></a>00100    <span class="keywordflow">if</span> (<a class="code" href="adsistub_8c.html#ad61354ac038c6aaed26fded971a8843b">service</a>) {
<a name="l00101"></a>00101       entry-&gt;<a class="code" href="structast__dnsmgr__entry.html#a95c05b2a02d1d31907fde00f0051aed2">service</a> = ((<span class="keywordtype">char</span> *) entry) + <span class="keyword">sizeof</span>(*entry) + strlen(<a class="code" href="cdr__adaptive__odbc_8c.html#a5ac083a645d964373f022d03df4849c8">name</a>);
<a name="l00102"></a>00102       strcpy(entry-&gt;<a class="code" href="structast__dnsmgr__entry.html#a95c05b2a02d1d31907fde00f0051aed2">service</a>, <a class="code" href="adsistub_8c.html#ad61354ac038c6aaed26fded971a8843b">service</a>);
<a name="l00103"></a>00103    }
<a name="l00104"></a>00104 
<a name="l00105"></a>00105    <a class="code" href="linkedlists_8h.html#a2d0cf4182bade9f773fb16ff12abe595" title="Write locks a list.">AST_RWLIST_WRLOCK</a>(&amp;<a class="code" href="structentry__list.html">entry_list</a>);
<a name="l00106"></a>00106    <a class="code" href="linkedlists_8h.html#aacc5f6b7c25e361d11d40137fd55a8e8">AST_RWLIST_INSERT_HEAD</a>(&amp;<a class="code" href="structentry__list.html">entry_list</a>, entry, <a class="code" href="structast__dnsmgr__entry.html#aae38607f9c0c85769368645b604157a0">list</a>);
<a name="l00107"></a>00107    <a class="code" href="linkedlists_8h.html#a2e9a2518b5029b96671aff6701bd5138" title="Attempts to unlock a read/write based list.">AST_RWLIST_UNLOCK</a>(&amp;<a class="code" href="structentry__list.html">entry_list</a>);
<a name="l00108"></a>00108 
<a name="l00109"></a>00109    <span class="keywordflow">return</span> entry;
<a name="l00110"></a>00110 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a281a512e7dbfb3ca5875c1a4d08ac0d6"></a><!-- doxytag: member="dnsmgr.h::ast_dnsmgr_lookup" ref="a281a512e7dbfb3ca5875c1a4d08ac0d6" args="(const char *name, struct sockaddr_in *result, struct ast_dnsmgr_entry **dnsmgr, const char *service)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ast_dnsmgr_lookup </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct sockaddr_in *&nbsp;</td>
          <td class="paramname"> <em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structast__dnsmgr__entry.html">ast_dnsmgr_entry</a> **&nbsp;</td>
          <td class="paramname"> <em>dnsmgr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>service</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Allocate and initialize a DNS manager entry. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td>the hostname </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>result</em>&nbsp;</td><td>where to store the IP address as the DNS manager refreshes it </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dnsmgr</em>&nbsp;</td><td>Where to store the allocate DNS manager entry</td></tr>
  </table>
  </dd>
</dl>
<p>This function allocates a new DNS manager entry object, and fills it with the provided hostname and IP address. This function _does_ force an initial lookup, so it may block for some period of time.</p>
<dl><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>0</em>&nbsp;</td><td>success </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>non-zero</em>&nbsp;</td><td>failure </td></tr>
  </table>
  </dd>
</dl>
<dl class="version"><dt><b>Version:</b></dt><dd>1.6.1 result changed from struct in_addr to struct aockaddr_in to store port <a class="el" href="structnumber.html" title="Number structure.">number</a> </dd></dl>

<p>Definition at line <a class="el" href="dnsmgr_8c_source.html#l00126">126</a> of file <a class="el" href="dnsmgr_8c_source.html">dnsmgr.c</a>.</p>

<p>References <a class="el" href="dnsmgr_8c_source.html#l00088">ast_dnsmgr_get()</a>, <a class="el" href="acl_8c_source.html#l00375">ast_get_ip_or_srv()</a>, <a class="el" href="strings_8h_source.html#l00063">ast_strlen_zero()</a>, <a class="el" href="logger_8h_source.html#l00220">ast_verb</a>, and <a class="el" href="cdr_8c_source.html#l00086">enabled</a>.</p>

<p>Referenced by <a class="el" href="chan__sip_8c_source.html#l10966">__sip_subscribe_mwi_do()</a>, <a class="el" href="chan__iax2_8c_source.html#l11880">build_peer()</a>, <a class="el" href="chan__iax2_8c_source.html#l08150">iax2_append_register()</a>, and <a class="el" href="chan__sip_8c_source.html#l11545">transmit_register()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00127"></a>00127 {
<a name="l00128"></a>00128    <span class="keywordflow">if</span> (<a class="code" href="strings_8h.html#a5c8aa5212ecb665fb072eac00c799da6">ast_strlen_zero</a>(<a class="code" href="cdr__adaptive__odbc_8c.html#a5ac083a645d964373f022d03df4849c8">name</a>) || !<a class="code" href="structast__dnsmgr__entry.html#a7eeb286de7c2b82381f8d0ffbc910d64">result</a> || !dnsmgr)
<a name="l00129"></a>00129       <span class="keywordflow">return</span> -1;
<a name="l00130"></a>00130 
<a name="l00131"></a>00131    <span class="keywordflow">if</span> (*dnsmgr &amp;&amp; !strcasecmp((*dnsmgr)-&gt;name, <a class="code" href="cdr__adaptive__odbc_8c.html#a5ac083a645d964373f022d03df4849c8">name</a>))
<a name="l00132"></a>00132       <span class="keywordflow">return</span> 0;
<a name="l00133"></a>00133 
<a name="l00134"></a>00134    <span class="comment">/* if it&apos;s actually an IP address and not a name,</span>
<a name="l00135"></a>00135 <span class="comment">      there&apos;s no need for a managed lookup */</span>
<a name="l00136"></a>00136    <span class="keywordflow">if</span> (inet_aton(<a class="code" href="cdr__adaptive__odbc_8c.html#a5ac083a645d964373f022d03df4849c8">name</a>, &amp;<a class="code" href="structast__dnsmgr__entry.html#a7eeb286de7c2b82381f8d0ffbc910d64">result</a>-&gt;sin_addr))
<a name="l00137"></a>00137       <span class="keywordflow">return</span> 0;
<a name="l00138"></a>00138 
<a name="l00139"></a>00139    <a class="code" href="logger_8h.html#ad770f83c71e237e1f64163358ce4e13d">ast_verb</a>(4, <span class="stringliteral">&quot;doing dnsmgr_lookup for &apos;%s&apos;\n&quot;</span>, <a class="code" href="cdr__adaptive__odbc_8c.html#a5ac083a645d964373f022d03df4849c8">name</a>);
<a name="l00140"></a>00140 
<a name="l00141"></a>00141    <span class="comment">/* do a lookup now but add a manager so it will automagically get updated in the background */</span>
<a name="l00142"></a>00142    <a class="code" href="acl_8h.html#afab7a25fb37c7e1a0dedef9c286a44a1">ast_get_ip_or_srv</a>(<a class="code" href="structast__dnsmgr__entry.html#a7eeb286de7c2b82381f8d0ffbc910d64">result</a>, <a class="code" href="cdr__adaptive__odbc_8c.html#a5ac083a645d964373f022d03df4849c8">name</a>, <a class="code" href="adsistub_8c.html#ad61354ac038c6aaed26fded971a8843b">service</a>);
<a name="l00143"></a>00143    
<a name="l00144"></a>00144    <span class="comment">/* if dnsmgr is not enable don&apos;t bother adding an entry */</span>
<a name="l00145"></a>00145    <span class="keywordflow">if</span> (!<a class="code" href="cdr_8c.html#a03e6cca0c879c0443efb431c30c14f76">enabled</a>)
<a name="l00146"></a>00146       <span class="keywordflow">return</span> 0;
<a name="l00147"></a>00147    
<a name="l00148"></a>00148    <a class="code" href="logger_8h.html#ad770f83c71e237e1f64163358ce4e13d">ast_verb</a>(3, <span class="stringliteral">&quot;adding dns manager for &apos;%s&apos;\n&quot;</span>, <a class="code" href="cdr__adaptive__odbc_8c.html#a5ac083a645d964373f022d03df4849c8">name</a>);
<a name="l00149"></a>00149    *dnsmgr = <a class="code" href="dnsmgr_8h.html#a984d70d01632590958b00f14e33962bb" title="Allocate a new DNS manager entry.">ast_dnsmgr_get</a>(<a class="code" href="cdr__adaptive__odbc_8c.html#a5ac083a645d964373f022d03df4849c8">name</a>, <a class="code" href="structast__dnsmgr__entry.html#a7eeb286de7c2b82381f8d0ffbc910d64">result</a>, <a class="code" href="adsistub_8c.html#ad61354ac038c6aaed26fded971a8843b">service</a>);
<a name="l00150"></a>00150    <span class="keywordflow">return</span> !*dnsmgr;
<a name="l00151"></a>00151 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="add74c87320b8447b69e776931520e994"></a><!-- doxytag: member="dnsmgr.h::ast_dnsmgr_refresh" ref="add74c87320b8447b69e776931520e994" args="(struct ast_dnsmgr_entry *entry)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ast_dnsmgr_refresh </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structast__dnsmgr__entry.html">ast_dnsmgr_entry</a> *&nbsp;</td>
          <td class="paramname"> <em>entry</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Force a refresh of a dnsmgr entry. </p>
<dl><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>non-zero</em>&nbsp;</td><td>if the result is different than the previous result </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>zero</em>&nbsp;</td><td>if the result is the same as the previous result </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="dnsmgr_8c_source.html#l00183">183</a> of file <a class="el" href="dnsmgr_8c_source.html">dnsmgr.c</a>.</p>

<p>References <a class="el" href="dnsmgr_8c_source.html#l00156">dnsmgr_refresh()</a>.</p>

<p>Referenced by <a class="el" href="chan__iax2_8c_source.html#l11265">iax2_do_register()</a>, and <a class="el" href="chan__sip_8c_source.html#l11487">sip_reg_timeout()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00184"></a>00184 {
<a name="l00185"></a>00185    <span class="keywordflow">return</span> <a class="code" href="dnsmgr_8c.html#afd4006993b0aac1410d7255730bc3a7c">dnsmgr_refresh</a>(entry, 0);
<a name="l00186"></a>00186 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a0255399a507b71ae563fc2caf94d749c"></a><!-- doxytag: member="dnsmgr.h::ast_dnsmgr_release" ref="a0255399a507b71ae563fc2caf94d749c" args="(struct ast_dnsmgr_entry *entry)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ast_dnsmgr_release </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structast__dnsmgr__entry.html">ast_dnsmgr_entry</a> *&nbsp;</td>
          <td class="paramname"> <em>entry</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Free a DNS manager entry. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>entry</em>&nbsp;</td><td>the DNS manager entry to free</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>nothing </dd></dl>

<p>Definition at line <a class="el" href="dnsmgr_8c_source.html#l00112">112</a> of file <a class="el" href="dnsmgr_8c_source.html">dnsmgr.c</a>.</p>

<p>References <a class="el" href="astmm_8h_source.html#l00087">ast_free</a>, <a class="el" href="lock_8h_source.html#l01712">ast_mutex_destroy()</a>, <a class="el" href="linkedlists_8h_source.html#l00860">AST_RWLIST_REMOVE</a>, <a class="el" href="linkedlists_8h_source.html#l00150">AST_RWLIST_UNLOCK</a>, <a class="el" href="linkedlists_8h_source.html#l00051">AST_RWLIST_WRLOCK</a>, <a class="el" href="logger_8h_source.html#l00220">ast_verb</a>, <a class="el" href="dnsmgr_8c_source.html#l00061">ast_dnsmgr_entry::lock</a>, and <a class="el" href="dnsmgr_8c_source.html#l00064">ast_dnsmgr_entry::name</a>.</p>

<p>Referenced by <a class="el" href="chan__iax2_8c_source.html#l12414">delete_users()</a>, <a class="el" href="chan__iax2_8c_source.html#l11855">peer_destructor()</a>, <a class="el" href="chan__sip_8c_source.html#l04649">sip_destroy_peer()</a>, <a class="el" href="chan__sip_8c_source.html#l05460">sip_registry_destroy()</a>, and <a class="el" href="chan__sip_8c_source.html#l05484">sip_subscribe_mwi_destroy()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00113"></a>00113 {
<a name="l00114"></a>00114    <span class="keywordflow">if</span> (!entry)
<a name="l00115"></a>00115       <span class="keywordflow">return</span>;
<a name="l00116"></a>00116 
<a name="l00117"></a>00117    <a class="code" href="linkedlists_8h.html#a2d0cf4182bade9f773fb16ff12abe595" title="Write locks a list.">AST_RWLIST_WRLOCK</a>(&amp;<a class="code" href="structentry__list.html">entry_list</a>);
<a name="l00118"></a>00118    <a class="code" href="linkedlists_8h.html#a6091f0518f8b6f443fd9f5150f3ac407">AST_RWLIST_REMOVE</a>(&amp;<a class="code" href="structentry__list.html">entry_list</a>, entry, <a class="code" href="structast__dnsmgr__entry.html#aae38607f9c0c85769368645b604157a0">list</a>);
<a name="l00119"></a>00119    <a class="code" href="linkedlists_8h.html#a2e9a2518b5029b96671aff6701bd5138" title="Attempts to unlock a read/write based list.">AST_RWLIST_UNLOCK</a>(&amp;<a class="code" href="structentry__list.html">entry_list</a>);
<a name="l00120"></a>00120    <a class="code" href="logger_8h.html#ad770f83c71e237e1f64163358ce4e13d">ast_verb</a>(4, <span class="stringliteral">&quot;removing dns manager for &apos;%s&apos;\n&quot;</span>, entry-&gt;<a class="code" href="structast__dnsmgr__entry.html#ac8b44a387cf3da062c4a32316b43962c">name</a>);
<a name="l00121"></a>00121 
<a name="l00122"></a>00122    <a class="code" href="lock_8h.html#ab237e70b569019bfb490ab0c3c09b8c5">ast_mutex_destroy</a>(&amp;entry-&gt;<a class="code" href="structast__dnsmgr__entry.html#adf04f66344e3fb0a6f6a69bf39d19902">lock</a>);
<a name="l00123"></a>00123    <a class="code" href="astmm_8h.html#a402072d6789f6ed9e3a81da27504127e">ast_free</a>(entry);
<a name="l00124"></a>00124 }
</pre></div></p>

</div>
</div>
</div>
<hr size="1"/><address style="text-align: right;"><small>Generated on Wed May 5 15:21:59 2010 for Asterisk - the Open Source PBX by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.1 </small></address>
</body>
</html>
