<HTML>
    <HEAD>
      <TITLE>Asterisk.org: Developer Documentation (5 May 2010)</TITLE>
      <LINK HREF="doxygen.css" REL="stylesheet" TYPE="text/css">
    </HEAD>
    <BODY BGCOLOR="#FFFFFF">
<div><font size="2" align="right">Wed May 5 15:18:47 2010</font></div>

<h2>Asterisk developer's documentation</h2>
<hr/>
<!-- Generated by Doxygen 1.6.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
  <div class="navpath"><a class="el" href="dir_1ab815038f534adda65c8b4ae4993449.html">include</a>&nbsp;&raquo&nbsp;<a class="el" href="dir_16d825f1fa9ecca2e70b1a8d9256d0e6.html">asterisk</a>
  </div>
</div>
<div class="contents">
<h1>res_odbc.h</h1><a href="res__odbc_8h.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">/*</span>
<a name="l00002"></a>00002 <span class="comment"> * Asterisk -- An open source telephony toolkit.</span>
<a name="l00003"></a>00003 <span class="comment"> *</span>
<a name="l00004"></a>00004 <span class="comment"> * Copyright (C) 1999 - 2005, Digium, Inc.</span>
<a name="l00005"></a>00005 <span class="comment"> * Copyright (C) 2004 - 2005, Anthony Minessale II</span>
<a name="l00006"></a>00006 <span class="comment"> * Copyright (C) 2006, Tilghman Lesher</span>
<a name="l00007"></a>00007 <span class="comment"> *</span>
<a name="l00008"></a>00008 <span class="comment"> * Mark Spencer &lt;markster@digium.com&gt;</span>
<a name="l00009"></a>00009 <span class="comment"> * Anthony Minessale &lt;anthmct@yahoo.com&gt;</span>
<a name="l00010"></a>00010 <span class="comment"> * Tilghman Lesher &lt;res_odbc_200603@the-tilghman.com&gt;</span>
<a name="l00011"></a>00011 <span class="comment"> *</span>
<a name="l00012"></a>00012 <span class="comment"> * See http://www.asterisk.org for more information about</span>
<a name="l00013"></a>00013 <span class="comment"> * the Asterisk project. Please do not directly contact</span>
<a name="l00014"></a>00014 <span class="comment"> * any of the maintainers of this project for assistance;</span>
<a name="l00015"></a>00015 <span class="comment"> * the project provides a web site, mailing lists and IRC</span>
<a name="l00016"></a>00016 <span class="comment"> * channels for your use.</span>
<a name="l00017"></a>00017 <span class="comment"> *</span>
<a name="l00018"></a>00018 <span class="comment"> * This program is free software, distributed under the terms of</span>
<a name="l00019"></a>00019 <span class="comment"> * the GNU General Public License Version 2. See the LICENSE file</span>
<a name="l00020"></a>00020 <span class="comment"> * at the top of the source tree.</span>
<a name="l00021"></a>00021 <span class="comment"> */</span>
<a name="l00022"></a>00022 <span class="comment"></span>
<a name="l00023"></a>00023 <span class="comment">/*! \file</span>
<a name="l00024"></a>00024 <span class="comment"> * \brief ODBC resource manager</span>
<a name="l00025"></a>00025 <span class="comment"> */</span>
<a name="l00026"></a>00026 
<a name="l00027"></a>00027 <span class="preprocessor">#ifndef _ASTERISK_RES_ODBC_H</span>
<a name="l00028"></a>00028 <span class="preprocessor"></span><span class="preprocessor">#define _ASTERISK_RES_ODBC_H</span>
<a name="l00029"></a>00029 <span class="preprocessor"></span>
<a name="l00030"></a>00030 <span class="preprocessor">#include &lt;sql.h&gt;</span>
<a name="l00031"></a>00031 <span class="preprocessor">#include &lt;sqlext.h&gt;</span>
<a name="l00032"></a>00032 <span class="preprocessor">#include &lt;sqltypes.h&gt;</span>
<a name="l00033"></a>00033 <span class="preprocessor">#include &quot;<a class="code" href="linkedlists_8h.html" title="A set of macros to manage forward-linked lists.">asterisk/linkedlists.h</a>&quot;</span>
<a name="l00034"></a>00034 <span class="preprocessor">#include &quot;<a class="code" href="strings_8h.html" title="String manipulation functions.">asterisk/strings.h</a>&quot;</span>
<a name="l00035"></a>00035 
<a name="l00036"></a><a class="code" href="res__odbc_8h.html#a105a23abbc3dcfda7728a1a39987b3d6ac683a4e66b82f69b00b54e279697fa92">00036</a> <span class="keyword">typedef</span> <span class="keyword">enum</span> { <a class="code" href="res__odbc_8h.html#a105a23abbc3dcfda7728a1a39987b3d6ac683a4e66b82f69b00b54e279697fa92">ODBC_SUCCESS</a>=0, <a class="code" href="res__odbc_8h.html#a105a23abbc3dcfda7728a1a39987b3d6a727133c18382293823de31545d7c5175">ODBC_FAIL</a>=-1} <a class="code" href="res__odbc_8h.html#a105a23abbc3dcfda7728a1a39987b3d6">odbc_status</a>;
<a name="l00037"></a>00037 <span class="comment"></span>
<a name="l00038"></a>00038 <span class="comment">/*! \brief Flags for use with \see ast_odbc_request_obj2 */</span>
<a name="l00039"></a>00039 <span class="keyword">enum</span> {
<a name="l00040"></a><a class="code" href="res__odbc_8h.html#a81929fb3d21206b62f55bcb744f71d5dae38953a3ea0dd8ab9f3994656e1e7fef">00040</a>    <a class="code" href="res__odbc_8h.html#a81929fb3d21206b62f55bcb744f71d5dae38953a3ea0dd8ab9f3994656e1e7fef">RES_ODBC_SANITY_CHECK</a> = (1 &lt;&lt; 0),
<a name="l00041"></a><a class="code" href="res__odbc_8h.html#a81929fb3d21206b62f55bcb744f71d5da90538ee30927dd290253a4774e361087">00041</a>    <a class="code" href="res__odbc_8h.html#a81929fb3d21206b62f55bcb744f71d5da90538ee30927dd290253a4774e361087">RES_ODBC_INDEPENDENT_CONNECTION</a> = (1 &lt;&lt; 1),
<a name="l00042"></a>00042 };
<a name="l00043"></a>00043 <span class="comment"></span>
<a name="l00044"></a>00044 <span class="comment">/*! \brief ODBC container */</span>
<a name="l00045"></a><a class="code" href="structodbc__obj.html">00045</a> <span class="keyword">struct </span><a class="code" href="structodbc__obj.html" title="ODBC container.">odbc_obj</a> {
<a name="l00046"></a><a class="code" href="structodbc__obj.html#adf04f66344e3fb0a6f6a69bf39d19902">00046</a>    <a class="code" href="lock_8h.html#a2d9118a2a8939f115eea771bce3a52f2">ast_mutex_t</a> <a class="code" href="structodbc__obj.html#adf04f66344e3fb0a6f6a69bf39d19902">lock</a>;
<a name="l00047"></a><a class="code" href="structodbc__obj.html#ae83918cc26dc7acd65bbec1712593054">00047</a>    SQLHDBC  <a class="code" href="structodbc__obj.html#ae83918cc26dc7acd65bbec1712593054">con</a>;                   <span class="comment">/*!&lt; ODBC Connection Handle */</span>
<a name="l00048"></a><a class="code" href="structodbc__obj.html#a2600ffe90b71935f45a9e36a6b5863c6">00048</a>    <span class="keyword">struct </span><a class="code" href="structodbc__class.html">odbc_class</a> *<a class="code" href="structodbc__obj.html#a2600ffe90b71935f45a9e36a6b5863c6">parent</a>;      <span class="comment">/*!&lt; Information about the connection is protected */</span>
<a name="l00049"></a><a class="code" href="structodbc__obj.html#a43b2c8a8bf77a2504897ff0da9b0aa90">00049</a>    <span class="keyword">struct </span>timeval <a class="code" href="structodbc__obj.html#a43b2c8a8bf77a2504897ff0da9b0aa90">last_used</a>;       <span class="comment">/*!&lt; Used by idlecheck to determine if the connection should be renegotiated */</span>
<a name="l00050"></a>00050 <span class="preprocessor">#ifdef DEBUG_THREADS</span>
<a name="l00051"></a>00051 <span class="preprocessor"></span>   <span class="keywordtype">char</span> file[80];
<a name="l00052"></a>00052    <span class="keywordtype">char</span> function[80];
<a name="l00053"></a>00053    <span class="keywordtype">int</span> lineno;
<a name="l00054"></a>00054 <span class="preprocessor">#endif</span>
<a name="l00055"></a><a class="code" href="structodbc__obj.html#a2590a5f33b83235fcf8740d3bb9b0e98">00055</a> <span class="preprocessor"></span>   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="structodbc__obj.html#a2590a5f33b83235fcf8740d3bb9b0e98">used</a>:1;            <span class="comment">/*!&lt; Is this connection currently in use? */</span>
<a name="l00056"></a><a class="code" href="structodbc__obj.html#a8042aba89daa6448b14e94e6d0bb63bf">00056</a>    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="structodbc__obj.html#a8042aba89daa6448b14e94e6d0bb63bf">up</a>:1;
<a name="l00057"></a><a class="code" href="structodbc__obj.html#abc0ea80cbb3a49c87b90be742126523c">00057</a>    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="structodbc__obj.html#abc0ea80cbb3a49c87b90be742126523c">tx</a>:1;              <span class="comment">/*!&lt; Should this connection be unshared, regardless of the class setting? */</span>
<a name="l00058"></a><a class="code" href="structodbc__obj.html#a3c30e5fedd5867e29dcc58b7abfe3c0d">00058</a>    <span class="keyword">struct </span><a class="code" href="structodbc__txn__frame.html">odbc_txn_frame</a> *<a class="code" href="structodbc__obj.html#a3c30e5fedd5867e29dcc58b7abfe3c0d">txf</a>;     <span class="comment">/*!&lt; Reference back to the transaction frame, if applicable */</span>
<a name="l00059"></a><a class="code" href="structodbc__obj.html#a35f93192e944901f5d3da32e8e937902">00059</a>    <a class="code" href="linkedlists_8h.html#a67508a613c8f337732e35d9367b43ae7" title="Declare a forward link structure inside a list entry.">AST_LIST_ENTRY</a>(<a class="code" href="structodbc__obj.html" title="ODBC container.">odbc_obj</a>) <a class="code" href="structodbc__obj.html#aea00fd1bbee2b8de5f83330881655694">list</a>;
<a name="l00060"></a>00060 };
<a name="l00061"></a>00061 
<a name="l00062"></a><a class="code" href="structodbc__cache__columns.html">00062</a> struct <a class="code" href="structodbc__cache__columns.html">odbc_cache_columns</a> {
<a name="l00063"></a><a class="code" href="structodbc__cache__columns.html#a5ac083a645d964373f022d03df4849c8">00063</a>    <span class="keywordtype">char</span> *<a class="code" href="cdr__adaptive__odbc_8c.html#a5ac083a645d964373f022d03df4849c8">name</a>;
<a name="l00064"></a><a class="code" href="structodbc__cache__columns.html#a713b6299f1d41d81cf4fec75082f0033">00064</a>    SQLSMALLINT <a class="code" href="evt_8c.html#a69e2889a94aeb9ac881abb82d3c22116">type</a>;
<a name="l00065"></a><a class="code" href="structodbc__cache__columns.html#a8f725e63e7aaa7e48a10d571d6bc5c44">00065</a>    SQLINTEGER size;
<a name="l00066"></a><a class="code" href="structodbc__cache__columns.html#a4655a72259cd34e7468eb595a3fb0c94">00066</a>    SQLSMALLINT decimals;
<a name="l00067"></a><a class="code" href="structodbc__cache__columns.html#a70c49af130fccda5ef1404bf0a994ef9">00067</a>    SQLSMALLINT radix;
<a name="l00068"></a><a class="code" href="structodbc__cache__columns.html#afa2cba5460bd1d85a31e95654006db4a">00068</a>    SQLSMALLINT nullable;
<a name="l00069"></a><a class="code" href="structodbc__cache__columns.html#a8c631ed493ba0edb1d8103971f8f7451">00069</a>    SQLINTEGER octetlen;
<a name="l00070"></a><a class="code" href="structodbc__cache__columns.html#a0a79a54fd8bab50cc16c4ff644f040c3">00070</a>    <a class="code" href="linkedlists_8h.html#ac63e9e237da22b6faf3be4edfc4f5a11">AST_RWLIST_ENTRY</a>(odbc_cache_columns) list;
<a name="l00071"></a>00071 };
<a name="l00072"></a>00072 
<a name="l00073"></a><a class="code" href="structodbc__cache__tables.html">00073</a> struct <a class="code" href="structodbc__cache__tables.html">odbc_cache_tables</a> {
<a name="l00074"></a><a class="code" href="structodbc__cache__tables.html#a2d51bc73bf08dbc3fcf184c65ce6622c">00074</a>    <span class="keywordtype">char</span> *connection;
<a name="l00075"></a><a class="code" href="structodbc__cache__tables.html#abc4810aa7718733bfc48b1973f4c92f8">00075</a>    <span class="keywordtype">char</span> *<a class="code" href="cdr__odbc_8c.html#a68d1e6e752f2cf81551fac543cae108a">table</a>;
<a name="l00076"></a><a class="code" href="structodbc__cache__tables_1_1__columns.html#ace4e0066a5b24f84b90536e9906619f6">00076</a>    <a class="code" href="linkedlists_8h.html#a93a29f1537444303ac1707e50b1a841d" title="Defines a structure to be used to hold a read/write list of specified type.">AST_RWLIST_HEAD</a>(<a class="code" href="structodbc__cache__tables_1_1__columns.html">_columns</a>, odbc_cache_columns) <a class="code" href="structcolumns.html">columns</a>;
<a name="l00077"></a><a class="code" href="structodbc__cache__tables.html#a18145eff6d7440e8093929c5f7266d06">00077</a>    <a class="code" href="linkedlists_8h.html#ac63e9e237da22b6faf3be4edfc4f5a11">AST_RWLIST_ENTRY</a>(odbc_cache_tables) list;
<a name="l00078"></a>00078 };
<a name="l00079"></a>00079 
<a name="l00080"></a>00080 <span class="comment">/* functions */</span>
<a name="l00081"></a>00081 <span class="comment"></span>
<a name="l00082"></a>00082 <span class="comment">/*! </span>
<a name="l00083"></a>00083 <span class="comment"> * \brief Executes a prepared statement handle</span>
<a name="l00084"></a>00084 <span class="comment"> * \param obj The non-NULL result of odbc_request_obj()</span>
<a name="l00085"></a>00085 <span class="comment"> * \param stmt The prepared statement handle</span>
<a name="l00086"></a>00086 <span class="comment"> * \retval 0 on success</span>
<a name="l00087"></a>00087 <span class="comment"> * \retval -1 on failure</span>
<a name="l00088"></a>00088 <span class="comment"> *</span>
<a name="l00089"></a>00089 <span class="comment"> * This function was originally designed simply to execute a prepared</span>
<a name="l00090"></a>00090 <span class="comment"> * statement handle and to retry if the initial execution failed.</span>
<a name="l00091"></a>00091 <span class="comment"> * Unfortunately, it did this by disconnecting and reconnecting the database</span>
<a name="l00092"></a>00092 <span class="comment"> * handle which on most databases causes the statement handle to become</span>
<a name="l00093"></a>00093 <span class="comment"> * invalid.  Therefore, this method has been deprecated in favor of</span>
<a name="l00094"></a>00094 <span class="comment"> * odbc_prepare_and_execute() which allows the statement to be prepared</span>
<a name="l00095"></a>00095 <span class="comment"> * multiple times, if necessary, in case of a loss of connection.</span>
<a name="l00096"></a>00096 <span class="comment"> *</span>
<a name="l00097"></a>00097 <span class="comment"> * This function really only ever worked with MySQL, where the statement handle is</span>
<a name="l00098"></a>00098 <span class="comment"> * not prepared on the server.  If you are not using MySQL, you should avoid it.</span>
<a name="l00099"></a>00099 <span class="comment"> */</span>
<a name="l00100"></a>00100 <span class="keywordtype">int</span> <a class="code" href="res__odbc_8h.html#af8da93ee13b95c6aae6a79558869812a" title="Executes a prepared statement handle.">ast_odbc_smart_execute</a>(struct <a class="code" href="structodbc__obj.html" title="ODBC container.">odbc_obj</a> *<a class="code" href="structodbc__txn__frame.html#ab5dd16c9db5f2ee0f0d6354952c92189">obj</a>, SQLHSTMT stmt) __attribute__((deprecated));
<a name="l00101"></a>00101 <span class="comment"></span>
<a name="l00102"></a>00102 <span class="comment">/*! </span>
<a name="l00103"></a>00103 <span class="comment"> * \brief Retrieves a connected ODBC object</span>
<a name="l00104"></a>00104 <span class="comment"> * \param name The name of the ODBC class for which a connection is needed.</span>
<a name="l00105"></a>00105 <span class="comment"> * \param flags Set of flags used to control which connection is returned.</span>
<a name="l00106"></a>00106 <span class="comment"> * \retval ODBC object </span>
<a name="l00107"></a>00107 <span class="comment"> * \retval  NULL if there is no connection available with the requested name.</span>
<a name="l00108"></a>00108 <span class="comment"> *</span>
<a name="l00109"></a>00109 <span class="comment"> * Connection classes may, in fact, contain multiple connection handles.  If</span>
<a name="l00110"></a>00110 <span class="comment"> * the connection is pooled, then each connection will be dedicated to the</span>
<a name="l00111"></a>00111 <span class="comment"> * thread which requests it.  Note that all connections should be released</span>
<a name="l00112"></a>00112 <span class="comment"> * when the thread is done by calling odbc_release_obj(), below.</span>
<a name="l00113"></a>00113 <span class="comment"> */</span>
<a name="l00114"></a>00114 <span class="preprocessor">#ifdef DEBUG_THREADS</span>
<a name="l00115"></a>00115 <span class="preprocessor"></span><span class="keyword">struct </span><a class="code" href="structodbc__obj.html" title="ODBC container.">odbc_obj</a> *_ast_odbc_request_obj2(<span class="keyword">const</span> <span class="keywordtype">char</span> *name, <span class="keyword">struct</span> <a class="code" href="structast__flags.html" title="Structure used to handle boolean flags.">ast_flags</a> flags, <span class="keyword">const</span> <span class="keywordtype">char</span> *file, <span class="keyword">const</span> <span class="keywordtype">char</span> *function, <span class="keywordtype">int</span> lineno);
<a name="l00116"></a>00116 <span class="preprocessor">#define ast_odbc_request_obj2(a, b) _ast_odbc_request_obj2(a, b, __FILE__, __PRETTY_FUNCTION__, __LINE__)</span>
<a name="l00117"></a>00117 <span class="preprocessor"></span><span class="preprocessor">#else</span>
<a name="l00118"></a>00118 <span class="preprocessor"></span><span class="keyword">struct </span><a class="code" href="structodbc__obj.html" title="ODBC container.">odbc_obj</a> *<a class="code" href="res__odbc_8h.html#a84fc89afd16a11b3a1095fb108e2a7ec" title="Retrieves a connected ODBC object.">ast_odbc_request_obj2</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> *name, <span class="keyword">struct</span> <a class="code" href="structast__flags.html" title="Structure used to handle boolean flags.">ast_flags</a> flags);
<a name="l00119"></a>00119 <span class="preprocessor">#endif</span>
<a name="l00120"></a>00120 <span class="preprocessor"></span>
<a name="l00121"></a>00121 <span class="preprocessor">#ifdef DEBUG_THREADS</span>
<a name="l00122"></a>00122 <span class="preprocessor"></span><span class="keyword">struct </span><a class="code" href="structodbc__obj.html" title="ODBC container.">odbc_obj</a> *_ast_odbc_request_obj(<span class="keyword">const</span> <span class="keywordtype">char</span> *name, <span class="keywordtype">int</span> check, <span class="keyword">const</span> <span class="keywordtype">char</span> *file, <span class="keyword">const</span> <span class="keywordtype">char</span> *function, <span class="keywordtype">int</span> lineno);
<a name="l00123"></a>00123 <span class="preprocessor">#define ast_odbc_request_obj(a, b)  _ast_odbc_request_obj(a, b, __FILE__, __PRETTY_FUNCTION__, __LINE__)</span>
<a name="l00124"></a>00124 <span class="preprocessor"></span><span class="preprocessor">#else</span>
<a name="l00125"></a>00125 <span class="preprocessor"></span><span class="keyword">struct </span><a class="code" href="structodbc__obj.html" title="ODBC container.">odbc_obj</a> *<a class="code" href="res__odbc_8h.html#ad34ae2bdba165ef6c7405afc94f2a7f3">ast_odbc_request_obj</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> *name, <span class="keywordtype">int</span> check);
<a name="l00126"></a>00126 <span class="preprocessor">#endif</span>
<a name="l00127"></a>00127 <span class="preprocessor"></span><span class="comment"></span>
<a name="l00128"></a>00128 <span class="comment">/*!</span>
<a name="l00129"></a>00129 <span class="comment"> * \brief Retrieve a stored ODBC object, if a transaction has been started.</span>
<a name="l00130"></a>00130 <span class="comment"> * \param chan Channel associated with the transaction.</span>
<a name="l00131"></a>00131 <span class="comment"> * \param objname Name of the database handle.  This name corresponds to the name passed</span>
<a name="l00132"></a>00132 <span class="comment"> * to \see ast_odbc_request_obj2 (or formerly, to ast_odbc_request_obj).  Note that the</span>
<a name="l00133"></a>00133 <span class="comment"> * existence of this parameter name explicitly allows for multiple transactions to be open</span>
<a name="l00134"></a>00134 <span class="comment"> * at once, albeit to different databases.</span>
<a name="l00135"></a>00135 <span class="comment"> * \retval A stored ODBC object, if a transaction was already started.</span>
<a name="l00136"></a>00136 <span class="comment"> * \retval NULL, if no transaction yet exists.</span>
<a name="l00137"></a>00137 <span class="comment"> */</span>
<a name="l00138"></a>00138 <span class="keyword">struct </span><a class="code" href="structodbc__obj.html" title="ODBC container.">odbc_obj</a> *<a class="code" href="res__odbc_8h.html#a14e6fc16f400d47e35ef4a0f2b220c53" title="Retrieve a stored ODBC object, if a transaction has been started.">ast_odbc_retrieve_transaction_obj</a>(<span class="keyword">struct</span> <a class="code" href="structast__channel.html" title="Main Channel structure associated with a channel. This is the side of it mostly used...">ast_channel</a> *<a class="code" href="adsistub_8c.html#a322af389d034b8f1282da0a853ffb921">chan</a>, <span class="keyword">const</span> <span class="keywordtype">char</span> *objname);
<a name="l00139"></a>00139 <span class="comment"></span>
<a name="l00140"></a>00140 <span class="comment">/*! </span>
<a name="l00141"></a>00141 <span class="comment"> * \brief Releases an ODBC object previously allocated by odbc_request_obj()</span>
<a name="l00142"></a>00142 <span class="comment"> * \param obj The ODBC object</span>
<a name="l00143"></a>00143 <span class="comment"> */</span>
<a name="l00144"></a>00144 <span class="keywordtype">void</span> <a class="code" href="res__odbc_8h.html#a78d14d1dd01c269c9c0a47b49475eeea" title="Releases an ODBC object previously allocated by odbc_request_obj().">ast_odbc_release_obj</a>(<span class="keyword">struct</span> <a class="code" href="structodbc__obj.html" title="ODBC container.">odbc_obj</a> *obj);
<a name="l00145"></a>00145 <span class="comment"></span>
<a name="l00146"></a>00146 <span class="comment">/*! </span>
<a name="l00147"></a>00147 <span class="comment"> * \brief Checks an ODBC object to ensure it is still connected</span>
<a name="l00148"></a>00148 <span class="comment"> * \param obj The ODBC object</span>
<a name="l00149"></a>00149 <span class="comment"> * \retval 0 if connected</span>
<a name="l00150"></a>00150 <span class="comment"> * \retval -1 otherwise.</span>
<a name="l00151"></a>00151 <span class="comment"> */</span>
<a name="l00152"></a>00152 <span class="keywordtype">int</span> <a class="code" href="res__odbc_8h.html#a91a6be5993a0928cd527b584ec3407b7" title="Checks an ODBC object to ensure it is still connected.">ast_odbc_sanity_check</a>(<span class="keyword">struct</span> <a class="code" href="structodbc__obj.html" title="ODBC container.">odbc_obj</a> *obj);
<a name="l00153"></a>00153 <span class="comment"></span>
<a name="l00154"></a>00154 <span class="comment">/*! \brief Checks if the database natively supports backslash as an escape character.</span>
<a name="l00155"></a>00155 <span class="comment"> * \param obj The ODBC object</span>
<a name="l00156"></a>00156 <span class="comment"> * \return Returns 1 if backslash is a native escape character, 0 if an ESCAPE clause is needed to support &apos;\&apos;</span>
<a name="l00157"></a>00157 <span class="comment"> */</span>
<a name="l00158"></a>00158 <span class="keywordtype">int</span> <a class="code" href="res__odbc_8h.html#a9fb64cb1a2fcc8c4f627fba961f84a4e" title="Checks if the database natively supports backslash as an escape character.">ast_odbc_backslash_is_escape</a>(<span class="keyword">struct</span> <a class="code" href="structodbc__obj.html" title="ODBC container.">odbc_obj</a> *obj);
<a name="l00159"></a>00159 <span class="comment"></span>
<a name="l00160"></a>00160 <span class="comment">/*! \brief Executes an non prepared statement and returns the resulting</span>
<a name="l00161"></a>00161 <span class="comment"> * statement handle.</span>
<a name="l00162"></a>00162 <span class="comment"> * \param obj The ODBC object</span>
<a name="l00163"></a>00163 <span class="comment"> * \param exec_cb A function callback, which, when called, should return a statement handle with result columns bound.</span>
<a name="l00164"></a>00164 <span class="comment"> * \param data A parameter to be passed to the exec_cb parameter function, indicating which statement handle is to be prepared.</span>
<a name="l00165"></a>00165 <span class="comment"> * \retval a statement handle</span>
<a name="l00166"></a>00166 <span class="comment"> * \retval NULL on error</span>
<a name="l00167"></a>00167 <span class="comment"> */</span>
<a name="l00168"></a>00168 SQLHSTMT <a class="code" href="res__odbc_8h.html#ac29fe8d9aba364c43aa8b5c47e48587e" title="Executes an non prepared statement and returns the resulting statement handle.">ast_odbc_direct_execute</a>(<span class="keyword">struct</span> <a class="code" href="structodbc__obj.html" title="ODBC container.">odbc_obj</a> *obj, SQLHSTMT (*exec_cb)(<span class="keyword">struct</span> <a class="code" href="structodbc__obj.html" title="ODBC container.">odbc_obj</a> *obj, <span class="keywordtype">void</span> *data), <span class="keywordtype">void</span> *data);
<a name="l00169"></a>00169 <span class="comment"></span>
<a name="l00170"></a>00170 <span class="comment">/*! </span>
<a name="l00171"></a>00171 <span class="comment"> * \brief Prepares, executes, and returns the resulting statement handle.</span>
<a name="l00172"></a>00172 <span class="comment"> * \param obj The ODBC object</span>
<a name="l00173"></a>00173 <span class="comment"> * \param prepare_cb A function callback, which, when called, should return a statement handle prepared, with any necessary parameters or result columns bound.</span>
<a name="l00174"></a>00174 <span class="comment"> * \param data A parameter to be passed to the prepare_cb parameter function, indicating which statement handle is to be prepared.</span>
<a name="l00175"></a>00175 <span class="comment"> * \retval a statement handle </span>
<a name="l00176"></a>00176 <span class="comment"> * \retval NULL on error</span>
<a name="l00177"></a>00177 <span class="comment"> */</span>
<a name="l00178"></a>00178 SQLHSTMT <a class="code" href="res__odbc_8h.html#ad1e82a2b1ba4eda1924d8b8f591de065" title="Prepares, executes, and returns the resulting statement handle.">ast_odbc_prepare_and_execute</a>(<span class="keyword">struct</span> <a class="code" href="structodbc__obj.html" title="ODBC container.">odbc_obj</a> *obj, SQLHSTMT (*prepare_cb)(<span class="keyword">struct</span> <a class="code" href="structodbc__obj.html" title="ODBC container.">odbc_obj</a> *obj, <span class="keywordtype">void</span> *data), <span class="keywordtype">void</span> *data);
<a name="l00179"></a>00179 <span class="comment"></span>
<a name="l00180"></a>00180 <span class="comment">/*!</span>
<a name="l00181"></a>00181 <span class="comment"> * \brief Find or create an entry describing the table specified.</span>
<a name="l00182"></a>00182 <span class="comment"> * \param database Name of an ODBC class on which to query the table</span>
<a name="l00183"></a>00183 <span class="comment"> * \param tablename Tablename to describe</span>
<a name="l00184"></a>00184 <span class="comment"> * \retval A structure describing the table layout, or NULL, if the table is not found or another error occurs.</span>
<a name="l00185"></a>00185 <span class="comment"> * When a structure is returned, the contained columns list will be</span>
<a name="l00186"></a>00186 <span class="comment"> * rdlock&apos;ed, to ensure that it will be retained in memory.</span>
<a name="l00187"></a>00187 <span class="comment"> * \since 1.6.1</span>
<a name="l00188"></a>00188 <span class="comment"> */</span>
<a name="l00189"></a>00189 <span class="keyword">struct </span>odbc_cache_tables *<a class="code" href="res__odbc_8h.html#aa15ed6f1d16784d3e2961c0bef9352c8" title="Find or create an entry describing the table specified.">ast_odbc_find_table</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> *database, <span class="keyword">const</span> <span class="keywordtype">char</span> *tablename);
<a name="l00190"></a>00190 <span class="comment"></span>
<a name="l00191"></a>00191 <span class="comment">/*!</span>
<a name="l00192"></a>00192 <span class="comment"> * \brief Find a column entry within a cached table structure</span>
<a name="l00193"></a>00193 <span class="comment"> * \param table Cached table structure, as returned from ast_odbc_find_table()</span>
<a name="l00194"></a>00194 <span class="comment"> * \param colname The column name requested</span>
<a name="l00195"></a>00195 <span class="comment"> * \retval A structure describing the column type, or NULL, if the column is not found.</span>
<a name="l00196"></a>00196 <span class="comment"> * \since 1.6.1</span>
<a name="l00197"></a>00197 <span class="comment"> */</span>
<a name="l00198"></a>00198 <span class="keyword">struct </span>odbc_cache_columns *<a class="code" href="res__odbc_8h.html#afa284d7796514825c1783efdd5f29c68" title="Find a column entry within a cached table structure.">ast_odbc_find_column</a>(<span class="keyword">struct</span> odbc_cache_tables *table, <span class="keyword">const</span> <span class="keywordtype">char</span> *colname);
<a name="l00199"></a>00199 <span class="comment"></span>
<a name="l00200"></a>00200 <span class="comment">/*!</span>
<a name="l00201"></a>00201 <span class="comment"> * \brief Remove a cache entry from memory</span>
<a name="l00202"></a>00202 <span class="comment"> * \param database Name of an ODBC class (used to ensure like-named tables in different databases are not confused)</span>
<a name="l00203"></a>00203 <span class="comment"> * \param tablename Tablename for which a cached record should be removed</span>
<a name="l00204"></a>00204 <span class="comment"> * \retval 0 if the cache entry was removed, or -1 if no matching entry was found.</span>
<a name="l00205"></a>00205 <span class="comment"> * \since 1.6.1</span>
<a name="l00206"></a>00206 <span class="comment"> */</span>
<a name="l00207"></a>00207 <span class="keywordtype">int</span> <a class="code" href="res__odbc_8h.html#a8632a3816d017c47147342465a488301" title="Remove a cache entry from memory.">ast_odbc_clear_cache</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> *database, <span class="keyword">const</span> <span class="keywordtype">char</span> *tablename);
<a name="l00208"></a>00208 <span class="comment"></span>
<a name="l00209"></a>00209 <span class="comment">/*!</span>
<a name="l00210"></a>00210 <span class="comment"> * \brief Release a table returned from ast_odbc_find_table</span>
<a name="l00211"></a>00211 <span class="comment"> */</span>
<a name="l00212"></a><a class="code" href="res__odbc_8h.html#a9aaeb9d433261beabf9ae1cc24566397">00212</a> <span class="preprocessor">#define ast_odbc_release_table(ptr) if (ptr) { AST_RWLIST_UNLOCK(&amp;(ptr)-&gt;columns); }</span>
<a name="l00213"></a>00213 <span class="preprocessor"></span><span class="comment"></span>
<a name="l00214"></a>00214 <span class="comment">/*!\brief Wrapper for SQLGetData to use with dynamic strings</span>
<a name="l00215"></a>00215 <span class="comment"> * \param buf Address of the pointer to the ast_str structure.</span>
<a name="l00216"></a>00216 <span class="comment"> * \param pmaxlen The maximum size of the resulting string, or 0 for no limit.</span>
<a name="l00217"></a>00217 <span class="comment"> * \param StatementHandle The statement handle from which to retrieve data.</span>
<a name="l00218"></a>00218 <span class="comment"> * \param ColumnNumber Column number (1-based offset) for which to retrieve data.</span>
<a name="l00219"></a>00219 <span class="comment"> * \param TargetType The SQL constant indicating what kind of data is to be retrieved (usually SQL_CHAR)</span>
<a name="l00220"></a>00220 <span class="comment"> * \param StrLen_or_Ind A pointer to a length indicator, specifying the total length of data.</span>
<a name="l00221"></a>00221 <span class="comment"> */</span>
<a name="l00222"></a>00222 SQLRETURN <a class="code" href="res__odbc_8h.html#ac208eda3a7586ac7aaf63949186f95b4" title="Wrapper for SQLGetData to use with dynamic strings.">ast_odbc_ast_str_SQLGetData</a>(<span class="keyword">struct</span> <a class="code" href="structast__str.html" title="The descriptor of a dynamic string XXX storage will be optimized later if needed...">ast_str</a> **<a class="code" href="adsistub_8c.html#aa95cbf1d00929438101e64ee5a216d0c">buf</a>, <span class="keywordtype">int</span> pmaxlen, SQLHSTMT StatementHandle, SQLUSMALLINT ColumnNumber, SQLSMALLINT TargetType, SQLLEN *StrLen_or_Ind);
<a name="l00223"></a>00223 
<a name="l00224"></a>00224 <span class="preprocessor">#endif </span><span class="comment">/* _ASTERISK_RES_ODBC_H */</span>
</pre></div></div>
<hr size="1"/><address style="text-align: right;"><small>Generated on Wed May 5 15:18:47 2010 for Asterisk - the Open Source PBX by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.1 </small></address>
</body>
</html>
