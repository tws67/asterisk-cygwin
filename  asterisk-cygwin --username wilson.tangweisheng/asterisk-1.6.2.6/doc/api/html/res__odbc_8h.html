<HTML>
    <HEAD>
      <TITLE>Asterisk.org: Developer Documentation (5 May 2010)</TITLE>
      <LINK HREF="doxygen.css" REL="stylesheet" TYPE="text/css">
    </HEAD>
    <BODY BGCOLOR="#FFFFFF">
<div><font size="2" align="right">Wed May 5 15:23:16 2010</font></div>

<h2>Asterisk developer's documentation</h2>
<hr/>
<!-- Generated by Doxygen 1.6.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
  <div class="navpath"><a class="el" href="dir_1ab815038f534adda65c8b4ae4993449.html">include</a>&nbsp;&raquo&nbsp;<a class="el" href="dir_16d825f1fa9ecca2e70b1a8d9256d0e6.html">asterisk</a>
  </div>
</div>
<div class="contents">
<h1>res_odbc.h File Reference</h1>
<p>ODBC resource manager.  
<a href="#_details">More...</a></p>
<code>#include &lt;sql.h&gt;</code><br/>
<code>#include &lt;sqlext.h&gt;</code><br/>
<code>#include &lt;sqltypes.h&gt;</code><br/>
<code>#include &quot;<a class="el" href="linkedlists_8h_source.html">asterisk/linkedlists.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="strings_8h_source.html">asterisk/strings.h</a>&quot;</code><br/>

<p><a href="res__odbc_8h_source.html">Go to the source code of this file.</a></p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Data Structures</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structodbc__cache__tables_1_1__columns.html">_columns</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structodbc__cache__columns.html">odbc_cache_columns</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structodbc__cache__tables.html">odbc_cache_tables</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structodbc__obj.html">odbc_obj</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">ODBC container.  <a href="structodbc__obj.html#_details">More...</a><br/></td></tr>
<tr><td colspan="2"><h2>Defines</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="res__odbc_8h.html#a9aaeb9d433261beabf9ae1cc24566397">ast_odbc_release_table</a>(ptr)&nbsp;&nbsp;&nbsp;if (ptr) { AST_RWLIST_UNLOCK(&amp;(ptr)-&gt;<a class="el" href="structcolumns.html">columns</a>); }</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Release a table returned from ast_odbc_find_table.  <a href="#a9aaeb9d433261beabf9ae1cc24566397"></a><br/></td></tr>
<tr><td colspan="2"><h2>Enumerations</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom">{ <a class="el" href="res__odbc_8h.html#a81929fb3d21206b62f55bcb744f71d5dae38953a3ea0dd8ab9f3994656e1e7fef">RES_ODBC_SANITY_CHECK</a> =  (1 &lt;&lt; 0), 
<a class="el" href="res__odbc_8h.html#a81929fb3d21206b62f55bcb744f71d5da90538ee30927dd290253a4774e361087">RES_ODBC_INDEPENDENT_CONNECTION</a> =  (1 &lt;&lt; 1)
 }</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p>Flags for use with. </p>
 <a href="res__odbc_8h.html#a81929fb3d21206b62f55bcb744f71d5d">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="res__odbc_8h.html#a105a23abbc3dcfda7728a1a39987b3d6">odbc_status</a> { <a class="el" href="res__odbc_8h.html#a105a23abbc3dcfda7728a1a39987b3d6ac683a4e66b82f69b00b54e279697fa92">ODBC_SUCCESS</a> = 0, 
<a class="el" href="res__odbc_8h.html#a105a23abbc3dcfda7728a1a39987b3d6a727133c18382293823de31545d7c5175">ODBC_FAIL</a> = -1
 }</td></tr>
<tr><td colspan="2"><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">SQLRETURN&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="res__odbc_8h.html#ac208eda3a7586ac7aaf63949186f95b4">ast_odbc_ast_str_SQLGetData</a> (struct <a class="el" href="structast__str.html">ast_str</a> **<a class="el" href="adsistub_8c.html#aa95cbf1d00929438101e64ee5a216d0c">buf</a>, int pmaxlen, SQLHSTMT StatementHandle, SQLUSMALLINT ColumnNumber, SQLSMALLINT TargetType, SQLLEN *StrLen_or_Ind)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Wrapper for SQLGetData to use with dynamic strings.  <a href="#ac208eda3a7586ac7aaf63949186f95b4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="res__odbc_8h.html#a9fb64cb1a2fcc8c4f627fba961f84a4e">ast_odbc_backslash_is_escape</a> (struct <a class="el" href="structodbc__obj.html">odbc_obj</a> *obj)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Checks if the database natively supports backslash as an escape character.  <a href="#a9fb64cb1a2fcc8c4f627fba961f84a4e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="res__odbc_8h.html#a8632a3816d017c47147342465a488301">ast_odbc_clear_cache</a> (const char *database, const char *tablename)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Remove a cache entry from memory.  <a href="#a8632a3816d017c47147342465a488301"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">SQLHSTMT&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="res__odbc_8h.html#ac29fe8d9aba364c43aa8b5c47e48587e">ast_odbc_direct_execute</a> (struct <a class="el" href="structodbc__obj.html">odbc_obj</a> *obj, SQLHSTMT(*exec_cb)(struct <a class="el" href="structodbc__obj.html">odbc_obj</a> *obj, void *data), void *data)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Executes an non prepared statement and returns the resulting statement handle.  <a href="#ac29fe8d9aba364c43aa8b5c47e48587e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structodbc__cache__columns.html">odbc_cache_columns</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="res__odbc_8h.html#afa284d7796514825c1783efdd5f29c68">ast_odbc_find_column</a> (struct <a class="el" href="structodbc__cache__tables.html">odbc_cache_tables</a> *<a class="el" href="cdr__sqlite3__custom_8c.html#aa334abe35e252ebf7a2c7c29572bc60f">table</a>, const char *colname)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Find a column entry within a cached table structure.  <a href="#afa284d7796514825c1783efdd5f29c68"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structodbc__cache__tables.html">odbc_cache_tables</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="res__odbc_8h.html#aa15ed6f1d16784d3e2961c0bef9352c8">ast_odbc_find_table</a> (const char *database, const char *tablename)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Find or create an entry describing the table specified.  <a href="#aa15ed6f1d16784d3e2961c0bef9352c8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">SQLHSTMT&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="res__odbc_8h.html#ad1e82a2b1ba4eda1924d8b8f591de065">ast_odbc_prepare_and_execute</a> (struct <a class="el" href="structodbc__obj.html">odbc_obj</a> *obj, SQLHSTMT(*prepare_cb)(struct <a class="el" href="structodbc__obj.html">odbc_obj</a> *obj, void *data), void *data)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Prepares, executes, and returns the resulting statement handle.  <a href="#ad1e82a2b1ba4eda1924d8b8f591de065"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="res__odbc_8h.html#a78d14d1dd01c269c9c0a47b49475eeea">ast_odbc_release_obj</a> (struct <a class="el" href="structodbc__obj.html">odbc_obj</a> *obj)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Releases an ODBC object previously allocated by odbc_request_obj().  <a href="#a78d14d1dd01c269c9c0a47b49475eeea"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structodbc__obj.html">odbc_obj</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="res__odbc_8h.html#ad34ae2bdba165ef6c7405afc94f2a7f3">ast_odbc_request_obj</a> (const char *<a class="el" href="channel_8c.html#a8f8f80d37794cde9472343e4487ba3eb">name</a>, int check)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structodbc__obj.html">odbc_obj</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="res__odbc_8h.html#a84fc89afd16a11b3a1095fb108e2a7ec">ast_odbc_request_obj2</a> (const char *<a class="el" href="channel_8c.html#a8f8f80d37794cde9472343e4487ba3eb">name</a>, struct <a class="el" href="structast__flags.html">ast_flags</a> flags)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves a connected ODBC object.  <a href="#a84fc89afd16a11b3a1095fb108e2a7ec"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structodbc__obj.html">odbc_obj</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="res__odbc_8h.html#a14e6fc16f400d47e35ef4a0f2b220c53">ast_odbc_retrieve_transaction_obj</a> (struct <a class="el" href="structast__channel.html">ast_channel</a> *<a class="el" href="adsistub_8c.html#a322af389d034b8f1282da0a853ffb921">chan</a>, const char *objname)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieve a stored ODBC object, if a transaction has been started.  <a href="#a14e6fc16f400d47e35ef4a0f2b220c53"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="res__odbc_8h.html#a91a6be5993a0928cd527b584ec3407b7">ast_odbc_sanity_check</a> (struct <a class="el" href="structodbc__obj.html">odbc_obj</a> *obj)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Checks an ODBC object to ensure it is still connected.  <a href="#a91a6be5993a0928cd527b584ec3407b7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="res__odbc_8h.html#af8da93ee13b95c6aae6a79558869812a">ast_odbc_smart_execute</a> (struct <a class="el" href="structodbc__obj.html">odbc_obj</a> *obj, SQLHSTMT stmt)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Executes a prepared statement handle.  <a href="#af8da93ee13b95c6aae6a79558869812a"></a><br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>ODBC resource manager. </p>

<p>Definition in file <a class="el" href="res__odbc_8h_source.html">res_odbc.h</a>.</p>
<hr/><h2>Define Documentation</h2>
<a class="anchor" id="a9aaeb9d433261beabf9ae1cc24566397"></a><!-- doxytag: member="res_odbc.h::ast_odbc_release_table" ref="a9aaeb9d433261beabf9ae1cc24566397" args="(ptr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ast_odbc_release_table</td>
          <td>(</td>
          <td class="paramtype">ptr&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td>&nbsp;&nbsp;&nbsp;if (ptr) { AST_RWLIST_UNLOCK(&amp;(ptr)-&gt;<a class="el" href="structcolumns.html">columns</a>); }</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Release a table returned from ast_odbc_find_table. </p>

<p>Definition at line <a class="el" href="res__odbc_8h_source.html#l00212">212</a> of file <a class="el" href="res__odbc_8h_source.html">res_odbc.h</a>.</p>

<p>Referenced by <a class="el" href="res__config__odbc_8c_source.html#l00485">update2_prepare()</a>, and <a class="el" href="res__config__odbc_8c_source.html#l00404">update_odbc()</a>.</p>

</div>
</div>
<hr/><h2>Enumeration Type Documentation</h2>
<a class="anchor" id="a81929fb3d21206b62f55bcb744f71d5d"></a><!-- doxytag: member="res_odbc.h::@130" ref="a81929fb3d21206b62f55bcb744f71d5d" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">anonymous enum</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Flags for use with. </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="res__odbc_8c.html#a84fc89afd16a11b3a1095fb108e2a7ec" title="Retrieves a connected ODBC object.">ast_odbc_request_obj2</a> </dd></dl>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="a81929fb3d21206b62f55bcb744f71d5dae38953a3ea0dd8ab9f3994656e1e7fef"></a><!-- doxytag: member="RES_ODBC_SANITY_CHECK" ref="a81929fb3d21206b62f55bcb744f71d5dae38953a3ea0dd8ab9f3994656e1e7fef" args="" -->RES_ODBC_SANITY_CHECK</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a81929fb3d21206b62f55bcb744f71d5da90538ee30927dd290253a4774e361087"></a><!-- doxytag: member="RES_ODBC_INDEPENDENT_CONNECTION" ref="a81929fb3d21206b62f55bcb744f71d5da90538ee30927dd290253a4774e361087" args="" -->RES_ODBC_INDEPENDENT_CONNECTION</em>&nbsp;</td><td>
</td></tr>
</table>
</dd>
</dl>

<p>Definition at line <a class="el" href="res__odbc_8h_source.html#l00039">39</a> of file <a class="el" href="res__odbc_8h_source.html">res_odbc.h</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00039"></a>00039      {
<a name="l00040"></a>00040    <a class="code" href="res__odbc_8h.html#a81929fb3d21206b62f55bcb744f71d5dae38953a3ea0dd8ab9f3994656e1e7fef">RES_ODBC_SANITY_CHECK</a> = (1 &lt;&lt; 0),
<a name="l00041"></a>00041    <a class="code" href="res__odbc_8h.html#a81929fb3d21206b62f55bcb744f71d5da90538ee30927dd290253a4774e361087">RES_ODBC_INDEPENDENT_CONNECTION</a> = (1 &lt;&lt; 1),
<a name="l00042"></a>00042 };
</pre></div></p>

</div>
</div>
<a class="anchor" id="a105a23abbc3dcfda7728a1a39987b3d6"></a><!-- doxytag: member="res_odbc.h::odbc_status" ref="a105a23abbc3dcfda7728a1a39987b3d6" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="res__odbc_8h.html#a105a23abbc3dcfda7728a1a39987b3d6">odbc_status</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="a105a23abbc3dcfda7728a1a39987b3d6ac683a4e66b82f69b00b54e279697fa92"></a><!-- doxytag: member="ODBC_SUCCESS" ref="a105a23abbc3dcfda7728a1a39987b3d6ac683a4e66b82f69b00b54e279697fa92" args="" -->ODBC_SUCCESS</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a105a23abbc3dcfda7728a1a39987b3d6a727133c18382293823de31545d7c5175"></a><!-- doxytag: member="ODBC_FAIL" ref="a105a23abbc3dcfda7728a1a39987b3d6a727133c18382293823de31545d7c5175" args="" -->ODBC_FAIL</em>&nbsp;</td><td>
</td></tr>
</table>
</dd>
</dl>

<p>Definition at line <a class="el" href="res__odbc_8h_source.html#l00036">36</a> of file <a class="el" href="res__odbc_8h_source.html">res_odbc.h</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00036"></a>00036 { <a class="code" href="res__odbc_8h.html#a105a23abbc3dcfda7728a1a39987b3d6ac683a4e66b82f69b00b54e279697fa92">ODBC_SUCCESS</a>=0, <a class="code" href="res__odbc_8h.html#a105a23abbc3dcfda7728a1a39987b3d6a727133c18382293823de31545d7c5175">ODBC_FAIL</a>=-1} <a class="code" href="res__odbc_8h.html#a105a23abbc3dcfda7728a1a39987b3d6">odbc_status</a>;
</pre></div></p>

</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="ac208eda3a7586ac7aaf63949186f95b4"></a><!-- doxytag: member="res_odbc.h::ast_odbc_ast_str_SQLGetData" ref="ac208eda3a7586ac7aaf63949186f95b4" args="(struct ast_str **buf, int pmaxlen, SQLHSTMT StatementHandle, SQLUSMALLINT ColumnNumber, SQLSMALLINT TargetType, SQLLEN *StrLen_or_Ind)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SQLRETURN ast_odbc_ast_str_SQLGetData </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structast__str.html">ast_str</a> **&nbsp;</td>
          <td class="paramname"> <em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>pmaxlen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SQLHSTMT&nbsp;</td>
          <td class="paramname"> <em>StatementHandle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SQLUSMALLINT&nbsp;</td>
          <td class="paramname"> <em>ColumnNumber</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SQLSMALLINT&nbsp;</td>
          <td class="paramname"> <em>TargetType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SQLLEN *&nbsp;</td>
          <td class="paramname"> <em>StrLen_or_Ind</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Wrapper for SQLGetData to use with dynamic strings. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>buf</em>&nbsp;</td><td>Address of the pointer to the <a class="el" href="structast__str.html" title="The descriptor of a dynamic string XXX storage will be optimized later if needed...">ast_str</a> structure. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pmaxlen</em>&nbsp;</td><td>The maximum size of the resulting string, or 0 for no limit. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>StatementHandle</em>&nbsp;</td><td>The statement handle from which to retrieve data. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ColumnNumber</em>&nbsp;</td><td>Column <a class="el" href="structnumber.html" title="Number structure.">number</a> (1-based offset) for which to retrieve data. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>TargetType</em>&nbsp;</td><td>The SQL constant indicating what kind of data is to be retrieved (usually SQL_CHAR) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>StrLen_or_Ind</em>&nbsp;</td><td>A pointer to a length indicator, specifying the total length of data. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="res__odbc_8c_source.html#l00678">678</a> of file <a class="el" href="res__odbc_8c_source.html">res_odbc.c</a>.</p>

<p>References <a class="el" href="strings_8h_source.html#l00488">ast_str_buffer()</a>, <a class="el" href="strings_8h_source.html#l00573">ast_str_make_space()</a>, <a class="el" href="strings_8h_source.html#l00477">ast_str_size()</a>, and <a class="el" href="strings_8h_source.html#l00441">ast_str_update()</a>.</p>

<p>Referenced by <a class="el" href="func__odbc_8c_source.html#l00375">acf_odbc_read()</a>, and <a class="el" href="func__odbc_8c_source.html#l00978">cli_odbc_read()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00679"></a>00679 {
<a name="l00680"></a>00680    SQLRETURN res;
<a name="l00681"></a>00681 
<a name="l00682"></a>00682    <span class="keywordflow">if</span> (pmaxlen == 0) {
<a name="l00683"></a>00683       <span class="keywordflow">if</span> (SQLGetData(StatementHandle, ColumnNumber, TargetType, <a class="code" href="strings_8h.html#a053bdfc229997a75f112bdd7b995e00b" title="Returns the string buffer within the ast_str buf.">ast_str_buffer</a>(*buf), 0, StrLen_or_Ind) == SQL_SUCCESS_WITH_INFO) {
<a name="l00684"></a>00684          <a class="code" href="strings_8h.html#a7f20a4560b028f55b5d723f02f5830cb">ast_str_make_space</a>(buf, *StrLen_or_Ind + 1);
<a name="l00685"></a>00685       }
<a name="l00686"></a>00686    } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (pmaxlen &gt; 0) {
<a name="l00687"></a>00687       <a class="code" href="strings_8h.html#a7f20a4560b028f55b5d723f02f5830cb">ast_str_make_space</a>(buf, pmaxlen);
<a name="l00688"></a>00688    }
<a name="l00689"></a>00689    res = SQLGetData(StatementHandle, ColumnNumber, TargetType, <a class="code" href="strings_8h.html#a053bdfc229997a75f112bdd7b995e00b" title="Returns the string buffer within the ast_str buf.">ast_str_buffer</a>(*buf), <a class="code" href="strings_8h.html#ab9726d03e7f9f4746876d71bea28de33" title="Returns the current maximum length (without reallocation) of the current buffer.">ast_str_size</a>(*buf), StrLen_or_Ind);
<a name="l00690"></a>00690    <a class="code" href="strings_8h.html#a8887fcac1220a7528e88efc16f751415" title="Update the length of the buffer, after using ast_str merely as a buffer.">ast_str_update</a>(*buf);
<a name="l00691"></a>00691 
<a name="l00692"></a>00692    <span class="keywordflow">return</span> res;
<a name="l00693"></a>00693 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a9fb64cb1a2fcc8c4f627fba961f84a4e"></a><!-- doxytag: member="res_odbc.h::ast_odbc_backslash_is_escape" ref="a9fb64cb1a2fcc8c4f627fba961f84a4e" args="(struct odbc_obj *obj)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ast_odbc_backslash_is_escape </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structodbc__obj.html">odbc_obj</a> *&nbsp;</td>
          <td class="paramname"> <em>obj</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Checks if the database natively supports backslash as an escape character. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>obj</em>&nbsp;</td><td>The ODBC object </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Returns 1 if backslash is a native escape character, 0 if an ESCAPE clause is needed to support '\' </dd></dl>

<p>Definition at line <a class="el" href="res__odbc_8c_source.html#l01047">1047</a> of file <a class="el" href="res__odbc_8c_source.html">res_odbc.c</a>.</p>

<p>References <a class="el" href="res__odbc_8c_source.html#l00127">odbc_class::backslash_is_escape</a>, and <a class="el" href="res__odbc_8h_source.html#l00048">odbc_obj::parent</a>.</p>

<p>Referenced by <a class="el" href="cdr__adaptive__odbc_8c_source.html#l00343">odbc_log()</a>, <a class="el" href="res__config__odbc_8c_source.html#l00256">realtime_multi_odbc()</a>, and <a class="el" href="res__config__odbc_8c_source.html#l00111">realtime_odbc()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l01048"></a>01048 {
<a name="l01049"></a>01049    <span class="keywordflow">return</span> obj-&gt;<a class="code" href="structodbc__obj.html#a2600ffe90b71935f45a9e36a6b5863c6">parent</a>-&gt;<a class="code" href="structodbc__class.html#a6d5083df37a331ad8166d5f658cc900b">backslash_is_escape</a>;
<a name="l01050"></a>01050 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a8632a3816d017c47147342465a488301"></a><!-- doxytag: member="res_odbc.h::ast_odbc_clear_cache" ref="a8632a3816d017c47147342465a488301" args="(const char *database, const char *tablename)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ast_odbc_clear_cache </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>database</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>tablename</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Remove a cache entry from memory. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>database</em>&nbsp;</td><td>Name of an ODBC class (used to ensure like-named <a class="el" href="structtables.html">tables</a> in different databases are not confused) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>tablename</em>&nbsp;</td><td>Tablename for which a cached record should be removed </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>0</em>&nbsp;</td><td>if the cache entry was removed, or -1 if no matching entry was found. </td></tr>
  </table>
  </dd>
</dl>
<dl class="since"><dt><b>Since:</b></dt><dd>1.6.1 </dd></dl>

<p>Definition at line <a class="el" href="res__odbc_8c_source.html#l00551">551</a> of file <a class="el" href="res__odbc_8c_source.html">res_odbc.c</a>.</p>

<p>References <a class="el" href="linkedlists_8h_source.html#l00553">AST_LIST_REMOVE_CURRENT</a>, <a class="el" href="linkedlists_8h_source.html#l00541">AST_RWLIST_TRAVERSE_SAFE_BEGIN</a>, <a class="el" href="linkedlists_8h_source.html#l00601">AST_RWLIST_TRAVERSE_SAFE_END</a>, <a class="el" href="linkedlists_8h_source.html#l00150">AST_RWLIST_UNLOCK</a>, <a class="el" href="linkedlists_8h_source.html#l00051">AST_RWLIST_WRLOCK</a>, <a class="el" href="res__odbc_8h_source.html#l00074">odbc_cache_tables::connection</a>, <a class="el" href="res__odbc_8c_source.html#l00404">destroy_table_cache()</a>, <a class="el" href="structodbc__class.html#a033c9e1d6a001b7c5dc1a71ab21d0357">odbc_class::list</a>, and <a class="el" href="res__odbc_8h_source.html#l00075">odbc_cache_tables::table</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00552"></a>00552 {
<a name="l00553"></a>00553    <span class="keyword">struct </span><a class="code" href="structodbc__cache__tables.html">odbc_cache_tables</a> *tableptr;
<a name="l00554"></a>00554 
<a name="l00555"></a>00555    <a class="code" href="linkedlists_8h.html#a2d0cf4182bade9f773fb16ff12abe595" title="Write locks a list.">AST_RWLIST_WRLOCK</a>(&amp;<a class="code" href="structodbc__tables.html">odbc_tables</a>);
<a name="l00556"></a>00556    <a class="code" href="linkedlists_8h.html#a21be6da4b2146b04b4868c2be5cae750">AST_RWLIST_TRAVERSE_SAFE_BEGIN</a>(&amp;<a class="code" href="structodbc__tables.html">odbc_tables</a>, tableptr, <a class="code" href="structodbc__cache__tables.html#a5f5e109ccb3b0383bd2b9ceefc3fa56a">list</a>) {
<a name="l00557"></a>00557       <span class="keywordflow">if</span> (strcmp(tableptr-&gt;<a class="code" href="structodbc__cache__tables.html#a2d51bc73bf08dbc3fcf184c65ce6622c">connection</a>, database) == 0 &amp;&amp; strcmp(tableptr-&gt;<a class="code" href="structodbc__cache__tables.html#abc4810aa7718733bfc48b1973f4c92f8">table</a>, tablename) == 0) {
<a name="l00558"></a>00558          <a class="code" href="linkedlists_8h.html#aa8ac496fa9c717d5afb99a02e1e2760c" title="Removes the current entry from a list during a traversal.">AST_LIST_REMOVE_CURRENT</a>(<a class="code" href="structodbc__cache__tables.html#a5f5e109ccb3b0383bd2b9ceefc3fa56a">list</a>);
<a name="l00559"></a>00559          <a class="code" href="res__odbc_8c.html#a9f262bdbb941597f050a0eacbf518d51">destroy_table_cache</a>(tableptr);
<a name="l00560"></a>00560          <span class="keywordflow">break</span>;
<a name="l00561"></a>00561       }
<a name="l00562"></a>00562    }
<a name="l00563"></a>00563    <a class="code" href="linkedlists_8h.html#a6bf0e81cb6ef01532ddebaba68f6de28">AST_RWLIST_TRAVERSE_SAFE_END</a>
<a name="l00564"></a>00564    <a class="code" href="linkedlists_8h.html#a2e9a2518b5029b96671aff6701bd5138" title="Attempts to unlock a read/write based list.">AST_RWLIST_UNLOCK</a>(&amp;<a class="code" href="structodbc__tables.html">odbc_tables</a>);
<a name="l00565"></a>00565    <span class="keywordflow">return</span> tableptr ? 0 : -1;
<a name="l00566"></a>00566 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="ac29fe8d9aba364c43aa8b5c47e48587e"></a><!-- doxytag: member="res_odbc.h::ast_odbc_direct_execute" ref="ac29fe8d9aba364c43aa8b5c47e48587e" args="(struct odbc_obj *obj, SQLHSTMT(*exec_cb)(struct odbc_obj *obj, void *data), void *data)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SQLHSTMT ast_odbc_direct_execute </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structodbc__obj.html">odbc_obj</a> *&nbsp;</td>
          <td class="paramname"> <em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SQLHSTMT(*)(struct <a class="el" href="structodbc__obj.html">odbc_obj</a> *obj, void *data)&nbsp;</td>
          <td class="paramname"> <em>exec_cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>data</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Executes an non prepared statement and returns the resulting statement handle. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>obj</em>&nbsp;</td><td>The ODBC object </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>exec_cb</em>&nbsp;</td><td>A function callback, which, when called, should return a statement handle with result <a class="el" href="structcolumns.html">columns</a> bound. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>data</em>&nbsp;</td><td>A parameter to be passed to the exec_cb parameter function, indicating which statement handle is to be prepared. </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>a</em>&nbsp;</td><td>statement handle </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>NULL</em>&nbsp;</td><td>on error </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="res__odbc_8c_source.html#l00568">568</a> of file <a class="el" href="res__odbc_8c_source.html">res_odbc.c</a>.</p>

<p>References <a class="el" href="logger_8c_source.html#l01090">ast_log()</a>, <a class="el" href="logger_8h_source.html#l00152">LOG_WARNING</a>, <a class="el" href="res__odbc_8c_source.html#l01411">odbc_obj_connect()</a>, <a class="el" href="res__odbc_8c_source.html#l01374">odbc_obj_disconnect()</a>, <a class="el" href="res__odbc_8h_source.html#l00057">odbc_obj::tx</a>, and <a class="el" href="res__odbc_8h_source.html#l00056">odbc_obj::up</a>.</p>

<p>Referenced by <a class="el" href="func__odbc_8c_source.html#l00375">acf_odbc_read()</a>, <a class="el" href="func__odbc_8c_source.html#l00203">acf_odbc_write()</a>, <a class="el" href="func__odbc_8c_source.html#l00978">cli_odbc_read()</a>, <a class="el" href="func__odbc_8c_source.html#l01177">cli_odbc_write()</a>, and <a class="el" href="cdr__odbc_8c_source.html#l00127">odbc_log()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00569"></a>00569 {
<a name="l00570"></a>00570    <span class="keywordtype">int</span> attempt;
<a name="l00571"></a>00571    SQLHSTMT stmt;
<a name="l00572"></a>00572 
<a name="l00573"></a>00573    <span class="keywordflow">for</span> (attempt = 0; attempt &lt; 2; attempt++) {
<a name="l00574"></a>00574       stmt = exec_cb(obj, data);
<a name="l00575"></a>00575 
<a name="l00576"></a>00576       <span class="keywordflow">if</span> (stmt) {
<a name="l00577"></a>00577          <span class="keywordflow">break</span>;
<a name="l00578"></a>00578       } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (obj-&gt;<a class="code" href="structodbc__obj.html#abc0ea80cbb3a49c87b90be742126523c">tx</a>) {
<a name="l00579"></a>00579          <a class="code" href="logger_8h.html#a93dd824dff97fe84941d6d71b7a3710e" title="Used for sending a log message This is the standard logger function. Probably the...">ast_log</a>(<a class="code" href="logger_8h.html#adf4476a6a4ea6c74231c826e899d7189">LOG_WARNING</a>, <span class="stringliteral">&quot;Failed to execute, but unable to reconnect, as we&apos;re transactional.\n&quot;</span>);
<a name="l00580"></a>00580          <span class="keywordflow">break</span>;
<a name="l00581"></a>00581       } <span class="keywordflow">else</span> {
<a name="l00582"></a>00582          obj-&gt;<a class="code" href="structodbc__obj.html#a8042aba89daa6448b14e94e6d0bb63bf">up</a> = 0;
<a name="l00583"></a>00583          <a class="code" href="logger_8h.html#a93dd824dff97fe84941d6d71b7a3710e" title="Used for sending a log message This is the standard logger function. Probably the...">ast_log</a>(<a class="code" href="logger_8h.html#adf4476a6a4ea6c74231c826e899d7189">LOG_WARNING</a>, <span class="stringliteral">&quot;SQL Exec Direct failed.  Attempting a reconnect...\n&quot;</span>);
<a name="l00584"></a>00584 
<a name="l00585"></a>00585          <a class="code" href="res__odbc_8c.html#ac83b00e5ebe4dcb0af74363ac609c8d5">odbc_obj_disconnect</a>(obj);
<a name="l00586"></a>00586          <a class="code" href="res__odbc_8c.html#a5f3e9c3099b36a9c5cf70c19f9935d38">odbc_obj_connect</a>(obj);
<a name="l00587"></a>00587       }
<a name="l00588"></a>00588    }
<a name="l00589"></a>00589 
<a name="l00590"></a>00590    <span class="keywordflow">return</span> stmt;
<a name="l00591"></a>00591 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="afa284d7796514825c1783efdd5f29c68"></a><!-- doxytag: member="res_odbc.h::ast_odbc_find_column" ref="afa284d7796514825c1783efdd5f29c68" args="(struct odbc_cache_tables *table, const char *colname)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structodbc__cache__columns.html">odbc_cache_columns</a>* ast_odbc_find_column </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structodbc__cache__tables.html">odbc_cache_tables</a> *&nbsp;</td>
          <td class="paramname"> <em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>colname</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [read]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Find a column entry within a cached table structure. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>table</em>&nbsp;</td><td>Cached table structure, as returned from <a class="el" href="res__odbc_8h.html#aa15ed6f1d16784d3e2961c0bef9352c8" title="Find or create an entry describing the table specified.">ast_odbc_find_table()</a> </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>colname</em>&nbsp;</td><td>The column name requested </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>A</em>&nbsp;</td><td>structure describing the column type, or NULL, if the column is not found. </td></tr>
  </table>
  </dd>
</dl>
<dl class="since"><dt><b>Since:</b></dt><dd>1.6.1 </dd></dl>

<p>Definition at line <a class="el" href="res__odbc_8c_source.html#l00540">540</a> of file <a class="el" href="res__odbc_8c_source.html">res_odbc.c</a>.</p>

<p>References <a class="el" href="linkedlists_8h_source.html#l00493">AST_RWLIST_TRAVERSE</a>, <a class="el" href="structodbc__cache__tables.html#a09f857e5d5d25c0d2065acfbb45afe6c">odbc_cache_tables::columns</a>, <a class="el" href="structodbc__class.html#a033c9e1d6a001b7c5dc1a71ab21d0357">odbc_class::list</a>, and <a class="el" href="res__odbc_8h_source.html#l00063">odbc_cache_columns::name</a>.</p>

<p>Referenced by <a class="el" href="res__config__odbc_8c_source.html#l00485">update2_prepare()</a>, and <a class="el" href="res__config__odbc_8c_source.html#l00404">update_odbc()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00541"></a>00541 {
<a name="l00542"></a>00542    <span class="keyword">struct </span><a class="code" href="structodbc__cache__columns.html">odbc_cache_columns</a> *col;
<a name="l00543"></a>00543    <a class="code" href="linkedlists_8h.html#a944b82566722f2247aa35f1328402c98">AST_RWLIST_TRAVERSE</a>(&amp;table-&gt;<a class="code" href="structodbc__cache__tables.html#a09f857e5d5d25c0d2065acfbb45afe6c">columns</a>, col, <a class="code" href="structodbc__cache__columns.html#a104d3ecbbd644ca8156e812056c5ce90">list</a>) {
<a name="l00544"></a>00544       <span class="keywordflow">if</span> (strcasecmp(col-&gt;<a class="code" href="structodbc__cache__columns.html#a5ac083a645d964373f022d03df4849c8">name</a>, colname) == 0) {
<a name="l00545"></a>00545          <span class="keywordflow">return</span> col;
<a name="l00546"></a>00546       }
<a name="l00547"></a>00547    }
<a name="l00548"></a>00548    <span class="keywordflow">return</span> NULL;
<a name="l00549"></a>00549 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="aa15ed6f1d16784d3e2961c0bef9352c8"></a><!-- doxytag: member="res_odbc.h::ast_odbc_find_table" ref="aa15ed6f1d16784d3e2961c0bef9352c8" args="(const char *database, const char *tablename)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structodbc__cache__tables.html">odbc_cache_tables</a>* ast_odbc_find_table </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>database</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>tablename</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [read]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Find or create an entry describing the table specified. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>database</em>&nbsp;</td><td>Name of an ODBC class on which to query the table </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>tablename</em>&nbsp;</td><td>Tablename to describe </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>A</em>&nbsp;</td><td>structure describing the table layout, or NULL, if the table is not found or another error occurs. When a structure is returned, the contained <a class="el" href="structcolumns.html">columns</a> list will be rdlock'ed, to ensure that it will be retained in memory. </td></tr>
  </table>
  </dd>
</dl>
<dl class="since"><dt><b>Since:</b></dt><dd>1.6.1 </dd></dl>

<p>Definition at line <a class="el" href="res__odbc_8c_source.html#l00425">425</a> of file <a class="el" href="res__odbc_8c_source.html">res_odbc.c</a>.</p>

<p>References <a class="el" href="astmm_8h_source.html#l00072">ast_calloc</a>, <a class="el" href="linkedlists_8h_source.html#l00715">AST_LIST_INSERT_TAIL</a>, <a class="el" href="logger_8c_source.html#l01090">ast_log()</a>, <a class="el" href="res__odbc_8c_source.html#l01041">ast_odbc_release_obj()</a>, <a class="el" href="res__odbc_8c_source.html#l01331">ast_odbc_request_obj()</a>, <a class="el" href="res__odbc_8c_source.html#l00695">ast_odbc_sanity_check()</a>, <a class="el" href="linkedlists_8h_source.html#l00623">AST_RWLIST_HEAD_INIT</a>, <a class="el" href="linkedlists_8h_source.html#l00725">AST_RWLIST_INSERT_TAIL</a>, <a class="el" href="linkedlists_8h_source.html#l00077">AST_RWLIST_RDLOCK</a>, <a class="el" href="linkedlists_8h_source.html#l00493">AST_RWLIST_TRAVERSE</a>, <a class="el" href="linkedlists_8h_source.html#l00150">AST_RWLIST_UNLOCK</a>, <a class="el" href="logger_8h_source.html#l00220">ast_verb</a>, <a class="el" href="structodbc__cache__tables.html#a09f857e5d5d25c0d2065acfbb45afe6c">odbc_cache_tables::columns</a>, <a class="el" href="res__odbc_8h_source.html#l00047">odbc_obj::con</a>, <a class="el" href="res__odbc_8h_source.html#l00074">odbc_cache_tables::connection</a>, <a class="el" href="res__odbc_8h_source.html#l00066">odbc_cache_columns::decimals</a>, <a class="el" href="res__odbc_8c_source.html#l00404">destroy_table_cache()</a>, <a class="el" href="structodbc__class.html#a033c9e1d6a001b7c5dc1a71ab21d0357">odbc_class::list</a>, <a class="el" href="logger_8h_source.html#l00163">LOG_ERROR</a>, <a class="el" href="logger_8h_source.html#l00152">LOG_WARNING</a>, <a class="el" href="res__odbc_8h_source.html#l00063">odbc_cache_columns::name</a>, <a class="el" href="res__odbc_8h_source.html#l00068">odbc_cache_columns::nullable</a>, <a class="el" href="res__odbc_8h_source.html#l00069">odbc_cache_columns::octetlen</a>, <a class="el" href="res__odbc_8h_source.html#l00067">odbc_cache_columns::radix</a>, <a class="el" href="res__odbc_8h_source.html#l00065">odbc_cache_columns::size</a>, <a class="el" href="res__odbc_8h_source.html#l00075">odbc_cache_tables::table</a>, and <a class="el" href="res__odbc_8h_source.html#l00064">odbc_cache_columns::type</a>.</p>

<p>Referenced by <a class="el" href="res__config__odbc_8c_source.html#l00884">require_odbc()</a>, <a class="el" href="res__config__odbc_8c_source.html#l00485">update2_prepare()</a>, and <a class="el" href="res__config__odbc_8c_source.html#l00404">update_odbc()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00426"></a>00426 {
<a name="l00427"></a>00427    <span class="keyword">struct </span><a class="code" href="structodbc__cache__tables.html">odbc_cache_tables</a> *tableptr;
<a name="l00428"></a>00428    <span class="keyword">struct </span><a class="code" href="structodbc__cache__columns.html">odbc_cache_columns</a> *entry;
<a name="l00429"></a>00429    <span class="keywordtype">char</span> columnname[80];
<a name="l00430"></a>00430    SQLLEN sqlptr;
<a name="l00431"></a>00431    SQLHSTMT stmt = NULL;
<a name="l00432"></a>00432    <span class="keywordtype">int</span> res = 0, error = 0, <span class="keywordflow">try</span> = 0;
<a name="l00433"></a>00433    <span class="keyword">struct </span><a class="code" href="structodbc__obj.html" title="ODBC container.">odbc_obj</a> *obj = <a class="code" href="res__odbc_8h.html#ad34ae2bdba165ef6c7405afc94f2a7f3">ast_odbc_request_obj</a>(database, 0);
<a name="l00434"></a>00434 
<a name="l00435"></a>00435    <a class="code" href="linkedlists_8h.html#a0a0fe104cc2cc36a43784f886f3ae7dc" title="Read locks a list.">AST_RWLIST_RDLOCK</a>(&amp;<a class="code" href="structodbc__tables.html">odbc_tables</a>);
<a name="l00436"></a>00436    <a class="code" href="linkedlists_8h.html#a944b82566722f2247aa35f1328402c98">AST_RWLIST_TRAVERSE</a>(&amp;<a class="code" href="structodbc__tables.html">odbc_tables</a>, tableptr, <a class="code" href="structodbc__obj.html#aea00fd1bbee2b8de5f83330881655694">list</a>) {
<a name="l00437"></a>00437       <span class="keywordflow">if</span> (strcmp(tableptr-&gt;<a class="code" href="structodbc__cache__tables.html#a2d51bc73bf08dbc3fcf184c65ce6622c">connection</a>, database) == 0 &amp;&amp; strcmp(tableptr-&gt;<a class="code" href="structodbc__cache__tables.html#abc4810aa7718733bfc48b1973f4c92f8">table</a>, tablename) == 0) {
<a name="l00438"></a>00438          <span class="keywordflow">break</span>;
<a name="l00439"></a>00439       }
<a name="l00440"></a>00440    }
<a name="l00441"></a>00441    <span class="keywordflow">if</span> (tableptr) {
<a name="l00442"></a>00442       <a class="code" href="linkedlists_8h.html#a0a0fe104cc2cc36a43784f886f3ae7dc" title="Read locks a list.">AST_RWLIST_RDLOCK</a>(&amp;tableptr-&gt;<a class="code" href="structodbc__cache__tables.html#a09f857e5d5d25c0d2065acfbb45afe6c">columns</a>);
<a name="l00443"></a>00443       <a class="code" href="linkedlists_8h.html#a2e9a2518b5029b96671aff6701bd5138" title="Attempts to unlock a read/write based list.">AST_RWLIST_UNLOCK</a>(&amp;<a class="code" href="structodbc__tables.html">odbc_tables</a>);
<a name="l00444"></a>00444       <span class="keywordflow">if</span> (obj) {
<a name="l00445"></a>00445          <a class="code" href="res__odbc_8h.html#a78d14d1dd01c269c9c0a47b49475eeea" title="Releases an ODBC object previously allocated by odbc_request_obj().">ast_odbc_release_obj</a>(obj);
<a name="l00446"></a>00446       }
<a name="l00447"></a>00447       <span class="keywordflow">return</span> tableptr;
<a name="l00448"></a>00448    }
<a name="l00449"></a>00449 
<a name="l00450"></a>00450    <span class="keywordflow">if</span> (!obj) {
<a name="l00451"></a>00451       <a class="code" href="logger_8h.html#a93dd824dff97fe84941d6d71b7a3710e" title="Used for sending a log message This is the standard logger function. Probably the...">ast_log</a>(<a class="code" href="logger_8h.html#adf4476a6a4ea6c74231c826e899d7189">LOG_WARNING</a>, <span class="stringliteral">&quot;Unable to retrieve database handle for table description &apos;%s@%s&apos;\n&quot;</span>, tablename, database);
<a name="l00452"></a>00452       <a class="code" href="linkedlists_8h.html#a2e9a2518b5029b96671aff6701bd5138" title="Attempts to unlock a read/write based list.">AST_RWLIST_UNLOCK</a>(&amp;<a class="code" href="structodbc__tables.html">odbc_tables</a>);
<a name="l00453"></a>00453       <span class="keywordflow">return</span> NULL;
<a name="l00454"></a>00454    }
<a name="l00455"></a>00455 
<a name="l00456"></a>00456    <span class="comment">/* Table structure not already cached; build it now. */</span>
<a name="l00457"></a>00457    <span class="keywordflow">do</span> {
<a name="l00458"></a>00458       res = SQLAllocHandle(SQL_HANDLE_STMT, obj-&gt;<a class="code" href="structodbc__obj.html#ae83918cc26dc7acd65bbec1712593054">con</a>, &amp;stmt);
<a name="l00459"></a>00459       <span class="keywordflow">if</span> ((res != SQL_SUCCESS) &amp;&amp; (res != SQL_SUCCESS_WITH_INFO)) {
<a name="l00460"></a>00460          <span class="keywordflow">if</span> (<span class="keywordflow">try</span> == 0) {
<a name="l00461"></a>00461             <span class="keywordflow">try</span> = 1;
<a name="l00462"></a>00462             <a class="code" href="res__odbc_8h.html#a91a6be5993a0928cd527b584ec3407b7" title="Checks an ODBC object to ensure it is still connected.">ast_odbc_sanity_check</a>(obj);
<a name="l00463"></a>00463             <span class="keywordflow">continue</span>;
<a name="l00464"></a>00464          }
<a name="l00465"></a>00465          <a class="code" href="logger_8h.html#a93dd824dff97fe84941d6d71b7a3710e" title="Used for sending a log message This is the standard logger function. Probably the...">ast_log</a>(<a class="code" href="logger_8h.html#adf4476a6a4ea6c74231c826e899d7189">LOG_WARNING</a>, <span class="stringliteral">&quot;SQL Alloc Handle failed on connection &apos;%s&apos;!\n&quot;</span>, database);
<a name="l00466"></a>00466          <span class="keywordflow">break</span>;
<a name="l00467"></a>00467       }
<a name="l00468"></a>00468 
<a name="l00469"></a>00469       res = SQLColumns(stmt, NULL, 0, NULL, 0, (<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *)tablename, SQL_NTS, (<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *)<span class="stringliteral">&quot;%&quot;</span>, SQL_NTS);
<a name="l00470"></a>00470       <span class="keywordflow">if</span> ((res != SQL_SUCCESS) &amp;&amp; (res != SQL_SUCCESS_WITH_INFO)) {
<a name="l00471"></a>00471          <span class="keywordflow">if</span> (<span class="keywordflow">try</span> == 0) {
<a name="l00472"></a>00472             <span class="keywordflow">try</span> = 1;
<a name="l00473"></a>00473             SQLFreeHandle(SQL_HANDLE_STMT, stmt);
<a name="l00474"></a>00474             <a class="code" href="res__odbc_8h.html#a91a6be5993a0928cd527b584ec3407b7" title="Checks an ODBC object to ensure it is still connected.">ast_odbc_sanity_check</a>(obj);
<a name="l00475"></a>00475             <span class="keywordflow">continue</span>;
<a name="l00476"></a>00476          }
<a name="l00477"></a>00477          <a class="code" href="logger_8h.html#a93dd824dff97fe84941d6d71b7a3710e" title="Used for sending a log message This is the standard logger function. Probably the...">ast_log</a>(<a class="code" href="logger_8h.html#aced66975c154ea0e2a8ec3bc818b4e08">LOG_ERROR</a>, <span class="stringliteral">&quot;Unable to query database columns on connection &apos;%s&apos;.\n&quot;</span>, database);
<a name="l00478"></a>00478          <span class="keywordflow">break</span>;
<a name="l00479"></a>00479       }
<a name="l00480"></a>00480 
<a name="l00481"></a>00481       <span class="keywordflow">if</span> (!(tableptr = <a class="code" href="astmm_8h.html#a1cb33b63d94fbbde94234b062249e015">ast_calloc</a>(<span class="keyword">sizeof</span>(<span class="keywordtype">char</span>), <span class="keyword">sizeof</span>(*tableptr) + strlen(database) + 1 + strlen(tablename) + 1))) {
<a name="l00482"></a>00482          <a class="code" href="logger_8h.html#a93dd824dff97fe84941d6d71b7a3710e" title="Used for sending a log message This is the standard logger function. Probably the...">ast_log</a>(<a class="code" href="logger_8h.html#aced66975c154ea0e2a8ec3bc818b4e08">LOG_ERROR</a>, <span class="stringliteral">&quot;Out of memory creating entry for table &apos;%s&apos; on connection &apos;%s&apos;\n&quot;</span>, tablename, database);
<a name="l00483"></a>00483          <span class="keywordflow">break</span>;
<a name="l00484"></a>00484       }
<a name="l00485"></a>00485 
<a name="l00486"></a>00486       tableptr-&gt;<a class="code" href="structodbc__cache__tables.html#a2d51bc73bf08dbc3fcf184c65ce6622c">connection</a> = (<span class="keywordtype">char</span> *)tableptr + <span class="keyword">sizeof</span>(*tableptr);
<a name="l00487"></a>00487       tableptr-&gt;<a class="code" href="structodbc__cache__tables.html#abc4810aa7718733bfc48b1973f4c92f8">table</a> = (<span class="keywordtype">char</span> *)tableptr + <span class="keyword">sizeof</span>(*tableptr) + strlen(database) + 1;
<a name="l00488"></a>00488       strcpy(tableptr-&gt;<a class="code" href="structodbc__cache__tables.html#a2d51bc73bf08dbc3fcf184c65ce6622c">connection</a>, database); <span class="comment">/* SAFE */</span>
<a name="l00489"></a>00489       strcpy(tableptr-&gt;<a class="code" href="structodbc__cache__tables.html#abc4810aa7718733bfc48b1973f4c92f8">table</a>, tablename); <span class="comment">/* SAFE */</span>
<a name="l00490"></a>00490       <a class="code" href="linkedlists_8h.html#a389aaa73318087dfed0cdd11e1d3090b" title="Initializes an rwlist head structure.">AST_RWLIST_HEAD_INIT</a>(&amp;(tableptr-&gt;<a class="code" href="structodbc__cache__tables.html#a09f857e5d5d25c0d2065acfbb45afe6c">columns</a>));
<a name="l00491"></a>00491 
<a name="l00492"></a>00492       <span class="keywordflow">while</span> ((res = SQLFetch(stmt)) != SQL_NO_DATA &amp;&amp; res != SQL_ERROR) {
<a name="l00493"></a>00493          SQLGetData(stmt,  4, SQL_C_CHAR, columnname, <span class="keyword">sizeof</span>(columnname), &amp;sqlptr);
<a name="l00494"></a>00494 
<a name="l00495"></a>00495          <span class="keywordflow">if</span> (!(entry = <a class="code" href="astmm_8h.html#a1cb33b63d94fbbde94234b062249e015">ast_calloc</a>(<span class="keyword">sizeof</span>(<span class="keywordtype">char</span>), <span class="keyword">sizeof</span>(*entry) + strlen(columnname) + 1))) {
<a name="l00496"></a>00496             <a class="code" href="logger_8h.html#a93dd824dff97fe84941d6d71b7a3710e" title="Used for sending a log message This is the standard logger function. Probably the...">ast_log</a>(<a class="code" href="logger_8h.html#aced66975c154ea0e2a8ec3bc818b4e08">LOG_ERROR</a>, <span class="stringliteral">&quot;Out of memory creating entry for column &apos;%s&apos; in table &apos;%s&apos; on connection &apos;%s&apos;\n&quot;</span>, columnname, tablename, database);
<a name="l00497"></a>00497             error = 1;
<a name="l00498"></a>00498             <span class="keywordflow">break</span>;
<a name="l00499"></a>00499          }
<a name="l00500"></a>00500          entry-&gt;<a class="code" href="structodbc__cache__columns.html#a5ac083a645d964373f022d03df4849c8">name</a> = (<span class="keywordtype">char</span> *)entry + <span class="keyword">sizeof</span>(*entry);
<a name="l00501"></a>00501          strcpy(entry-&gt;<a class="code" href="structodbc__cache__columns.html#a5ac083a645d964373f022d03df4849c8">name</a>, columnname);
<a name="l00502"></a>00502 
<a name="l00503"></a>00503          SQLGetData(stmt,  5, SQL_C_SHORT, &amp;entry-&gt;<a class="code" href="structodbc__cache__columns.html#a713b6299f1d41d81cf4fec75082f0033">type</a>, <span class="keyword">sizeof</span>(entry-&gt;<a class="code" href="structodbc__cache__columns.html#a713b6299f1d41d81cf4fec75082f0033">type</a>), NULL);
<a name="l00504"></a>00504          SQLGetData(stmt,  7, SQL_C_LONG, &amp;entry-&gt;<a class="code" href="structodbc__cache__columns.html#a8f725e63e7aaa7e48a10d571d6bc5c44">size</a>, <span class="keyword">sizeof</span>(entry-&gt;<a class="code" href="structodbc__cache__columns.html#a8f725e63e7aaa7e48a10d571d6bc5c44">size</a>), NULL);
<a name="l00505"></a>00505          SQLGetData(stmt,  9, SQL_C_SHORT, &amp;entry-&gt;<a class="code" href="structodbc__cache__columns.html#a4655a72259cd34e7468eb595a3fb0c94">decimals</a>, <span class="keyword">sizeof</span>(entry-&gt;<a class="code" href="structodbc__cache__columns.html#a4655a72259cd34e7468eb595a3fb0c94">decimals</a>), NULL);
<a name="l00506"></a>00506          SQLGetData(stmt, 10, SQL_C_SHORT, &amp;entry-&gt;<a class="code" href="structodbc__cache__columns.html#a70c49af130fccda5ef1404bf0a994ef9">radix</a>, <span class="keyword">sizeof</span>(entry-&gt;<a class="code" href="structodbc__cache__columns.html#a70c49af130fccda5ef1404bf0a994ef9">radix</a>), NULL);
<a name="l00507"></a>00507          SQLGetData(stmt, 11, SQL_C_SHORT, &amp;entry-&gt;<a class="code" href="structodbc__cache__columns.html#afa2cba5460bd1d85a31e95654006db4a">nullable</a>, <span class="keyword">sizeof</span>(entry-&gt;<a class="code" href="structodbc__cache__columns.html#afa2cba5460bd1d85a31e95654006db4a">nullable</a>), NULL);
<a name="l00508"></a>00508          SQLGetData(stmt, 16, SQL_C_LONG, &amp;entry-&gt;<a class="code" href="structodbc__cache__columns.html#a8c631ed493ba0edb1d8103971f8f7451">octetlen</a>, <span class="keyword">sizeof</span>(entry-&gt;<a class="code" href="structodbc__cache__columns.html#a8c631ed493ba0edb1d8103971f8f7451">octetlen</a>), NULL);
<a name="l00509"></a>00509 
<a name="l00510"></a>00510          <span class="comment">/* Specification states that the octenlen should be the maximum number of bytes</span>
<a name="l00511"></a>00511 <span class="comment">          * returned in a char or binary column, but it seems that some drivers just set</span>
<a name="l00512"></a>00512 <span class="comment">          * it to NULL. (Bad Postgres! No biscuit!) */</span>
<a name="l00513"></a>00513          <span class="keywordflow">if</span> (entry-&gt;<a class="code" href="structodbc__cache__columns.html#a8c631ed493ba0edb1d8103971f8f7451">octetlen</a> == 0) {
<a name="l00514"></a>00514             entry-&gt;<a class="code" href="structodbc__cache__columns.html#a8c631ed493ba0edb1d8103971f8f7451">octetlen</a> = entry-&gt;<a class="code" href="structodbc__cache__columns.html#a8f725e63e7aaa7e48a10d571d6bc5c44">size</a>;
<a name="l00515"></a>00515          }
<a name="l00516"></a>00516 
<a name="l00517"></a>00517          <a class="code" href="logger_8h.html#ad770f83c71e237e1f64163358ce4e13d">ast_verb</a>(10, <span class="stringliteral">&quot;Found %s column with type %hd with len %ld, octetlen %ld, and numlen (%hd,%hd)\n&quot;</span>, entry-&gt;<a class="code" href="structodbc__cache__columns.html#a5ac083a645d964373f022d03df4849c8">name</a>, entry-&gt;<a class="code" href="structodbc__cache__columns.html#a713b6299f1d41d81cf4fec75082f0033">type</a>, (<span class="keywordtype">long</span>) entry-&gt;<a class="code" href="structodbc__cache__columns.html#a8f725e63e7aaa7e48a10d571d6bc5c44">size</a>, (<span class="keywordtype">long</span>) entry-&gt;<a class="code" href="structodbc__cache__columns.html#a8c631ed493ba0edb1d8103971f8f7451">octetlen</a>, entry-&gt;<a class="code" href="structodbc__cache__columns.html#a4655a72259cd34e7468eb595a3fb0c94">decimals</a>, entry-&gt;<a class="code" href="structodbc__cache__columns.html#a70c49af130fccda5ef1404bf0a994ef9">radix</a>);
<a name="l00518"></a>00518          <span class="comment">/* Insert column info into column list */</span>
<a name="l00519"></a>00519          <a class="code" href="linkedlists_8h.html#a4d258b4525e63c435d7de579d3f46960" title="Appends a list entry to the tail of a list.">AST_LIST_INSERT_TAIL</a>(&amp;(tableptr-&gt;<a class="code" href="structodbc__cache__tables.html#a09f857e5d5d25c0d2065acfbb45afe6c">columns</a>), entry, <a class="code" href="structodbc__obj.html#aea00fd1bbee2b8de5f83330881655694">list</a>);
<a name="l00520"></a>00520       }
<a name="l00521"></a>00521       SQLFreeHandle(SQL_HANDLE_STMT, stmt);
<a name="l00522"></a>00522 
<a name="l00523"></a>00523       <a class="code" href="linkedlists_8h.html#aadda916488b2d151af4426e2f06ad332">AST_RWLIST_INSERT_TAIL</a>(&amp;<a class="code" href="structodbc__tables.html">odbc_tables</a>, tableptr, <a class="code" href="structodbc__obj.html#aea00fd1bbee2b8de5f83330881655694">list</a>);
<a name="l00524"></a>00524       <a class="code" href="linkedlists_8h.html#a0a0fe104cc2cc36a43784f886f3ae7dc" title="Read locks a list.">AST_RWLIST_RDLOCK</a>(&amp;(tableptr-&gt;<a class="code" href="structodbc__cache__tables.html#a09f857e5d5d25c0d2065acfbb45afe6c">columns</a>));
<a name="l00525"></a>00525       <span class="keywordflow">break</span>;
<a name="l00526"></a>00526    } <span class="keywordflow">while</span> (1);
<a name="l00527"></a>00527 
<a name="l00528"></a>00528    <a class="code" href="linkedlists_8h.html#a2e9a2518b5029b96671aff6701bd5138" title="Attempts to unlock a read/write based list.">AST_RWLIST_UNLOCK</a>(&amp;<a class="code" href="structodbc__tables.html">odbc_tables</a>);
<a name="l00529"></a>00529 
<a name="l00530"></a>00530    <span class="keywordflow">if</span> (error) {
<a name="l00531"></a>00531       <a class="code" href="res__odbc_8c.html#a9f262bdbb941597f050a0eacbf518d51">destroy_table_cache</a>(tableptr);
<a name="l00532"></a>00532       tableptr = NULL;
<a name="l00533"></a>00533    }
<a name="l00534"></a>00534    <span class="keywordflow">if</span> (obj) {
<a name="l00535"></a>00535       <a class="code" href="res__odbc_8h.html#a78d14d1dd01c269c9c0a47b49475eeea" title="Releases an ODBC object previously allocated by odbc_request_obj().">ast_odbc_release_obj</a>(obj);
<a name="l00536"></a>00536    }
<a name="l00537"></a>00537    <span class="keywordflow">return</span> tableptr;
<a name="l00538"></a>00538 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="ad1e82a2b1ba4eda1924d8b8f591de065"></a><!-- doxytag: member="res_odbc.h::ast_odbc_prepare_and_execute" ref="ad1e82a2b1ba4eda1924d8b8f591de065" args="(struct odbc_obj *obj, SQLHSTMT(*prepare_cb)(struct odbc_obj *obj, void *data), void *data)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SQLHSTMT ast_odbc_prepare_and_execute </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structodbc__obj.html">odbc_obj</a> *&nbsp;</td>
          <td class="paramname"> <em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SQLHSTMT(*)(struct <a class="el" href="structodbc__obj.html">odbc_obj</a> *obj, void *data)&nbsp;</td>
          <td class="paramname"> <em>prepare_cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>data</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Prepares, executes, and returns the resulting statement handle. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>obj</em>&nbsp;</td><td>The ODBC object </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>prepare_cb</em>&nbsp;</td><td>A function callback, which, when called, should return a statement handle prepared, with any necessary parameters or result <a class="el" href="structcolumns.html">columns</a> bound. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>data</em>&nbsp;</td><td>A parameter to be passed to the prepare_cb parameter function, indicating which statement handle is to be prepared. </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>a</em>&nbsp;</td><td>statement handle </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>NULL</em>&nbsp;</td><td>on error </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="res__odbc_8c_source.html#l00593">593</a> of file <a class="el" href="res__odbc_8c_source.html">res_odbc.c</a>.</p>

<p>References <a class="el" href="logger_8c_source.html#l01090">ast_log()</a>, <a class="el" href="res__odbc_8c_source.html#l00695">ast_odbc_sanity_check()</a>, <a class="el" href="time_8h_source.html#l00141">ast_tvnow()</a>, <a class="el" href="res__odbc_8h_source.html#l00049">odbc_obj::last_used</a>, <a class="el" href="logger_8h_source.html#l00152">LOG_WARNING</a>, <a class="el" href="res__odbc_8h_source.html#l00057">odbc_obj::tx</a>, and <a class="el" href="res__odbc_8h_source.html#l00056">odbc_obj::up</a>.</p>

<p>Referenced by <a class="el" href="res__config__odbc_8c_source.html#l00797">config_odbc()</a>, <a class="el" href="res__config__odbc_8c_source.html#l00709">destroy_odbc()</a>, <a class="el" href="cdr__adaptive__odbc_8c_source.html#l00343">odbc_log()</a>, <a class="el" href="res__config__odbc_8c_source.html#l00256">realtime_multi_odbc()</a>, <a class="el" href="res__config__odbc_8c_source.html#l00111">realtime_odbc()</a>, <a class="el" href="res__config__odbc_8c_source.html#l00633">store_odbc()</a>, <a class="el" href="res__config__odbc_8c_source.html#l00582">update2_odbc()</a>, and <a class="el" href="res__config__odbc_8c_source.html#l00404">update_odbc()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00594"></a>00594 {
<a name="l00595"></a>00595    <span class="keywordtype">int</span> res = 0, i, attempt;
<a name="l00596"></a>00596    SQLINTEGER nativeerror=0, numfields=0;
<a name="l00597"></a>00597    SQLSMALLINT diagbytes=0;
<a name="l00598"></a>00598    <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> <a class="code" href="structstate.html">state</a>[10], diagnostic[256];
<a name="l00599"></a>00599    SQLHSTMT stmt;
<a name="l00600"></a>00600 
<a name="l00601"></a>00601    <span class="keywordflow">for</span> (attempt = 0; attempt &lt; 2; attempt++) {
<a name="l00602"></a>00602       <span class="comment">/* This prepare callback may do more than just prepare -- it may also</span>
<a name="l00603"></a>00603 <span class="comment">       * bind parameters, bind results, etc.  The real key, here, is that</span>
<a name="l00604"></a>00604 <span class="comment">       * when we disconnect, all handles become invalid for most databases.</span>
<a name="l00605"></a>00605 <span class="comment">       * We must therefore redo everything when we establish a new</span>
<a name="l00606"></a>00606 <span class="comment">       * connection. */</span>
<a name="l00607"></a>00607       stmt = prepare_cb(obj, data);
<a name="l00608"></a>00608 
<a name="l00609"></a>00609       <span class="keywordflow">if</span> (stmt) {
<a name="l00610"></a>00610          res = SQLExecute(stmt);
<a name="l00611"></a>00611          <span class="keywordflow">if</span> ((res != SQL_SUCCESS) &amp;&amp; (res != SQL_SUCCESS_WITH_INFO) &amp;&amp; (res != SQL_NO_DATA)) {
<a name="l00612"></a>00612             <span class="keywordflow">if</span> (res == SQL_ERROR) {
<a name="l00613"></a>00613                SQLGetDiagField(SQL_HANDLE_STMT, stmt, 1, SQL_DIAG_NUMBER, &amp;numfields, SQL_IS_INTEGER, &amp;diagbytes);
<a name="l00614"></a>00614                <span class="keywordflow">for</span> (i = 0; i &lt; numfields; i++) {
<a name="l00615"></a>00615                   SQLGetDiagRec(SQL_HANDLE_STMT, stmt, i + 1, state, &amp;nativeerror, diagnostic, <span class="keyword">sizeof</span>(diagnostic), &amp;diagbytes);
<a name="l00616"></a>00616                   <a class="code" href="logger_8h.html#a93dd824dff97fe84941d6d71b7a3710e" title="Used for sending a log message This is the standard logger function. Probably the...">ast_log</a>(<a class="code" href="logger_8h.html#adf4476a6a4ea6c74231c826e899d7189">LOG_WARNING</a>, <span class="stringliteral">&quot;SQL Execute returned an error %d: %s: %s (%d)\n&quot;</span>, res, state, diagnostic, diagbytes);
<a name="l00617"></a>00617                   <span class="keywordflow">if</span> (i &gt; 10) {
<a name="l00618"></a>00618                      <a class="code" href="logger_8h.html#a93dd824dff97fe84941d6d71b7a3710e" title="Used for sending a log message This is the standard logger function. Probably the...">ast_log</a>(<a class="code" href="logger_8h.html#adf4476a6a4ea6c74231c826e899d7189">LOG_WARNING</a>, <span class="stringliteral">&quot;Oh, that was good.  There are really %d diagnostics?\n&quot;</span>, (<span class="keywordtype">int</span>)numfields);
<a name="l00619"></a>00619                      <span class="keywordflow">break</span>;
<a name="l00620"></a>00620                   }
<a name="l00621"></a>00621                }
<a name="l00622"></a>00622             }
<a name="l00623"></a>00623 
<a name="l00624"></a>00624             <span class="keywordflow">if</span> (obj-&gt;<a class="code" href="structodbc__obj.html#abc0ea80cbb3a49c87b90be742126523c">tx</a>) {
<a name="l00625"></a>00625                <a class="code" href="logger_8h.html#a93dd824dff97fe84941d6d71b7a3710e" title="Used for sending a log message This is the standard logger function. Probably the...">ast_log</a>(<a class="code" href="logger_8h.html#adf4476a6a4ea6c74231c826e899d7189">LOG_WARNING</a>, <span class="stringliteral">&quot;SQL Execute error, but unable to reconnect, as we&apos;re transactional.\n&quot;</span>);
<a name="l00626"></a>00626                <span class="keywordflow">break</span>;
<a name="l00627"></a>00627             } <span class="keywordflow">else</span> {
<a name="l00628"></a>00628                <a class="code" href="logger_8h.html#a93dd824dff97fe84941d6d71b7a3710e" title="Used for sending a log message This is the standard logger function. Probably the...">ast_log</a>(<a class="code" href="logger_8h.html#adf4476a6a4ea6c74231c826e899d7189">LOG_WARNING</a>, <span class="stringliteral">&quot;SQL Execute error %d! Attempting a reconnect...\n&quot;</span>, res);
<a name="l00629"></a>00629                SQLFreeHandle(SQL_HANDLE_STMT, stmt);
<a name="l00630"></a>00630                stmt = NULL;
<a name="l00631"></a>00631 
<a name="l00632"></a>00632                obj-&gt;<a class="code" href="structodbc__obj.html#a8042aba89daa6448b14e94e6d0bb63bf">up</a> = 0;
<a name="l00633"></a>00633                <span class="comment">/*</span>
<a name="l00634"></a>00634 <span class="comment">                * While this isn&apos;t the best way to try to correct an error, this won&apos;t automatically</span>
<a name="l00635"></a>00635 <span class="comment">                * fail when the statement handle invalidates.</span>
<a name="l00636"></a>00636 <span class="comment">                */</span>
<a name="l00637"></a>00637                <a class="code" href="res__odbc_8h.html#a91a6be5993a0928cd527b584ec3407b7" title="Checks an ODBC object to ensure it is still connected.">ast_odbc_sanity_check</a>(obj);
<a name="l00638"></a>00638                <span class="keywordflow">continue</span>;
<a name="l00639"></a>00639             }
<a name="l00640"></a>00640          } <span class="keywordflow">else</span> {
<a name="l00641"></a>00641             obj-&gt;<a class="code" href="structodbc__obj.html#a43b2c8a8bf77a2504897ff0da9b0aa90">last_used</a> = <a class="code" href="time_8h.html#abd5ba75c20787bcc479809c53b58406e" title="Returns current timeval. Meant to replace calls to gettimeofday().">ast_tvnow</a>();
<a name="l00642"></a>00642          }
<a name="l00643"></a>00643          <span class="keywordflow">break</span>;
<a name="l00644"></a>00644       } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (attempt == 0) {
<a name="l00645"></a>00645          <a class="code" href="res__odbc_8h.html#a91a6be5993a0928cd527b584ec3407b7" title="Checks an ODBC object to ensure it is still connected.">ast_odbc_sanity_check</a>(obj);
<a name="l00646"></a>00646       }
<a name="l00647"></a>00647    }
<a name="l00648"></a>00648 
<a name="l00649"></a>00649    <span class="keywordflow">return</span> stmt;
<a name="l00650"></a>00650 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a78d14d1dd01c269c9c0a47b49475eeea"></a><!-- doxytag: member="res_odbc.h::ast_odbc_release_obj" ref="a78d14d1dd01c269c9c0a47b49475eeea" args="(struct odbc_obj *obj)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ast_odbc_release_obj </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structodbc__obj.html">odbc_obj</a> *&nbsp;</td>
          <td class="paramname"> <em>obj</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Releases an ODBC object previously allocated by odbc_request_obj(). </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>obj</em>&nbsp;</td><td>The ODBC object </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="res__odbc_8c_source.html#l01041">1041</a> of file <a class="el" href="res__odbc_8c_source.html">res_odbc.c</a>.</p>

<p>References <a class="el" href="res__odbc_8c_source.html#l00204">find_transaction()</a>, and <a class="el" href="res__odbc_8c_source.html#l00982">odbc_release_obj2()</a>.</p>

<p>Referenced by <a class="el" href="func__odbc_8c_source.html#l00375">acf_odbc_read()</a>, <a class="el" href="func__odbc_8c_source.html#l00203">acf_odbc_write()</a>, <a class="el" href="res__odbc_8c_source.html#l00425">ast_odbc_find_table()</a>, <a class="el" href="func__odbc_8c_source.html#l00978">cli_odbc_read()</a>, <a class="el" href="func__odbc_8c_source.html#l01177">cli_odbc_write()</a>, <a class="el" href="res__config__odbc_8c_source.html#l00797">config_odbc()</a>, <a class="el" href="res__config__odbc_8c_source.html#l00709">destroy_odbc()</a>, <a class="el" href="cdr__adaptive__odbc_8c_source.html#l00081">load_config()</a>, <a class="el" href="cdr__adaptive__odbc_8c_source.html#l00343">odbc_log()</a>, <a class="el" href="res__odbc_8c_source.html#l00960">odbc_register_class()</a>, <a class="el" href="res__config__odbc_8c_source.html#l00256">realtime_multi_odbc()</a>, <a class="el" href="res__config__odbc_8c_source.html#l00111">realtime_odbc()</a>, <a class="el" href="res__config__odbc_8c_source.html#l00633">store_odbc()</a>, <a class="el" href="res__config__odbc_8c_source.html#l00582">update2_odbc()</a>, and <a class="el" href="res__config__odbc_8c_source.html#l00404">update_odbc()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l01042"></a>01042 {
<a name="l01043"></a>01043    <span class="keyword">struct </span><a class="code" href="structodbc__txn__frame.html">odbc_txn_frame</a> *tx = <a class="code" href="res__odbc_8c.html#a00e68e8fd24bd80b6fd5f4af94e1b993">find_transaction</a>(NULL, obj, NULL, 0);
<a name="l01044"></a>01044    <a class="code" href="res__odbc_8c.html#a0cb988b805f7ef81fa43f5d8096576d2">odbc_release_obj2</a>(obj, tx);
<a name="l01045"></a>01045 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="ad34ae2bdba165ef6c7405afc94f2a7f3"></a><!-- doxytag: member="res_odbc.h::ast_odbc_request_obj" ref="ad34ae2bdba165ef6c7405afc94f2a7f3" args="(const char *name, int check)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structodbc__obj.html">odbc_obj</a>* ast_odbc_request_obj </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>check</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [read]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="res__odbc_8c_source.html#l01331">1331</a> of file <a class="el" href="res__odbc_8c_source.html">res_odbc.c</a>.</p>

<p>References <a class="el" href="res__odbc_8c_source.html#l01156">ast_odbc_request_obj2()</a>, and <a class="el" href="res__odbc_8h_source.html#l00040">RES_ODBC_SANITY_CHECK</a>.</p>

<p>Referenced by <a class="el" href="func__odbc_8c_source.html#l00375">acf_odbc_read()</a>, <a class="el" href="func__odbc_8c_source.html#l00203">acf_odbc_write()</a>, <a class="el" href="res__odbc_8c_source.html#l00425">ast_odbc_find_table()</a>, <a class="el" href="func__odbc_8c_source.html#l00978">cli_odbc_read()</a>, <a class="el" href="func__odbc_8c_source.html#l01177">cli_odbc_write()</a>, <a class="el" href="res__config__odbc_8c_source.html#l00797">config_odbc()</a>, <a class="el" href="res__config__odbc_8c_source.html#l00709">destroy_odbc()</a>, <a class="el" href="cdr__adaptive__odbc_8c_source.html#l00081">load_config()</a>, <a class="el" href="cdr__adaptive__odbc_8c_source.html#l00343">odbc_log()</a>, <a class="el" href="res__odbc_8c_source.html#l00960">odbc_register_class()</a>, <a class="el" href="res__config__odbc_8c_source.html#l00256">realtime_multi_odbc()</a>, <a class="el" href="res__config__odbc_8c_source.html#l00111">realtime_odbc()</a>, <a class="el" href="res__config__odbc_8c_source.html#l00633">store_odbc()</a>, <a class="el" href="res__config__odbc_8c_source.html#l00582">update2_odbc()</a>, and <a class="el" href="res__config__odbc_8c_source.html#l00404">update_odbc()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l01333"></a>01333 {
<a name="l01334"></a>01334    <span class="keyword">struct </span><a class="code" href="structast__flags.html" title="Structure used to handle boolean flags.">ast_flags</a> <a class="code" href="structast__flags.html#ac92588540e8c1d014a08cd8a45462b19">flags</a> = { check ? <a class="code" href="res__odbc_8h.html#a81929fb3d21206b62f55bcb744f71d5dae38953a3ea0dd8ab9f3994656e1e7fef">RES_ODBC_SANITY_CHECK</a> : 0 };
<a name="l01335"></a>01335 <span class="preprocessor">#ifdef DEBUG_THREADS</span>
<a name="l01336"></a>01336 <span class="preprocessor"></span>   <span class="keywordflow">return</span> _ast_odbc_request_obj2(<a class="code" href="cdr__adaptive__odbc_8c.html#a5ac083a645d964373f022d03df4849c8">name</a>, flags, file, function, lineno);
<a name="l01337"></a>01337 <span class="preprocessor">#else</span>
<a name="l01338"></a>01338 <span class="preprocessor"></span>   <span class="keywordflow">return</span> <a class="code" href="res__odbc_8h.html#a84fc89afd16a11b3a1095fb108e2a7ec" title="Retrieves a connected ODBC object.">ast_odbc_request_obj2</a>(<a class="code" href="cdr__adaptive__odbc_8c.html#a5ac083a645d964373f022d03df4849c8">name</a>, flags);
<a name="l01339"></a>01339 <span class="preprocessor">#endif</span>
<a name="l01340"></a>01340 <span class="preprocessor"></span>}
</pre></div></p>

</div>
</div>
<a class="anchor" id="a84fc89afd16a11b3a1095fb108e2a7ec"></a><!-- doxytag: member="res_odbc.h::ast_odbc_request_obj2" ref="a84fc89afd16a11b3a1095fb108e2a7ec" args="(const char *name, struct ast_flags flags)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structodbc__obj.html">odbc_obj</a>* ast_odbc_request_obj2 </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structast__flags.html">ast_flags</a>&nbsp;</td>
          <td class="paramname"> <em>flags</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [read]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Retrieves a connected ODBC object. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td>The name of the ODBC class for which a connection is needed. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>flags</em>&nbsp;</td><td>Set of flags used to control which connection is returned. </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ODBC</em>&nbsp;</td><td>object </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>NULL</em>&nbsp;</td><td>if there is no connection available with the requested name.</td></tr>
  </table>
  </dd>
</dl>
<p>Connection classes may, in fact, contain multiple connection handles. If the connection is pooled, then each connection will be dedicated to the thread which <a class="el" href="structrequests.html">requests</a> it. Note that all connections should be released when the thread is done by calling odbc_release_obj(), below. </p>

<p>Definition at line <a class="el" href="res__odbc_8c_source.html#l01156">1156</a> of file <a class="el" href="res__odbc_8c_source.html">res_odbc.c</a>.</p>

<p>References <a class="el" href="astobj2_8h_source.html#l00413">ao2_alloc</a>, <a class="el" href="astobj2_8h_source.html#l00916">ao2_callback</a>, <a class="el" href="astobj2_8h_source.html#l00782">ao2_link</a>, <a class="el" href="astobj2_8h_source.html#l00459">ao2_ref</a>, <a class="el" href="res__odbc_8c_source.html#l01126">aoro2_class_cb()</a>, <a class="el" href="res__odbc_8c_source.html#l01140">aoro2_obj_cb()</a>, <a class="el" href="utils_8h_source.html#l00678">ast_assert</a>, <a class="el" href="lock_8h_source.html#l01964">ast_atomic_fetchadd_int()</a>, <a class="el" href="strings_8h_source.html#l00218">ast_copy_string()</a>, <a class="el" href="logger_8c_source.html#l01090">ast_log()</a>, <a class="el" href="lock_8h_source.html#l01692">ast_mutex_init()</a>, <a class="el" href="res__odbc_8c_source.html#l00695">ast_odbc_sanity_check()</a>, <a class="el" href="utils_8h_source.html#l00061">ast_test_flag</a>, <a class="el" href="time_8h_source.html#l00056">ast_tvdiff_sec()</a>, <a class="el" href="time_8h_source.html#l00141">ast_tvnow()</a>, <a class="el" href="res__odbc_8c_source.html#l00136">class_container</a>, <a class="el" href="res__odbc_8h_source.html#l00047">odbc_obj::con</a>, <a class="el" href="res__odbc_8c_source.html#l00131">odbc_class::count</a>, <a class="el" href="res__odbc_8c_source.html#l01138">EOR_TX</a>, <a class="el" href="res__odbc_8c_source.html#l00132">odbc_class::idlecheck</a>, <a class="el" href="res__odbc_8c_source.html#l00129">odbc_class::isolation</a>, <a class="el" href="res__odbc_8h_source.html#l00049">odbc_obj::last_used</a>, <a class="el" href="res__odbc_8h_source.html#l00046">odbc_obj::lock</a>, <a class="el" href="logger_8h_source.html#l00152">LOG_WARNING</a>, <a class="el" href="res__odbc_8c_source.html#l01137">NO_TX</a>, <a class="el" href="res__odbc_8c_source.html#l00133">odbc_class::obj_container</a>, <a class="el" href="res__odbc_8h_source.html#l00036">ODBC_FAIL</a>, <a class="el" href="res__odbc_8c_source.html#l01411">odbc_obj_connect()</a>, <a class="el" href="res__odbc_8c_source.html#l00394">odbc_obj_destructor()</a>, <a class="el" href="res__odbc_8h_source.html#l00048">odbc_obj::parent</a>, <a class="el" href="res__odbc_8h_source.html#l00041">RES_ODBC_INDEPENDENT_CONNECTION</a>, <a class="el" href="res__odbc_8h_source.html#l00040">RES_ODBC_SANITY_CHECK</a>, <a class="el" href="res__odbc_8c_source.html#l01136">USE_TX</a>, and <a class="el" href="res__odbc_8h_source.html#l00055">odbc_obj::used</a>.</p>

<p>Referenced by <a class="el" href="res__odbc_8c_source.html#l01502">acf_transaction_write()</a>, and <a class="el" href="res__odbc_8c_source.html#l01331">ast_odbc_request_obj()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l01158"></a>01158 {
<a name="l01159"></a>01159    <span class="keyword">struct </span><a class="code" href="structodbc__obj.html" title="ODBC container.">odbc_obj</a> *obj = NULL;
<a name="l01160"></a>01160    <span class="keyword">struct </span><a class="code" href="structodbc__class.html">odbc_class</a> *<span class="keyword">class</span>;
<a name="l01161"></a>01161    SQLINTEGER nativeerror=0, numfields=0;
<a name="l01162"></a>01162    SQLSMALLINT diagbytes=0, i;
<a name="l01163"></a>01163    <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> <a class="code" href="structstate.html">state</a>[10], diagnostic[256];
<a name="l01164"></a>01164 
<a name="l01165"></a>01165    <span class="keywordflow">if</span> (!(<span class="keyword">class</span> = <a class="code" href="astobj2_8h.html#a47857055118a703ae87ea5ebaf4842ed">ao2_callback</a>(<a class="code" href="res__odbc_8c.html#a9412fb74c274dc0c012fd7b4f5b6aa71">class_container</a>, 0, <a class="code" href="res__odbc_8c.html#a4774f9275056e3537178e5ce30daf2fa">aoro2_class_cb</a>, (<span class="keywordtype">char</span> *) <a class="code" href="cdr__adaptive__odbc_8c.html#a5ac083a645d964373f022d03df4849c8">name</a>))) {
<a name="l01166"></a>01166       <span class="keywordflow">return</span> NULL;
<a name="l01167"></a>01167    }
<a name="l01168"></a>01168 
<a name="l01169"></a>01169    <a class="code" href="utils_8h.html#a24374da24af1931d8a7ccde5b352bb2c">ast_assert</a>(<a class="code" href="astobj2_8h.html#aaca5e8eac39a22f9da1c36fc6c922270">ao2_ref</a>(<span class="keyword">class</span>, 0) &gt; 1);
<a name="l01170"></a>01170 
<a name="l01171"></a>01171    <span class="keywordflow">if</span> (class-&gt;haspool) {
<a name="l01172"></a>01172       <span class="comment">/* Recycle connections before building another */</span>
<a name="l01173"></a>01173       obj = <a class="code" href="astobj2_8h.html#a47857055118a703ae87ea5ebaf4842ed">ao2_callback</a>(class-&gt;obj_container, 0, <a class="code" href="res__odbc_8c.html#a7e917d482947c7704537c0ca191bfde0">aoro2_obj_cb</a>, <a class="code" href="res__odbc_8c.html#af1e97e0585fe2a1631cbc21d501320f6">EOR_TX</a>);
<a name="l01174"></a>01174 
<a name="l01175"></a>01175       <span class="keywordflow">if</span> (obj) {
<a name="l01176"></a>01176          <a class="code" href="utils_8h.html#a24374da24af1931d8a7ccde5b352bb2c">ast_assert</a>(<a class="code" href="astobj2_8h.html#aaca5e8eac39a22f9da1c36fc6c922270">ao2_ref</a>(obj, 0) &gt; 1);
<a name="l01177"></a>01177       }
<a name="l01178"></a>01178 
<a name="l01179"></a>01179       <span class="keywordflow">if</span> (!obj &amp;&amp; (class-&gt;count &lt; class-&gt;limit)) {
<a name="l01180"></a>01180          obj = <a class="code" href="astobj2_8h.html#ae0422b60d8e25b6962b2d61ae4ddf724">ao2_alloc</a>(<span class="keyword">sizeof</span>(*obj), <a class="code" href="res__odbc_8c.html#a4d57d49f8c33dc81fb16699d63ff8f26">odbc_obj_destructor</a>);
<a name="l01181"></a>01181          <span class="keywordflow">if</span> (!obj) {
<a name="l01182"></a>01182             <a class="code" href="astobj2_8h.html#aaca5e8eac39a22f9da1c36fc6c922270">ao2_ref</a>(<span class="keyword">class</span>, -1);
<a name="l01183"></a>01183             <span class="keywordflow">return</span> NULL;
<a name="l01184"></a>01184          }
<a name="l01185"></a>01185          <a class="code" href="utils_8h.html#a24374da24af1931d8a7ccde5b352bb2c">ast_assert</a>(<a class="code" href="astobj2_8h.html#aaca5e8eac39a22f9da1c36fc6c922270">ao2_ref</a>(obj, 0) == 1);
<a name="l01186"></a>01186          <a class="code" href="lock_8h.html#a5dc895fe6e8c089175159fc22e33fc3b">ast_mutex_init</a>(&amp;obj-&gt;<a class="code" href="structodbc__obj.html#adf04f66344e3fb0a6f6a69bf39d19902">lock</a>);
<a name="l01187"></a>01187          <span class="comment">/* obj inherits the outstanding reference to class */</span>
<a name="l01188"></a>01188          obj-&gt;<a class="code" href="structodbc__obj.html#a2600ffe90b71935f45a9e36a6b5863c6">parent</a> = <span class="keyword">class</span>;
<a name="l01189"></a>01189          <span class="keyword">class </span>= NULL;
<a name="l01190"></a>01190          <span class="keywordflow">if</span> (<a class="code" href="res__odbc_8c.html#a5f3e9c3099b36a9c5cf70c19f9935d38">odbc_obj_connect</a>(obj) == <a class="code" href="res__odbc_8h.html#a105a23abbc3dcfda7728a1a39987b3d6a727133c18382293823de31545d7c5175">ODBC_FAIL</a>) {
<a name="l01191"></a>01191             <a class="code" href="logger_8h.html#a93dd824dff97fe84941d6d71b7a3710e" title="Used for sending a log message This is the standard logger function. Probably the...">ast_log</a>(<a class="code" href="logger_8h.html#adf4476a6a4ea6c74231c826e899d7189">LOG_WARNING</a>, <span class="stringliteral">&quot;Failed to connect to %s\n&quot;</span>, name);
<a name="l01192"></a>01192             <a class="code" href="astobj2_8h.html#aaca5e8eac39a22f9da1c36fc6c922270">ao2_ref</a>(obj, -1);
<a name="l01193"></a>01193             <a class="code" href="utils_8h.html#a24374da24af1931d8a7ccde5b352bb2c">ast_assert</a>(<a class="code" href="astobj2_8h.html#aaca5e8eac39a22f9da1c36fc6c922270">ao2_ref</a>(<span class="keyword">class</span>, 0) &gt; 0);
<a name="l01194"></a>01194             obj = NULL;
<a name="l01195"></a>01195          } <span class="keywordflow">else</span> {
<a name="l01196"></a>01196             obj-&gt;<a class="code" href="structodbc__obj.html#a2590a5f33b83235fcf8740d3bb9b0e98">used</a> = 1;
<a name="l01197"></a>01197             <a class="code" href="astobj2_8h.html#a210544bdcc5afe0601d01d6e529c22d8">ao2_link</a>(obj-&gt;<a class="code" href="structodbc__obj.html#a2600ffe90b71935f45a9e36a6b5863c6">parent</a>-&gt;<a class="code" href="structodbc__class.html#a1e3f049fb8753279ce152d1efb9ff16b">obj_container</a>, obj);
<a name="l01198"></a>01198             <a class="code" href="lock_8h.html#a30df186a6f53f66621e88fae2e7adaf9" title="Atomically add v to *p and return * the previous value of *p. This can be used to...">ast_atomic_fetchadd_int</a>(&amp;obj-&gt;<a class="code" href="structodbc__obj.html#a2600ffe90b71935f45a9e36a6b5863c6">parent</a>-&gt;<a class="code" href="structodbc__class.html#ad43c3812e6d13e0518d9f8b8f463ffcf">count</a>, +1);
<a name="l01199"></a>01199          }
<a name="l01200"></a>01200       } <span class="keywordflow">else</span> {
<a name="l01201"></a>01201          <span class="comment">/* Object is not constructed, so delete outstanding reference to class. */</span>
<a name="l01202"></a>01202          <a class="code" href="astobj2_8h.html#aaca5e8eac39a22f9da1c36fc6c922270">ao2_ref</a>(<span class="keyword">class</span>, -1);
<a name="l01203"></a>01203          <span class="keyword">class </span>= NULL;
<a name="l01204"></a>01204       }
<a name="l01205"></a>01205 
<a name="l01206"></a>01206       <span class="keywordflow">if</span> (obj &amp;&amp; <a class="code" href="utils_8h.html#a00d4c9254c9827d6fa44f17a326744a5">ast_test_flag</a>(&amp;flags, <a class="code" href="res__odbc_8h.html#a81929fb3d21206b62f55bcb744f71d5da90538ee30927dd290253a4774e361087">RES_ODBC_INDEPENDENT_CONNECTION</a>)) {
<a name="l01207"></a>01207          <span class="comment">/* Ensure this connection has autocommit turned off. */</span>
<a name="l01208"></a>01208          <span class="keywordflow">if</span> (SQLSetConnectAttr(obj-&gt;<a class="code" href="structodbc__obj.html#ae83918cc26dc7acd65bbec1712593054">con</a>, SQL_ATTR_AUTOCOMMIT, (<span class="keywordtype">void</span> *)SQL_AUTOCOMMIT_OFF, 0) == SQL_ERROR) {
<a name="l01209"></a>01209             SQLGetDiagField(SQL_HANDLE_DBC, obj-&gt;<a class="code" href="structodbc__obj.html#ae83918cc26dc7acd65bbec1712593054">con</a>, 1, SQL_DIAG_NUMBER, &amp;numfields, SQL_IS_INTEGER, &amp;diagbytes);
<a name="l01210"></a>01210             <span class="keywordflow">for</span> (i = 0; i &lt; numfields; i++) {
<a name="l01211"></a>01211                SQLGetDiagRec(SQL_HANDLE_DBC, obj-&gt;<a class="code" href="structodbc__obj.html#ae83918cc26dc7acd65bbec1712593054">con</a>, i + 1, state, &amp;nativeerror, diagnostic, <span class="keyword">sizeof</span>(diagnostic), &amp;diagbytes);
<a name="l01212"></a>01212                <a class="code" href="logger_8h.html#a93dd824dff97fe84941d6d71b7a3710e" title="Used for sending a log message This is the standard logger function. Probably the...">ast_log</a>(<a class="code" href="logger_8h.html#adf4476a6a4ea6c74231c826e899d7189">LOG_WARNING</a>, <span class="stringliteral">&quot;SQLSetConnectAttr (Autocommit) returned an error: %s: %s\n&quot;</span>, state, diagnostic);
<a name="l01213"></a>01213                <span class="keywordflow">if</span> (i &gt; 10) {
<a name="l01214"></a>01214                   <a class="code" href="logger_8h.html#a93dd824dff97fe84941d6d71b7a3710e" title="Used for sending a log message This is the standard logger function. Probably the...">ast_log</a>(<a class="code" href="logger_8h.html#adf4476a6a4ea6c74231c826e899d7189">LOG_WARNING</a>, <span class="stringliteral">&quot;Oh, that was good.  There are really %d diagnostics?\n&quot;</span>, (<span class="keywordtype">int</span>)numfields);
<a name="l01215"></a>01215                   <span class="keywordflow">break</span>;
<a name="l01216"></a>01216                }
<a name="l01217"></a>01217             }
<a name="l01218"></a>01218          }
<a name="l01219"></a>01219       }
<a name="l01220"></a>01220    } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="utils_8h.html#a00d4c9254c9827d6fa44f17a326744a5">ast_test_flag</a>(&amp;flags, <a class="code" href="res__odbc_8h.html#a81929fb3d21206b62f55bcb744f71d5da90538ee30927dd290253a4774e361087">RES_ODBC_INDEPENDENT_CONNECTION</a>)) {
<a name="l01221"></a>01221       <span class="comment">/* Non-pooled connections -- but must use a separate connection handle */</span>
<a name="l01222"></a>01222       <span class="keywordflow">if</span> (!(obj = <a class="code" href="astobj2_8h.html#a47857055118a703ae87ea5ebaf4842ed">ao2_callback</a>(class-&gt;obj_container, 0, <a class="code" href="res__odbc_8c.html#a7e917d482947c7704537c0ca191bfde0">aoro2_obj_cb</a>, <a class="code" href="res__odbc_8c.html#acc6834ef6d1c44daa24e94fb77a8d98a">USE_TX</a>))) {
<a name="l01223"></a>01223          obj = <a class="code" href="astobj2_8h.html#ae0422b60d8e25b6962b2d61ae4ddf724">ao2_alloc</a>(<span class="keyword">sizeof</span>(*obj), <a class="code" href="res__odbc_8c.html#a4d57d49f8c33dc81fb16699d63ff8f26">odbc_obj_destructor</a>);
<a name="l01224"></a>01224          <span class="keywordflow">if</span> (!obj) {
<a name="l01225"></a>01225             <a class="code" href="astobj2_8h.html#aaca5e8eac39a22f9da1c36fc6c922270">ao2_ref</a>(<span class="keyword">class</span>, -1);
<a name="l01226"></a>01226             <span class="keywordflow">return</span> NULL;
<a name="l01227"></a>01227          }
<a name="l01228"></a>01228          <a class="code" href="lock_8h.html#a5dc895fe6e8c089175159fc22e33fc3b">ast_mutex_init</a>(&amp;obj-&gt;<a class="code" href="structodbc__obj.html#adf04f66344e3fb0a6f6a69bf39d19902">lock</a>);
<a name="l01229"></a>01229          <span class="comment">/* obj inherits the outstanding reference to class */</span>
<a name="l01230"></a>01230          obj-&gt;<a class="code" href="structodbc__obj.html#a2600ffe90b71935f45a9e36a6b5863c6">parent</a> = <span class="keyword">class</span>;
<a name="l01231"></a>01231          <span class="keyword">class </span>= NULL;
<a name="l01232"></a>01232          <span class="keywordflow">if</span> (<a class="code" href="res__odbc_8c.html#a5f3e9c3099b36a9c5cf70c19f9935d38">odbc_obj_connect</a>(obj) == <a class="code" href="res__odbc_8h.html#a105a23abbc3dcfda7728a1a39987b3d6a727133c18382293823de31545d7c5175">ODBC_FAIL</a>) {
<a name="l01233"></a>01233             <a class="code" href="logger_8h.html#a93dd824dff97fe84941d6d71b7a3710e" title="Used for sending a log message This is the standard logger function. Probably the...">ast_log</a>(<a class="code" href="logger_8h.html#adf4476a6a4ea6c74231c826e899d7189">LOG_WARNING</a>, <span class="stringliteral">&quot;Failed to connect to %s\n&quot;</span>, name);
<a name="l01234"></a>01234             <a class="code" href="astobj2_8h.html#aaca5e8eac39a22f9da1c36fc6c922270">ao2_ref</a>(obj, -1);
<a name="l01235"></a>01235             obj = NULL;
<a name="l01236"></a>01236          } <span class="keywordflow">else</span> {
<a name="l01237"></a>01237             obj-&gt;<a class="code" href="structodbc__obj.html#a2590a5f33b83235fcf8740d3bb9b0e98">used</a> = 1;
<a name="l01238"></a>01238             <a class="code" href="astobj2_8h.html#a210544bdcc5afe0601d01d6e529c22d8">ao2_link</a>(obj-&gt;<a class="code" href="structodbc__obj.html#a2600ffe90b71935f45a9e36a6b5863c6">parent</a>-&gt;<a class="code" href="structodbc__class.html#a1e3f049fb8753279ce152d1efb9ff16b">obj_container</a>, obj);
<a name="l01239"></a>01239             <a class="code" href="lock_8h.html#a30df186a6f53f66621e88fae2e7adaf9" title="Atomically add v to *p and return * the previous value of *p. This can be used to...">ast_atomic_fetchadd_int</a>(&amp;obj-&gt;<a class="code" href="structodbc__obj.html#a2600ffe90b71935f45a9e36a6b5863c6">parent</a>-&gt;<a class="code" href="structodbc__class.html#ad43c3812e6d13e0518d9f8b8f463ffcf">count</a>, +1);
<a name="l01240"></a>01240          }
<a name="l01241"></a>01241       }
<a name="l01242"></a>01242 
<a name="l01243"></a>01243       <span class="keywordflow">if</span> (obj &amp;&amp; SQLSetConnectAttr(obj-&gt;<a class="code" href="structodbc__obj.html#ae83918cc26dc7acd65bbec1712593054">con</a>, SQL_ATTR_AUTOCOMMIT, (<span class="keywordtype">void</span> *)SQL_AUTOCOMMIT_OFF, 0) == SQL_ERROR) {
<a name="l01244"></a>01244          SQLGetDiagField(SQL_HANDLE_DBC, obj-&gt;<a class="code" href="structodbc__obj.html#ae83918cc26dc7acd65bbec1712593054">con</a>, 1, SQL_DIAG_NUMBER, &amp;numfields, SQL_IS_INTEGER, &amp;diagbytes);
<a name="l01245"></a>01245          <span class="keywordflow">for</span> (i = 0; i &lt; numfields; i++) {
<a name="l01246"></a>01246             SQLGetDiagRec(SQL_HANDLE_DBC, obj-&gt;<a class="code" href="structodbc__obj.html#ae83918cc26dc7acd65bbec1712593054">con</a>, i + 1, state, &amp;nativeerror, diagnostic, <span class="keyword">sizeof</span>(diagnostic), &amp;diagbytes);
<a name="l01247"></a>01247             <a class="code" href="logger_8h.html#a93dd824dff97fe84941d6d71b7a3710e" title="Used for sending a log message This is the standard logger function. Probably the...">ast_log</a>(<a class="code" href="logger_8h.html#adf4476a6a4ea6c74231c826e899d7189">LOG_WARNING</a>, <span class="stringliteral">&quot;SetConnectAttr (Autocommit) returned an error: %s: %s\n&quot;</span>, state, diagnostic);
<a name="l01248"></a>01248             <span class="keywordflow">if</span> (i &gt; 10) {
<a name="l01249"></a>01249                <a class="code" href="logger_8h.html#a93dd824dff97fe84941d6d71b7a3710e" title="Used for sending a log message This is the standard logger function. Probably the...">ast_log</a>(<a class="code" href="logger_8h.html#adf4476a6a4ea6c74231c826e899d7189">LOG_WARNING</a>, <span class="stringliteral">&quot;Oh, that was good.  There are really %d diagnostics?\n&quot;</span>, (<span class="keywordtype">int</span>)numfields);
<a name="l01250"></a>01250                <span class="keywordflow">break</span>;
<a name="l01251"></a>01251             }
<a name="l01252"></a>01252          }
<a name="l01253"></a>01253       }
<a name="l01254"></a>01254    } <span class="keywordflow">else</span> {
<a name="l01255"></a>01255       <span class="comment">/* Non-pooled connection: multiple modules can use the same connection. */</span>
<a name="l01256"></a>01256       <span class="keywordflow">if</span> ((obj = <a class="code" href="astobj2_8h.html#a47857055118a703ae87ea5ebaf4842ed">ao2_callback</a>(class-&gt;obj_container, 0, <a class="code" href="res__odbc_8c.html#a7e917d482947c7704537c0ca191bfde0">aoro2_obj_cb</a>, <a class="code" href="res__odbc_8c.html#a2ca13cc687b31de4a8cb9071cf5208ef">NO_TX</a>))) {
<a name="l01257"></a>01257          <span class="comment">/* Object is not constructed, so delete outstanding reference to class. */</span>
<a name="l01258"></a>01258          <a class="code" href="utils_8h.html#a24374da24af1931d8a7ccde5b352bb2c">ast_assert</a>(<a class="code" href="astobj2_8h.html#aaca5e8eac39a22f9da1c36fc6c922270">ao2_ref</a>(<span class="keyword">class</span>, 0) &gt; 1);
<a name="l01259"></a>01259          <a class="code" href="astobj2_8h.html#aaca5e8eac39a22f9da1c36fc6c922270">ao2_ref</a>(<span class="keyword">class</span>, -1);
<a name="l01260"></a>01260          <span class="keyword">class </span>= NULL;
<a name="l01261"></a>01261       } <span class="keywordflow">else</span> {
<a name="l01262"></a>01262          <span class="comment">/* No entry: build one */</span>
<a name="l01263"></a>01263          <span class="keywordflow">if</span> (!(obj = <a class="code" href="astobj2_8h.html#ae0422b60d8e25b6962b2d61ae4ddf724">ao2_alloc</a>(<span class="keyword">sizeof</span>(*obj), <a class="code" href="res__odbc_8c.html#a4d57d49f8c33dc81fb16699d63ff8f26">odbc_obj_destructor</a>))) {
<a name="l01264"></a>01264             <a class="code" href="utils_8h.html#a24374da24af1931d8a7ccde5b352bb2c">ast_assert</a>(<a class="code" href="astobj2_8h.html#aaca5e8eac39a22f9da1c36fc6c922270">ao2_ref</a>(<span class="keyword">class</span>, 0) &gt; 1);
<a name="l01265"></a>01265             <a class="code" href="astobj2_8h.html#aaca5e8eac39a22f9da1c36fc6c922270">ao2_ref</a>(<span class="keyword">class</span>, -1);
<a name="l01266"></a>01266             <span class="keywordflow">return</span> NULL;
<a name="l01267"></a>01267          }
<a name="l01268"></a>01268          <a class="code" href="lock_8h.html#a5dc895fe6e8c089175159fc22e33fc3b">ast_mutex_init</a>(&amp;obj-&gt;<a class="code" href="structodbc__obj.html#adf04f66344e3fb0a6f6a69bf39d19902">lock</a>);
<a name="l01269"></a>01269          <span class="comment">/* obj inherits the outstanding reference to class */</span>
<a name="l01270"></a>01270          obj-&gt;<a class="code" href="structodbc__obj.html#a2600ffe90b71935f45a9e36a6b5863c6">parent</a> = <span class="keyword">class</span>;
<a name="l01271"></a>01271          <span class="keyword">class </span>= NULL;
<a name="l01272"></a>01272          <span class="keywordflow">if</span> (<a class="code" href="res__odbc_8c.html#a5f3e9c3099b36a9c5cf70c19f9935d38">odbc_obj_connect</a>(obj) == <a class="code" href="res__odbc_8h.html#a105a23abbc3dcfda7728a1a39987b3d6a727133c18382293823de31545d7c5175">ODBC_FAIL</a>) {
<a name="l01273"></a>01273             <a class="code" href="logger_8h.html#a93dd824dff97fe84941d6d71b7a3710e" title="Used for sending a log message This is the standard logger function. Probably the...">ast_log</a>(<a class="code" href="logger_8h.html#adf4476a6a4ea6c74231c826e899d7189">LOG_WARNING</a>, <span class="stringliteral">&quot;Failed to connect to %s\n&quot;</span>, name);
<a name="l01274"></a>01274             <a class="code" href="astobj2_8h.html#aaca5e8eac39a22f9da1c36fc6c922270">ao2_ref</a>(obj, -1);
<a name="l01275"></a>01275             obj = NULL;
<a name="l01276"></a>01276          } <span class="keywordflow">else</span> {
<a name="l01277"></a>01277             <a class="code" href="astobj2_8h.html#a210544bdcc5afe0601d01d6e529c22d8">ao2_link</a>(obj-&gt;<a class="code" href="structodbc__obj.html#a2600ffe90b71935f45a9e36a6b5863c6">parent</a>-&gt;<a class="code" href="structodbc__class.html#a1e3f049fb8753279ce152d1efb9ff16b">obj_container</a>, obj);
<a name="l01278"></a>01278             <a class="code" href="utils_8h.html#a24374da24af1931d8a7ccde5b352bb2c">ast_assert</a>(<a class="code" href="astobj2_8h.html#aaca5e8eac39a22f9da1c36fc6c922270">ao2_ref</a>(obj, 0) &gt; 1);
<a name="l01279"></a>01279          }
<a name="l01280"></a>01280       }
<a name="l01281"></a>01281 
<a name="l01282"></a>01282       <span class="keywordflow">if</span> (obj &amp;&amp; SQLSetConnectAttr(obj-&gt;<a class="code" href="structodbc__obj.html#ae83918cc26dc7acd65bbec1712593054">con</a>, SQL_ATTR_AUTOCOMMIT, (<span class="keywordtype">void</span> *)SQL_AUTOCOMMIT_ON, 0) == SQL_ERROR) {
<a name="l01283"></a>01283          SQLGetDiagField(SQL_HANDLE_DBC, obj-&gt;<a class="code" href="structodbc__obj.html#ae83918cc26dc7acd65bbec1712593054">con</a>, 1, SQL_DIAG_NUMBER, &amp;numfields, SQL_IS_INTEGER, &amp;diagbytes);
<a name="l01284"></a>01284          <span class="keywordflow">for</span> (i = 0; i &lt; numfields; i++) {
<a name="l01285"></a>01285             SQLGetDiagRec(SQL_HANDLE_DBC, obj-&gt;<a class="code" href="structodbc__obj.html#ae83918cc26dc7acd65bbec1712593054">con</a>, i + 1, state, &amp;nativeerror, diagnostic, <span class="keyword">sizeof</span>(diagnostic), &amp;diagbytes);
<a name="l01286"></a>01286             <a class="code" href="logger_8h.html#a93dd824dff97fe84941d6d71b7a3710e" title="Used for sending a log message This is the standard logger function. Probably the...">ast_log</a>(<a class="code" href="logger_8h.html#adf4476a6a4ea6c74231c826e899d7189">LOG_WARNING</a>, <span class="stringliteral">&quot;SetConnectAttr (Autocommit) returned an error: %s: %s\n&quot;</span>, state, diagnostic);
<a name="l01287"></a>01287             <span class="keywordflow">if</span> (i &gt; 10) {
<a name="l01288"></a>01288                <a class="code" href="logger_8h.html#a93dd824dff97fe84941d6d71b7a3710e" title="Used for sending a log message This is the standard logger function. Probably the...">ast_log</a>(<a class="code" href="logger_8h.html#adf4476a6a4ea6c74231c826e899d7189">LOG_WARNING</a>, <span class="stringliteral">&quot;Oh, that was good.  There are really %d diagnostics?\n&quot;</span>, (<span class="keywordtype">int</span>)numfields);
<a name="l01289"></a>01289                <span class="keywordflow">break</span>;
<a name="l01290"></a>01290             }
<a name="l01291"></a>01291          }
<a name="l01292"></a>01292       }
<a name="l01293"></a>01293    }
<a name="l01294"></a>01294 
<a name="l01295"></a>01295    <span class="comment">/* Set the isolation property */</span>
<a name="l01296"></a>01296    <span class="keywordflow">if</span> (obj &amp;&amp; SQLSetConnectAttr(obj-&gt;<a class="code" href="structodbc__obj.html#ae83918cc26dc7acd65bbec1712593054">con</a>, SQL_ATTR_TXN_ISOLATION, (<span class="keywordtype">void</span> *)(<span class="keywordtype">long</span>)obj-&gt;<a class="code" href="structodbc__obj.html#a2600ffe90b71935f45a9e36a6b5863c6">parent</a>-&gt;<a class="code" href="structodbc__class.html#a6515c3eadbeefabf86e088a2b9a0332e">isolation</a>, 0) == SQL_ERROR) {
<a name="l01297"></a>01297       SQLGetDiagField(SQL_HANDLE_DBC, obj-&gt;<a class="code" href="structodbc__obj.html#ae83918cc26dc7acd65bbec1712593054">con</a>, 1, SQL_DIAG_NUMBER, &amp;numfields, SQL_IS_INTEGER, &amp;diagbytes);
<a name="l01298"></a>01298       <span class="keywordflow">for</span> (i = 0; i &lt; numfields; i++) {
<a name="l01299"></a>01299          SQLGetDiagRec(SQL_HANDLE_DBC, obj-&gt;<a class="code" href="structodbc__obj.html#ae83918cc26dc7acd65bbec1712593054">con</a>, i + 1, state, &amp;nativeerror, diagnostic, <span class="keyword">sizeof</span>(diagnostic), &amp;diagbytes);
<a name="l01300"></a>01300          <a class="code" href="logger_8h.html#a93dd824dff97fe84941d6d71b7a3710e" title="Used for sending a log message This is the standard logger function. Probably the...">ast_log</a>(<a class="code" href="logger_8h.html#adf4476a6a4ea6c74231c826e899d7189">LOG_WARNING</a>, <span class="stringliteral">&quot;SetConnectAttr (Txn isolation) returned an error: %s: %s\n&quot;</span>, state, diagnostic);
<a name="l01301"></a>01301          <span class="keywordflow">if</span> (i &gt; 10) {
<a name="l01302"></a>01302             <a class="code" href="logger_8h.html#a93dd824dff97fe84941d6d71b7a3710e" title="Used for sending a log message This is the standard logger function. Probably the...">ast_log</a>(<a class="code" href="logger_8h.html#adf4476a6a4ea6c74231c826e899d7189">LOG_WARNING</a>, <span class="stringliteral">&quot;Oh, that was good.  There are really %d diagnostics?\n&quot;</span>, (<span class="keywordtype">int</span>)numfields);
<a name="l01303"></a>01303             <span class="keywordflow">break</span>;
<a name="l01304"></a>01304          }
<a name="l01305"></a>01305       }
<a name="l01306"></a>01306    }
<a name="l01307"></a>01307 
<a name="l01308"></a>01308    <span class="keywordflow">if</span> (obj &amp;&amp; <a class="code" href="utils_8h.html#a00d4c9254c9827d6fa44f17a326744a5">ast_test_flag</a>(&amp;flags, <a class="code" href="res__odbc_8h.html#a81929fb3d21206b62f55bcb744f71d5dae38953a3ea0dd8ab9f3994656e1e7fef">RES_ODBC_SANITY_CHECK</a>)) {
<a name="l01309"></a>01309       <a class="code" href="res__odbc_8h.html#a91a6be5993a0928cd527b584ec3407b7" title="Checks an ODBC object to ensure it is still connected.">ast_odbc_sanity_check</a>(obj);
<a name="l01310"></a>01310    } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (obj &amp;&amp; obj-&gt;<a class="code" href="structodbc__obj.html#a2600ffe90b71935f45a9e36a6b5863c6">parent</a>-&gt;<a class="code" href="structodbc__class.html#a7c18ec907c99979db44845239b00d4aa">idlecheck</a> &gt; 0 &amp;&amp; <a class="code" href="time_8h.html#a3f55930df743fa0d76c353f2643e148b" title="Computes the difference (in seconds) between two struct timeval instances.">ast_tvdiff_sec</a>(<a class="code" href="time_8h.html#abd5ba75c20787bcc479809c53b58406e" title="Returns current timeval. Meant to replace calls to gettimeofday().">ast_tvnow</a>(), obj-&gt;<a class="code" href="structodbc__obj.html#a43b2c8a8bf77a2504897ff0da9b0aa90">last_used</a>) &gt; obj-&gt;<a class="code" href="structodbc__obj.html#a2600ffe90b71935f45a9e36a6b5863c6">parent</a>-&gt;<a class="code" href="structodbc__class.html#a7c18ec907c99979db44845239b00d4aa">idlecheck</a>)
<a name="l01311"></a>01311       <a class="code" href="res__odbc_8c.html#a5f3e9c3099b36a9c5cf70c19f9935d38">odbc_obj_connect</a>(obj);
<a name="l01312"></a>01312 
<a name="l01313"></a>01313 <span class="preprocessor">#ifdef DEBUG_THREADS</span>
<a name="l01314"></a>01314 <span class="preprocessor"></span>   <span class="keywordflow">if</span> (obj) {
<a name="l01315"></a>01315       <a class="code" href="strings_8h.html#a17df4d252f3e2ecb230b526475ac4d93" title="Size-limited null-terminating string copy.">ast_copy_string</a>(obj-&gt;file, file, <span class="keyword">sizeof</span>(obj-&gt;file));
<a name="l01316"></a>01316       <a class="code" href="strings_8h.html#a17df4d252f3e2ecb230b526475ac4d93" title="Size-limited null-terminating string copy.">ast_copy_string</a>(obj-&gt;function, function, <span class="keyword">sizeof</span>(obj-&gt;function));
<a name="l01317"></a>01317       obj-&gt;lineno = lineno;
<a name="l01318"></a>01318    }
<a name="l01319"></a>01319 <span class="preprocessor">#endif</span>
<a name="l01320"></a>01320 <span class="preprocessor"></span>   <a class="code" href="utils_8h.html#a24374da24af1931d8a7ccde5b352bb2c">ast_assert</a>(<span class="keyword">class</span> == NULL);
<a name="l01321"></a>01321 
<a name="l01322"></a>01322    <span class="keywordflow">if</span> (obj) {
<a name="l01323"></a>01323       <a class="code" href="utils_8h.html#a24374da24af1931d8a7ccde5b352bb2c">ast_assert</a>(<a class="code" href="astobj2_8h.html#aaca5e8eac39a22f9da1c36fc6c922270">ao2_ref</a>(obj, 0) &gt; 1);
<a name="l01324"></a>01324    }
<a name="l01325"></a>01325    <span class="keywordflow">return</span> obj;
<a name="l01326"></a>01326 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a14e6fc16f400d47e35ef4a0f2b220c53"></a><!-- doxytag: member="res_odbc.h::ast_odbc_retrieve_transaction_obj" ref="a14e6fc16f400d47e35ef4a0f2b220c53" args="(struct ast_channel *chan, const char *objname)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structodbc__obj.html">odbc_obj</a>* ast_odbc_retrieve_transaction_obj </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structast__channel.html">ast_channel</a> *&nbsp;</td>
          <td class="paramname"> <em>chan</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>objname</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [read]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Retrieve a stored ODBC object, if a transaction has been started. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>chan</em>&nbsp;</td><td>Channel associated with the transaction. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>objname</em>&nbsp;</td><td>Name of the database handle. This name corresponds to the name passed to </td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="res__odbc_8c.html#a84fc89afd16a11b3a1095fb108e2a7ec" title="Retrieves a connected ODBC object.">ast_odbc_request_obj2</a> (or formerly, to <a class="el" href="res__odbc_8c.html#ad34ae2bdba165ef6c7405afc94f2a7f3">ast_odbc_request_obj</a>). Note that the existence of this parameter <a class="el" href="channel_8c.html#a8f8f80d37794cde9472343e4487ba3eb">name</a> explicitly allows for multiple transactions to be open at once, albeit to different databases. </dd></dl>
<dl><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>A</em>&nbsp;</td><td>stored ODBC object, if a transaction was already started. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>NULL,if</em>&nbsp;</td><td>no transaction yet exists. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="res__odbc_8c_source.html#l01342">1342</a> of file <a class="el" href="res__odbc_8c_source.html">res_odbc.c</a>.</p>

<p>References <a class="el" href="channel_8c_source.html#l01548">ast_channel_datastore_find()</a>, <a class="el" href="lock_8h_source.html#l02031">ast_channel_lock</a>, <a class="el" href="lock_8h_source.html#l02034">ast_channel_unlock</a>, <a class="el" href="linkedlists_8h_source.html#l00172">AST_LIST_HEAD</a>, <a class="el" href="linkedlists_8h_source.html#l00039">AST_LIST_LOCK</a>, <a class="el" href="linkedlists_8h_source.html#l00490">AST_LIST_TRAVERSE</a>, <a class="el" href="linkedlists_8h_source.html#l00139">AST_LIST_UNLOCK</a>, <a class="el" href="datastore_8h_source.html#l00056">ast_datastore::data</a>, <a class="el" href="structodbc__class.html#a033c9e1d6a001b7c5dc1a71ab21d0357">odbc_class::list</a>, <a class="el" href="res__odbc_8c_source.html#l00119">odbc_class::name</a>, <a class="el" href="res__odbc_8c_source.html#l00156">odbc_txn_frame::obj</a>, <a class="el" href="res__odbc_8h_source.html#l00048">odbc_obj::parent</a>, and <a class="el" href="res__odbc_8c_source.html#l00148">txn_info</a>.</p>

<p>Referenced by <a class="el" href="func__odbc_8c_source.html#l00203">acf_odbc_write()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l01343"></a>01343 {
<a name="l01344"></a>01344    <span class="keyword">struct </span><a class="code" href="structast__datastore.html" title="Structure for a data store object.">ast_datastore</a> *txn_store;
<a name="l01345"></a>01345    <a class="code" href="linkedlists_8h.html#acdb4f56da6b3071d02dcce20072852b0" title="Defines a structure to be used to hold a list of specified type.">AST_LIST_HEAD</a>(, <a class="code" href="structodbc__txn__frame.html">odbc_txn_frame</a>) *oldlist;
<a name="l01346"></a>01346    <span class="keyword">struct </span><a class="code" href="structodbc__txn__frame.html">odbc_txn_frame</a> *txn = NULL;
<a name="l01347"></a>01347 
<a name="l01348"></a>01348    <span class="keywordflow">if</span> (!chan) {
<a name="l01349"></a>01349       <span class="comment">/* No channel == no transaction */</span>
<a name="l01350"></a>01350       <span class="keywordflow">return</span> NULL;
<a name="l01351"></a>01351    }
<a name="l01352"></a>01352 
<a name="l01353"></a>01353    <a class="code" href="lock_8h.html#acbcec0b11bb6e43e0ebcd82828bc8684" title="Lock a channel. If DEBUG_CHANNEL_LOCKS is defined in the Makefile, print relevant...">ast_channel_lock</a>(chan);
<a name="l01354"></a>01354    <span class="keywordflow">if</span> ((txn_store = <a class="code" href="channel_8h.html#aad1e09cd7c79237d05cffb45d6cdfd7c" title="Find a datastore on a channel.">ast_channel_datastore_find</a>(chan, &amp;<a class="code" href="res__odbc_8c.html#a39d901a085de05b4b891f3643347316a">txn_info</a>, NULL))) {
<a name="l01355"></a>01355       oldlist = txn_store-&gt;<a class="code" href="structast__datastore.html#a735984d41155bc1032e09bece8f8d66d">data</a>;
<a name="l01356"></a>01356    } <span class="keywordflow">else</span> {
<a name="l01357"></a>01357       <a class="code" href="lock_8h.html#a853c07107a1385c83c5d2a0ab7e01d79" title="Unlock a channel. If DEBUG_CHANNEL_LOCKS is defined in the Makefile, print relevant...">ast_channel_unlock</a>(chan);
<a name="l01358"></a>01358       <span class="keywordflow">return</span> NULL;
<a name="l01359"></a>01359    }
<a name="l01360"></a>01360 
<a name="l01361"></a>01361    <a class="code" href="linkedlists_8h.html#a9140a4e4d781264fa9469c52b1adae40" title="Locks a list.">AST_LIST_LOCK</a>(oldlist);
<a name="l01362"></a>01362    <a class="code" href="lock_8h.html#a853c07107a1385c83c5d2a0ab7e01d79" title="Unlock a channel. If DEBUG_CHANNEL_LOCKS is defined in the Makefile, print relevant...">ast_channel_unlock</a>(chan);
<a name="l01363"></a>01363 
<a name="l01364"></a>01364    <a class="code" href="linkedlists_8h.html#a3008b2f4f236b72d8bcfb80e346324ef" title="Loops over (traverses) the entries in a list.">AST_LIST_TRAVERSE</a>(oldlist, txn, <a class="code" href="structodbc__txn__frame.html#a6715fc7084c4f5b7aa8ed33db42c33b5">list</a>) {
<a name="l01365"></a>01365       <span class="keywordflow">if</span> (txn-&gt;<a class="code" href="structodbc__txn__frame.html#ab5dd16c9db5f2ee0f0d6354952c92189">obj</a> &amp;&amp; txn-&gt;<a class="code" href="structodbc__txn__frame.html#ab5dd16c9db5f2ee0f0d6354952c92189">obj</a>-&gt;<a class="code" href="structodbc__obj.html#a2600ffe90b71935f45a9e36a6b5863c6">parent</a> &amp;&amp; !strcmp(txn-&gt;<a class="code" href="structodbc__txn__frame.html#ab5dd16c9db5f2ee0f0d6354952c92189">obj</a>-&gt;<a class="code" href="structodbc__obj.html#a2600ffe90b71935f45a9e36a6b5863c6">parent</a>-&gt;<a class="code" href="structodbc__class.html#a3777dbae63a15da001b2baa317a25149">name</a>, objname)) {
<a name="l01366"></a>01366          <a class="code" href="linkedlists_8h.html#ab48cb9e1e612dd486b747ba1c5d68d01" title="Attempts to unlock a list.">AST_LIST_UNLOCK</a>(oldlist);
<a name="l01367"></a>01367          <span class="keywordflow">return</span> txn-&gt;<a class="code" href="structodbc__txn__frame.html#ab5dd16c9db5f2ee0f0d6354952c92189">obj</a>;
<a name="l01368"></a>01368       }
<a name="l01369"></a>01369    }
<a name="l01370"></a>01370    <a class="code" href="linkedlists_8h.html#ab48cb9e1e612dd486b747ba1c5d68d01" title="Attempts to unlock a list.">AST_LIST_UNLOCK</a>(oldlist);
<a name="l01371"></a>01371    <span class="keywordflow">return</span> NULL;
<a name="l01372"></a>01372 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a91a6be5993a0928cd527b584ec3407b7"></a><!-- doxytag: member="res_odbc.h::ast_odbc_sanity_check" ref="a91a6be5993a0928cd527b584ec3407b7" args="(struct odbc_obj *obj)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ast_odbc_sanity_check </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structodbc__obj.html">odbc_obj</a> *&nbsp;</td>
          <td class="paramname"> <em>obj</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Checks an ODBC object to ensure it is still connected. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>obj</em>&nbsp;</td><td>The ODBC object </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>0</em>&nbsp;</td><td>if connected </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>-1</em>&nbsp;</td><td>otherwise. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="res__odbc_8c_source.html#l00695">695</a> of file <a class="el" href="res__odbc_8c_source.html">res_odbc.c</a>.</p>

<p>References <a class="el" href="logger_8c_source.html#l01090">ast_log()</a>, <a class="el" href="strings_8h_source.html#l00063">ast_strlen_zero()</a>, <a class="el" href="res__odbc_8h_source.html#l00047">odbc_obj::con</a>, <a class="el" href="logger_8h_source.html#l00152">LOG_WARNING</a>, <a class="el" href="res__odbc_8c_source.html#l01411">odbc_obj_connect()</a>, <a class="el" href="res__odbc_8c_source.html#l01374">odbc_obj_disconnect()</a>, <a class="el" href="res__odbc_8h_source.html#l00048">odbc_obj::parent</a>, <a class="el" href="res__odbc_8c_source.html#l00123">odbc_class::sanitysql</a>, <a class="el" href="res__odbc_8h_source.html#l00057">odbc_obj::tx</a>, and <a class="el" href="res__odbc_8h_source.html#l00056">odbc_obj::up</a>.</p>

<p>Referenced by <a class="el" href="res__odbc_8c_source.html#l00425">ast_odbc_find_table()</a>, <a class="el" href="res__odbc_8c_source.html#l00593">ast_odbc_prepare_and_execute()</a>, <a class="el" href="res__odbc_8c_source.html#l01156">ast_odbc_request_obj2()</a>, and <a class="el" href="res__odbc_8c_source.html#l00871">handle_cli_odbc_show()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00696"></a>00696 {
<a name="l00697"></a>00697    <span class="keywordtype">char</span> *test_sql = <span class="stringliteral">&quot;select 1&quot;</span>;
<a name="l00698"></a>00698    SQLHSTMT stmt;
<a name="l00699"></a>00699    <span class="keywordtype">int</span> res = 0;
<a name="l00700"></a>00700 
<a name="l00701"></a>00701    <span class="keywordflow">if</span> (!<a class="code" href="strings_8h.html#a5c8aa5212ecb665fb072eac00c799da6">ast_strlen_zero</a>(obj-&gt;<a class="code" href="structodbc__obj.html#a2600ffe90b71935f45a9e36a6b5863c6">parent</a>-&gt;<a class="code" href="structodbc__class.html#af41cb350797c76ea60f9b864e753eb79">sanitysql</a>))
<a name="l00702"></a>00702       test_sql = obj-&gt;<a class="code" href="structodbc__obj.html#a2600ffe90b71935f45a9e36a6b5863c6">parent</a>-&gt;<a class="code" href="structodbc__class.html#af41cb350797c76ea60f9b864e753eb79">sanitysql</a>;
<a name="l00703"></a>00703 
<a name="l00704"></a>00704    <span class="keywordflow">if</span> (obj-&gt;<a class="code" href="structodbc__obj.html#a8042aba89daa6448b14e94e6d0bb63bf">up</a>) {
<a name="l00705"></a>00705       res = SQLAllocHandle(SQL_HANDLE_STMT, obj-&gt;<a class="code" href="structodbc__obj.html#ae83918cc26dc7acd65bbec1712593054">con</a>, &amp;stmt);
<a name="l00706"></a>00706       <span class="keywordflow">if</span> ((res != SQL_SUCCESS) &amp;&amp; (res != SQL_SUCCESS_WITH_INFO)) {
<a name="l00707"></a>00707          obj-&gt;<a class="code" href="structodbc__obj.html#a8042aba89daa6448b14e94e6d0bb63bf">up</a> = 0;
<a name="l00708"></a>00708       } <span class="keywordflow">else</span> {
<a name="l00709"></a>00709          res = SQLPrepare(stmt, (<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *)test_sql, SQL_NTS);
<a name="l00710"></a>00710          <span class="keywordflow">if</span> ((res != SQL_SUCCESS) &amp;&amp; (res != SQL_SUCCESS_WITH_INFO)) {
<a name="l00711"></a>00711             obj-&gt;<a class="code" href="structodbc__obj.html#a8042aba89daa6448b14e94e6d0bb63bf">up</a> = 0;
<a name="l00712"></a>00712          } <span class="keywordflow">else</span> {
<a name="l00713"></a>00713             res = SQLExecute(stmt);
<a name="l00714"></a>00714             <span class="keywordflow">if</span> ((res != SQL_SUCCESS) &amp;&amp; (res != SQL_SUCCESS_WITH_INFO)) {
<a name="l00715"></a>00715                obj-&gt;<a class="code" href="structodbc__obj.html#a8042aba89daa6448b14e94e6d0bb63bf">up</a> = 0;
<a name="l00716"></a>00716             }
<a name="l00717"></a>00717          }
<a name="l00718"></a>00718       }
<a name="l00719"></a>00719       SQLFreeHandle (SQL_HANDLE_STMT, stmt);
<a name="l00720"></a>00720    }
<a name="l00721"></a>00721 
<a name="l00722"></a>00722    <span class="keywordflow">if</span> (!obj-&gt;<a class="code" href="structodbc__obj.html#a8042aba89daa6448b14e94e6d0bb63bf">up</a> &amp;&amp; !obj-&gt;<a class="code" href="structodbc__obj.html#abc0ea80cbb3a49c87b90be742126523c">tx</a>) { <span class="comment">/* Try to reconnect! */</span>
<a name="l00723"></a>00723       <a class="code" href="logger_8h.html#a93dd824dff97fe84941d6d71b7a3710e" title="Used for sending a log message This is the standard logger function. Probably the...">ast_log</a>(<a class="code" href="logger_8h.html#adf4476a6a4ea6c74231c826e899d7189">LOG_WARNING</a>, <span class="stringliteral">&quot;Connection is down attempting to reconnect...\n&quot;</span>);
<a name="l00724"></a>00724       <a class="code" href="res__odbc_8c.html#ac83b00e5ebe4dcb0af74363ac609c8d5">odbc_obj_disconnect</a>(obj);
<a name="l00725"></a>00725       <a class="code" href="res__odbc_8c.html#a5f3e9c3099b36a9c5cf70c19f9935d38">odbc_obj_connect</a>(obj);
<a name="l00726"></a>00726    }
<a name="l00727"></a>00727    <span class="keywordflow">return</span> obj-&gt;<a class="code" href="structodbc__obj.html#a8042aba89daa6448b14e94e6d0bb63bf">up</a>;
<a name="l00728"></a>00728 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="af8da93ee13b95c6aae6a79558869812a"></a><!-- doxytag: member="res_odbc.h::ast_odbc_smart_execute" ref="af8da93ee13b95c6aae6a79558869812a" args="(struct odbc_obj *obj, SQLHSTMT stmt)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ast_odbc_smart_execute </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structodbc__obj.html">odbc_obj</a> *&nbsp;</td>
          <td class="paramname"> <em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SQLHSTMT&nbsp;</td>
          <td class="paramname"> <em>stmt</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Executes a prepared statement handle. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>obj</em>&nbsp;</td><td>The non-NULL result of odbc_request_obj() </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>stmt</em>&nbsp;</td><td>The prepared statement handle </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>0</em>&nbsp;</td><td>on success </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>-1</em>&nbsp;</td><td>on failure</td></tr>
  </table>
  </dd>
</dl>
<p>This function was originally designed simply to execute a prepared statement handle and to retry if the initial execution failed. Unfortunately, it did this by disconnecting and reconnecting the database handle which on most databases causes the statement handle to become invalid. Therefore, this method has been deprecated in favor of odbc_prepare_and_execute() which allows the statement to be prepared multiple times, if necessary, in case of a loss of connection.</p>
<p>This function really only ever worked with MySQL, where the statement handle is not prepared on the server. If you are not using MySQL, you should avoid it. </p>

<p>Definition at line <a class="el" href="res__odbc_8c_source.html#l00652">652</a> of file <a class="el" href="res__odbc_8c_source.html">res_odbc.c</a>.</p>

<p>References <a class="el" href="logger_8c_source.html#l01090">ast_log()</a>, <a class="el" href="time_8h_source.html#l00141">ast_tvnow()</a>, <a class="el" href="res__odbc_8h_source.html#l00049">odbc_obj::last_used</a>, and <a class="el" href="logger_8h_source.html#l00152">LOG_WARNING</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00653"></a>00653 {
<a name="l00654"></a>00654    <span class="keywordtype">int</span> res = 0, i;
<a name="l00655"></a>00655    SQLINTEGER nativeerror=0, numfields=0;
<a name="l00656"></a>00656    SQLSMALLINT diagbytes=0;
<a name="l00657"></a>00657    <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> <a class="code" href="structstate.html">state</a>[10], diagnostic[256];
<a name="l00658"></a>00658 
<a name="l00659"></a>00659    res = SQLExecute(stmt);
<a name="l00660"></a>00660    <span class="keywordflow">if</span> ((res != SQL_SUCCESS) &amp;&amp; (res != SQL_SUCCESS_WITH_INFO) &amp;&amp; (res != SQL_NO_DATA)) {
<a name="l00661"></a>00661       <span class="keywordflow">if</span> (res == SQL_ERROR) {
<a name="l00662"></a>00662          SQLGetDiagField(SQL_HANDLE_STMT, stmt, 1, SQL_DIAG_NUMBER, &amp;numfields, SQL_IS_INTEGER, &amp;diagbytes);
<a name="l00663"></a>00663          <span class="keywordflow">for</span> (i = 0; i &lt; numfields; i++) {
<a name="l00664"></a>00664             SQLGetDiagRec(SQL_HANDLE_STMT, stmt, i + 1, state, &amp;nativeerror, diagnostic, <span class="keyword">sizeof</span>(diagnostic), &amp;diagbytes);
<a name="l00665"></a>00665             <a class="code" href="logger_8h.html#a93dd824dff97fe84941d6d71b7a3710e" title="Used for sending a log message This is the standard logger function. Probably the...">ast_log</a>(<a class="code" href="logger_8h.html#adf4476a6a4ea6c74231c826e899d7189">LOG_WARNING</a>, <span class="stringliteral">&quot;SQL Execute returned an error %d: %s: %s (%d)\n&quot;</span>, res, state, diagnostic, diagbytes);
<a name="l00666"></a>00666             <span class="keywordflow">if</span> (i &gt; 10) {
<a name="l00667"></a>00667                <a class="code" href="logger_8h.html#a93dd824dff97fe84941d6d71b7a3710e" title="Used for sending a log message This is the standard logger function. Probably the...">ast_log</a>(<a class="code" href="logger_8h.html#adf4476a6a4ea6c74231c826e899d7189">LOG_WARNING</a>, <span class="stringliteral">&quot;Oh, that was good.  There are really %d diagnostics?\n&quot;</span>, (<span class="keywordtype">int</span>)numfields);
<a name="l00668"></a>00668                <span class="keywordflow">break</span>;
<a name="l00669"></a>00669             }
<a name="l00670"></a>00670          }
<a name="l00671"></a>00671       }
<a name="l00672"></a>00672    } <span class="keywordflow">else</span>
<a name="l00673"></a>00673       obj-&gt;<a class="code" href="structodbc__obj.html#a43b2c8a8bf77a2504897ff0da9b0aa90">last_used</a> = <a class="code" href="time_8h.html#abd5ba75c20787bcc479809c53b58406e" title="Returns current timeval. Meant to replace calls to gettimeofday().">ast_tvnow</a>();
<a name="l00674"></a>00674    
<a name="l00675"></a>00675    <span class="keywordflow">return</span> res;
<a name="l00676"></a>00676 }
</pre></div></p>

</div>
</div>
</div>
<hr size="1"/><address style="text-align: right;"><small>Generated on Wed May 5 15:23:16 2010 for Asterisk - the Open Source PBX by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.1 </small></address>
</body>
</html>
