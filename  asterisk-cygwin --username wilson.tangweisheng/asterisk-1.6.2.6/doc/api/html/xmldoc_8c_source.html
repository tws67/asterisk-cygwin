<HTML>
    <HEAD>
      <TITLE>Asterisk.org: Developer Documentation (5 May 2010)</TITLE>
      <LINK HREF="doxygen.css" REL="stylesheet" TYPE="text/css">
    </HEAD>
    <BODY BGCOLOR="#FFFFFF">
<div><font size="2" align="right">Wed May 5 15:18:49 2010</font></div>

<h2>Asterisk developer's documentation</h2>
<hr/>
<!-- Generated by Doxygen 1.6.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
  <div class="navpath"><a class="el" href="dir_afe38fc0ccf2e9eefca5d5c6b03503d9.html">main</a>
  </div>
</div>
<div class="contents">
<h1>xmldoc.c</h1><a href="xmldoc_8c.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">/*</span>
<a name="l00002"></a>00002 <span class="comment"> * Asterisk -- An open source telephony toolkit.</span>
<a name="l00003"></a>00003 <span class="comment"> *</span>
<a name="l00004"></a>00004 <span class="comment"> * Copyright (C) 2008, Eliel C. Sardanons (LU1ALY) &lt;eliels@gmail.com&gt;</span>
<a name="l00005"></a>00005 <span class="comment"> *</span>
<a name="l00006"></a>00006 <span class="comment"> * See http://www.asterisk.org for more information about</span>
<a name="l00007"></a>00007 <span class="comment"> * the Asterisk project. Please do not directly contact</span>
<a name="l00008"></a>00008 <span class="comment"> * any of the maintainers of this project for assistance;</span>
<a name="l00009"></a>00009 <span class="comment"> * the project provides a web site, mailing lists and IRC</span>
<a name="l00010"></a>00010 <span class="comment"> * channels for your use.</span>
<a name="l00011"></a>00011 <span class="comment"> *</span>
<a name="l00012"></a>00012 <span class="comment"> * This program is free software, distributed under the terms of</span>
<a name="l00013"></a>00013 <span class="comment"> * the GNU General Public License Version 2. See the LICENSE file</span>
<a name="l00014"></a>00014 <span class="comment"> * at the top of the source tree.</span>
<a name="l00015"></a>00015 <span class="comment"> */</span>
<a name="l00016"></a>00016 <span class="comment"></span>
<a name="l00017"></a>00017 <span class="comment">/*! \file</span>
<a name="l00018"></a>00018 <span class="comment"> *</span>
<a name="l00019"></a>00019 <span class="comment"> * \brief XML Documentation API</span>
<a name="l00020"></a>00020 <span class="comment"> *</span>
<a name="l00021"></a>00021 <span class="comment"> * \author Eliel C. Sardanons (LU1ALY) &lt;eliels@gmail.com&gt;</span>
<a name="l00022"></a>00022 <span class="comment"> */</span>
<a name="l00023"></a>00023 
<a name="l00024"></a>00024 <span class="preprocessor">#include &quot;<a class="code" href="asterisk_8h.html" title="Asterisk main include file. File version handling, generic pbx functions.">asterisk.h</a>&quot;</span>
<a name="l00025"></a>00025 
<a name="l00026"></a>00026 <a class="code" href="asterisk_8h.html#ab0390be60f8c539a2662df2faf9985c7" title="Register/unregister a source code file with the core.">ASTERISK_FILE_VERSION</a>(__FILE__, <span class="stringliteral">&quot;$Revision: 196951 $&quot;</span>)
<a name="l00027"></a>00027 
<a name="l00028"></a>00028 <span class="preprocessor">#include &quot;asterisk/_private.h&quot;</span>
<a name="l00029"></a>00029 <span class="preprocessor"></span><span class="preprocessor">#include &quot;<a class="code" href="paths_8h.html" title="Asterisk file paths, configured in asterisk.conf.">asterisk/paths.h</a>&quot;</span>
<a name="l00030"></a>00030 <span class="preprocessor">#include &quot;<a class="code" href="linkedlists_8h.html" title="A set of macros to manage forward-linked lists.">asterisk/linkedlists.h</a>&quot;</span>
<a name="l00031"></a>00031 <span class="preprocessor">#include &quot;<a class="code" href="strings_8h.html" title="String manipulation functions.">asterisk/strings.h</a>&quot;</span>
<a name="l00032"></a>00032 <span class="preprocessor">#include &quot;<a class="code" href="config_8h.html" title="Configuration File Parser.">asterisk/config.h</a>&quot;</span>
<a name="l00033"></a>00033 <span class="preprocessor">#include &quot;<a class="code" href="term_8h.html" title="Handy terminal functions for vt* terms.">asterisk/term.h</a>&quot;</span>
<a name="l00034"></a>00034 <span class="preprocessor">#include &quot;<a class="code" href="xmldoc_8h.html" title="Asterisk XML Documentation API.">asterisk/xmldoc.h</a>&quot;</span>
<a name="l00035"></a>00035 
<a name="l00036"></a>00036 <span class="preprocessor">#ifdef AST_XML_DOCS</span>
<a name="l00037"></a>00037 <span class="preprocessor"></span><span class="comment"></span>
<a name="l00038"></a>00038 <span class="comment">/*! \brief Default documentation language. */</span>
<a name="l00039"></a><a class="code" href="xmldoc_8c.html#a5a4442a75c763b05f9145803e4c7dddf">00039</a> <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">char</span> <a class="code" href="xmldoc_8c.html#a5a4442a75c763b05f9145803e4c7dddf" title="Default documentation language.">default_documentation_language</a>[] = <span class="stringliteral">&quot;en_US&quot;</span>;
<a name="l00040"></a>00040 <span class="comment"></span>
<a name="l00041"></a>00041 <span class="comment">/*! \brief Number of columns to print when showing the XML documentation with a</span>
<a name="l00042"></a>00042 <span class="comment"> *         &apos;core show application/function *&apos; CLI command. Used in text wrapping.*/</span>
<a name="l00043"></a><a class="code" href="xmldoc_8c.html#aa552c3993b1ab39a21a153f6dccb8125">00043</a> <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">int</span> <a class="code" href="xmldoc_8c.html#aa552c3993b1ab39a21a153f6dccb8125" title="Number of columns to print when showing the XML documentation with a &amp;#39;core show...">xmldoc_text_columns</a> = 74;
<a name="l00044"></a>00044 <span class="comment"></span>
<a name="l00045"></a>00045 <span class="comment">/*! \brief This is a value that we will use to let the wrapping mechanism move the cursor</span>
<a name="l00046"></a>00046 <span class="comment"> *         backward and forward xmldoc_max_diff positions before cutting the middle of a</span>
<a name="l00047"></a>00047 <span class="comment"> *         word, trying to find a space or a \n. */</span>
<a name="l00048"></a><a class="code" href="xmldoc_8c.html#a35180e7cd29687b79b6450706156f539">00048</a> <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">int</span> <a class="code" href="xmldoc_8c.html#a35180e7cd29687b79b6450706156f539" title="This is a value that we will use to let the wrapping mechanism move the cursor backward...">xmldoc_max_diff</a> = 5;
<a name="l00049"></a>00049 <span class="comment"></span>
<a name="l00050"></a>00050 <span class="comment">/*! \brief XML documentation language. */</span>
<a name="l00051"></a><a class="code" href="xmldoc_8c.html#a0b2ace3b0a473d2514ce792377817934">00051</a> <span class="keyword">static</span> <span class="keywordtype">char</span> <a class="code" href="xmldoc_8c.html#a0b2ace3b0a473d2514ce792377817934" title="XML documentation language.">documentation_language</a>[6];
<a name="l00052"></a>00052 <span class="comment"></span>
<a name="l00053"></a>00053 <span class="comment">/*! \brief XML documentation tree */</span>
<a name="l00054"></a><a class="code" href="structdocumentation__tree.html">00054</a> <span class="keyword">struct </span><a class="code" href="structdocumentation__tree.html" title="XML documentation tree.">documentation_tree</a> {
<a name="l00055"></a><a class="code" href="structdocumentation__tree.html#aeac90097f29f7529968697163cea5c18">00055</a>    <span class="keywordtype">char</span> *<a class="code" href="structdocumentation__tree.html#aeac90097f29f7529968697163cea5c18">filename</a>;               <span class="comment">/*!&lt; XML document filename. */</span>
<a name="l00056"></a><a class="code" href="structdocumentation__tree.html#a8702ea03f4a7d2e0bcca01893d9dd5a6">00056</a>    <span class="keyword">struct </span>ast_xml_doc *<a class="code" href="structdocumentation__tree.html#a8702ea03f4a7d2e0bcca01893d9dd5a6">doc</a>;         <span class="comment">/*!&lt; Open document pointer. */</span>
<a name="l00057"></a><a class="code" href="structdocumentation__tree.html#afb6175549de9024fbc36b5210c15f7b0">00057</a>    <a class="code" href="linkedlists_8h.html#ac63e9e237da22b6faf3be4edfc4f5a11">AST_RWLIST_ENTRY</a>(<a class="code" href="structdocumentation__tree.html" title="XML documentation tree.">documentation_tree</a>) <a class="code" href="structdocumentation__tree.html#a9770eb03f735793008007de780d8b2f1">entry</a>;
<a name="l00058"></a>00058 };
<a name="l00059"></a>00059 
<a name="l00060"></a>00060 static <span class="keywordtype">char</span> *<a class="code" href="xmldoc_8c.html#a715470224f007f05ca6940fee40132ef">xmldoc_get_syntax_cmd</a>(struct ast_xml_node *fixnode, const <span class="keywordtype">char</span> *<a class="code" href="cdr__adaptive__odbc_8c.html#a5ac083a645d964373f022d03df4849c8">name</a>, <span class="keywordtype">int</span> printname);
<a name="l00061"></a>00061 static <span class="keywordtype">int</span> <a class="code" href="xmldoc_8c.html#aedc9e210a0057f5e7dc9f0caf3ba86a7">xmldoc_parse_enumlist</a>(struct ast_xml_node *fixnode, const <span class="keywordtype">char</span> *tabs, struct <a class="code" href="structast__str.html" title="The descriptor of a dynamic string XXX storage will be optimized later if needed...">ast_str</a> **buffer);
<a name="l00062"></a>00062 <span class="comment"></span>
<a name="l00063"></a>00063 <span class="comment">/*!</span>
<a name="l00064"></a>00064 <span class="comment"> * \brief Container of documentation trees</span>
<a name="l00065"></a>00065 <span class="comment"> *</span>
<a name="l00066"></a>00066 <span class="comment"> * \note A RWLIST is a sufficient container type to use here for now.</span>
<a name="l00067"></a>00067 <span class="comment"> *       However, some changes will need to be made to implement ref counting</span>
<a name="l00068"></a>00068 <span class="comment"> *       if reload support is added in the future.</span>
<a name="l00069"></a>00069 <span class="comment"> */</span>
<a name="l00070"></a><a class="code" href="structxmldoc__tree.html#ace4e0066a5b24f84b90536e9906619f6">00070</a> static <a class="code" href="linkedlists_8h.html#a39918fd433ac42184b152c86016ef139" title="Defines a structure to be used to hold a read/write list of specified type, statically...">AST_RWLIST_HEAD_STATIC</a>(<a class="code" href="structxmldoc__tree.html" title="Container of documentation trees.">xmldoc_tree</a>, <a class="code" href="structdocumentation__tree.html" title="XML documentation tree.">documentation_tree</a>);
<a name="l00071"></a>00071 
<a name="l00072"></a><a class="code" href="structstrcolorized__tags.html">00072</a> static const struct <a class="code" href="structstrcolorized__tags.html">strcolorized_tags</a> {
<a name="l00073"></a><a class="code" href="structstrcolorized__tags.html#a2b0f38f6e0a0fe73b63ef9442cec258f">00073</a>    <span class="keyword">const</span> <span class="keywordtype">char</span> *init;      <span class="comment">/*!&lt; Replace initial tag with this string. */</span>
<a name="l00074"></a><a class="code" href="structstrcolorized__tags.html#aa0c4bdeda46c4ae639e086c22fe5eed6">00074</a>    <span class="keyword">const</span> <span class="keywordtype">char</span> *end;       <span class="comment">/*!&lt; Replace end tag with this string. */</span>
<a name="l00075"></a><a class="code" href="structstrcolorized__tags.html#aa4e0dd42b902accde92847b127639bed">00075</a>    <span class="keyword">const</span> <span class="keywordtype">int</span> colorfg;     <span class="comment">/*!&lt; Foreground color. */</span>
<a name="l00076"></a><a class="code" href="structstrcolorized__tags.html#a5df14849d674cbb160848be2f13fe308">00076</a>    <span class="keyword">const</span> <span class="keywordtype">char</span> *inittag;   <span class="comment">/*!&lt; Initial tag description. */</span>
<a name="l00077"></a><a class="code" href="structstrcolorized__tags.html#a2ba0e15c727ebd5d4e9a5fed0ce76fd4">00077</a>    <span class="keyword">const</span> <span class="keywordtype">char</span> *endtag;    <span class="comment">/*!&lt; Ending tag description. */</span>
<a name="l00078"></a>00078 } <a class="code" href="xmldoc_8c.html#a9712901310108a9614a9a28136e6754a">colorized_tags</a>[] = {
<a name="l00079"></a>00079    { <span class="stringliteral">&quot;&lt;&quot;</span>,  <span class="stringliteral">&quot;&gt;&quot;</span>,  <a class="code" href="term_8h.html#afc9149f5de51bd9ac4f5ebbfa153f018">COLOR_GREEN</a>,  <span class="stringliteral">&quot;&lt;replaceable&gt;&quot;</span>, <span class="stringliteral">&quot;&lt;/replaceable&gt;&quot;</span> },
<a name="l00080"></a>00080    { <span class="stringliteral">&quot;\&apos;&quot;</span>, <span class="stringliteral">&quot;\&apos;&quot;</span>, <a class="code" href="term_8h.html#a23c70d699a5a775bc2e1ebeb8603f630">COLOR_BLUE</a>,   <span class="stringliteral">&quot;&lt;literal&gt;&quot;</span>,     <span class="stringliteral">&quot;&lt;/literal&gt;&quot;</span> },
<a name="l00081"></a>00081    { <span class="stringliteral">&quot;*&quot;</span>,  <span class="stringliteral">&quot;*&quot;</span>,  <a class="code" href="term_8h.html#ad86358bf19927183dd7b4ae215a29731">COLOR_RED</a>,    <span class="stringliteral">&quot;&lt;emphasis&gt;&quot;</span>,    <span class="stringliteral">&quot;&lt;/emphasis&gt;&quot;</span> },
<a name="l00082"></a>00082    { <span class="stringliteral">&quot;\&quot;&quot;</span>, <span class="stringliteral">&quot;\&quot;&quot;</span>, <a class="code" href="term_8h.html#a4534b577b74a58b0f4b7be027af664e0">COLOR_YELLOW</a>, <span class="stringliteral">&quot;&lt;filename&gt;&quot;</span>,    <span class="stringliteral">&quot;&lt;/filename&gt;&quot;</span> },
<a name="l00083"></a>00083    { <span class="stringliteral">&quot;\&quot;&quot;</span>, <span class="stringliteral">&quot;\&quot;&quot;</span>, <a class="code" href="term_8h.html#a82573859711fce56f1aa0a76b18a9b18">COLOR_CYAN</a>,   <span class="stringliteral">&quot;&lt;directory&gt;&quot;</span>,   <span class="stringliteral">&quot;&lt;/directory&gt;&quot;</span> },
<a name="l00084"></a>00084    { <span class="stringliteral">&quot;${&quot;</span>, <span class="stringliteral">&quot;}&quot;</span>,  <a class="code" href="term_8h.html#afc9149f5de51bd9ac4f5ebbfa153f018">COLOR_GREEN</a>,  <span class="stringliteral">&quot;&lt;variable&gt;&quot;</span>,    <span class="stringliteral">&quot;&lt;/variable&gt;&quot;</span> },
<a name="l00085"></a>00085    { <span class="stringliteral">&quot;&quot;</span>,   <span class="stringliteral">&quot;&quot;</span>,   <a class="code" href="term_8h.html#a23c70d699a5a775bc2e1ebeb8603f630">COLOR_BLUE</a>,   <span class="stringliteral">&quot;&lt;value&gt;&quot;</span>,       <span class="stringliteral">&quot;&lt;/value&gt;&quot;</span> },
<a name="l00086"></a>00086    { <span class="stringliteral">&quot;&quot;</span>,   <span class="stringliteral">&quot;&quot;</span>,   <a class="code" href="term_8h.html#a23c70d699a5a775bc2e1ebeb8603f630">COLOR_BLUE</a>,   <span class="stringliteral">&quot;&lt;enum&gt;&quot;</span>,        <span class="stringliteral">&quot;&lt;/enum&gt;&quot;</span> },
<a name="l00087"></a>00087    { <span class="stringliteral">&quot;\&apos;&quot;</span>, <span class="stringliteral">&quot;\&apos;&quot;</span>, <a class="code" href="term_8h.html#a3aaf3b0287d26dfb6ecb3b1c46e950c8">COLOR_GRAY</a>,   <span class="stringliteral">&quot;&lt;astcli&gt;&quot;</span>,      <span class="stringliteral">&quot;&lt;/astcli&gt;&quot;</span> },
<a name="l00088"></a>00088 
<a name="l00089"></a>00089    <span class="comment">/* Special tags */</span>
<a name="l00090"></a>00090    { <span class="stringliteral">&quot;&quot;</span>, <span class="stringliteral">&quot;&quot;</span>, <a class="code" href="term_8h.html#a4534b577b74a58b0f4b7be027af664e0">COLOR_YELLOW</a>, <span class="stringliteral">&quot;&lt;note&gt;&quot;</span>,   <span class="stringliteral">&quot;&lt;/note&gt;&quot;</span> },
<a name="l00091"></a>00091    { <span class="stringliteral">&quot;&quot;</span>, <span class="stringliteral">&quot;&quot;</span>, <a class="code" href="term_8h.html#ad86358bf19927183dd7b4ae215a29731">COLOR_RED</a>,   <span class="stringliteral">&quot;&lt;warning&gt;&quot;</span>, <span class="stringliteral">&quot;&lt;/warning&gt;&quot;</span> }
<a name="l00092"></a>00092 };
<a name="l00093"></a>00093 
<a name="l00094"></a><a class="code" href="structstrspecial__tags.html">00094</a> <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">struct </span><a class="code" href="structstrspecial__tags.html">strspecial_tags</a> {
<a name="l00095"></a><a class="code" href="structstrspecial__tags.html#ae9d9e5398f70f013b36a0adf67eb3528">00095</a>    <span class="keyword">const</span> <span class="keywordtype">char</span> *tagname;    <span class="comment">/*!&lt; Special tag name. */</span>
<a name="l00096"></a><a class="code" href="structstrspecial__tags.html#a2b0f38f6e0a0fe73b63ef9442cec258f">00096</a>    <span class="keyword">const</span> <span class="keywordtype">char</span> *init;    <span class="comment">/*!&lt; Print this at the beginning. */</span>
<a name="l00097"></a><a class="code" href="structstrspecial__tags.html#aa0c4bdeda46c4ae639e086c22fe5eed6">00097</a>    <span class="keyword">const</span> <span class="keywordtype">char</span> *end;     <span class="comment">/*!&lt; Print this at the end. */</span>
<a name="l00098"></a>00098 } <a class="code" href="xmldoc_8c.html#a2779d1b00e3343992468fe48be466553">special_tags</a>[] = {
<a name="l00099"></a>00099    { <span class="stringliteral">&quot;note&quot;</span>,    <span class="stringliteral">&quot;&lt;note&gt;NOTE:&lt;/note&gt; &quot;</span>,             <span class="stringliteral">&quot;&quot;</span> },
<a name="l00100"></a>00100    { <span class="stringliteral">&quot;warning&quot;</span>, <span class="stringliteral">&quot;&lt;warning&gt;WARNING!!!:&lt;/warning&gt; &quot;</span>, <span class="stringliteral">&quot;&quot;</span> }
<a name="l00101"></a>00101 };
<a name="l00102"></a>00102 <span class="comment"></span>
<a name="l00103"></a>00103 <span class="comment">/*! \internal</span>
<a name="l00104"></a>00104 <span class="comment"> *  \brief Calculate the space in bytes used by a format string</span>
<a name="l00105"></a>00105 <span class="comment"> *         that will be passed to a sprintf function.</span>
<a name="l00106"></a>00106 <span class="comment"> *  \param postbr The format string to use to calculate the length.</span>
<a name="l00107"></a>00107 <span class="comment"> *  \retval The postbr length.</span>
<a name="l00108"></a>00108 <span class="comment"> */</span>
<a name="l00109"></a><a class="code" href="xmldoc_8c.html#a9ba7dd0f62e3dc33f80acef7fc08ee4a">00109</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="xmldoc_8c.html#a9ba7dd0f62e3dc33f80acef7fc08ee4a">xmldoc_postbrlen</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> *postbr)
<a name="l00110"></a>00110 {
<a name="l00111"></a>00111    <span class="keywordtype">int</span> postbrreallen = 0, i;
<a name="l00112"></a>00112    <span class="keywordtype">size_t</span> postbrlen;
<a name="l00113"></a>00113 
<a name="l00114"></a>00114    <span class="keywordflow">if</span> (!postbr) {
<a name="l00115"></a>00115       <span class="keywordflow">return</span> 0;
<a name="l00116"></a>00116    }
<a name="l00117"></a>00117    postbrlen = strlen(postbr);
<a name="l00118"></a>00118    <span class="keywordflow">for</span> (i = 0; i &lt; postbrlen; i++) {
<a name="l00119"></a>00119       <span class="keywordflow">if</span> (postbr[i] == <span class="charliteral">&apos;\t&apos;</span>) {
<a name="l00120"></a>00120          postbrreallen += 8 - (postbrreallen % 8);
<a name="l00121"></a>00121       } <span class="keywordflow">else</span> {
<a name="l00122"></a>00122          postbrreallen++;
<a name="l00123"></a>00123       }
<a name="l00124"></a>00124    }
<a name="l00125"></a>00125    <span class="keywordflow">return</span> postbrreallen;
<a name="l00126"></a>00126 }
<a name="l00127"></a>00127 <span class="comment"></span>
<a name="l00128"></a>00128 <span class="comment">/*! \internal</span>
<a name="l00129"></a>00129 <span class="comment"> *  \brief Setup postbr to be used while wrapping the text.</span>
<a name="l00130"></a>00130 <span class="comment"> *         Add to postbr array all the spaces and tabs at the beginning of text.</span>
<a name="l00131"></a>00131 <span class="comment"> *  \param postbr output array.</span>
<a name="l00132"></a>00132 <span class="comment"> *  \param len text array length.</span>
<a name="l00133"></a>00133 <span class="comment"> *  \param text Text with format string before the actual string.</span>
<a name="l00134"></a>00134 <span class="comment"> */</span>
<a name="l00135"></a><a class="code" href="xmldoc_8c.html#a3b72a58671e87dfa14710116b8d3c8ae">00135</a> <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="xmldoc_8c.html#a3b72a58671e87dfa14710116b8d3c8ae">xmldoc_setpostbr</a>(<span class="keywordtype">char</span> *postbr, <span class="keywordtype">size_t</span> <a class="code" href="func__strings_8c.html#af24e73aaf92f3000fda15d285e66df24">len</a>, <span class="keyword">const</span> <span class="keywordtype">char</span> *<a class="code" href="app__queue_8c.html#a5633b1433389cec21ade3811bbe9ca5b">text</a>)
<a name="l00136"></a>00136 {
<a name="l00137"></a>00137    <span class="keywordtype">int</span> c, postbrlen = 0;
<a name="l00138"></a>00138 
<a name="l00139"></a>00139    <span class="keywordflow">if</span> (!text) {
<a name="l00140"></a>00140       <span class="keywordflow">return</span>;
<a name="l00141"></a>00141    }
<a name="l00142"></a>00142 
<a name="l00143"></a>00143    <span class="keywordflow">for</span> (c = 0; c &lt; len; c++) {
<a name="l00144"></a>00144       <span class="keywordflow">if</span> (text[c] == <span class="charliteral">&apos;\t&apos;</span> || text[c] == <span class="charliteral">&apos; &apos;</span>) {
<a name="l00145"></a>00145          postbr[postbrlen++] = text[c];
<a name="l00146"></a>00146       } <span class="keywordflow">else</span> {
<a name="l00147"></a>00147          <span class="keywordflow">break</span>;
<a name="l00148"></a>00148       }
<a name="l00149"></a>00149    }
<a name="l00150"></a>00150    postbr[postbrlen] = <span class="charliteral">&apos;\0&apos;</span>;
<a name="l00151"></a>00151 }
<a name="l00152"></a>00152 <span class="comment"></span>
<a name="l00153"></a>00153 <span class="comment">/*! \internal</span>
<a name="l00154"></a>00154 <span class="comment"> *  \brief Try to find a space or a break in text starting at currentpost</span>
<a name="l00155"></a>00155 <span class="comment"> *         and moving at most maxdiff positions.</span>
<a name="l00156"></a>00156 <span class="comment"> *         Helper for xmldoc_string_wrap().</span>
<a name="l00157"></a>00157 <span class="comment"> *  \param text Input string where it will search.</span>
<a name="l00158"></a>00158 <span class="comment"> *  \param currentpos Current position within text.</span>
<a name="l00159"></a>00159 <span class="comment"> *  \param maxdiff Not move more than maxdiff inside text.</span>
<a name="l00160"></a>00160 <span class="comment"> *  \retval 1 if a space or break is found inside text while moving.</span>
<a name="l00161"></a>00161 <span class="comment"> *  \retval 0 if no space or break is found.</span>
<a name="l00162"></a>00162 <span class="comment"> */</span>
<a name="l00163"></a><a class="code" href="xmldoc_8c.html#a3c6ef9878491cdc35b58f632317391b1">00163</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="xmldoc_8c.html#a3c6ef9878491cdc35b58f632317391b1">xmldoc_wait_nextspace</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> *<a class="code" href="app__queue_8c.html#a5633b1433389cec21ade3811bbe9ca5b">text</a>, <span class="keywordtype">int</span> currentpos, <span class="keywordtype">int</span> maxdiff)
<a name="l00164"></a>00164 {
<a name="l00165"></a>00165    <span class="keywordtype">int</span> i, textlen;
<a name="l00166"></a>00166 
<a name="l00167"></a>00167    <span class="keywordflow">if</span> (!text) {
<a name="l00168"></a>00168       <span class="keywordflow">return</span> 0;
<a name="l00169"></a>00169    }
<a name="l00170"></a>00170 
<a name="l00171"></a>00171    textlen = strlen(text);
<a name="l00172"></a>00172    <span class="keywordflow">for</span> (i = currentpos; i &lt; textlen; i++) {
<a name="l00173"></a>00173       <span class="keywordflow">if</span> (text[i] == <a class="code" href="term_8h.html#a4af1b6159e447ba72652bb7fcdfa726e">ESC</a>) {
<a name="l00174"></a>00174          <span class="comment">/* Move to the end of the escape sequence */</span>
<a name="l00175"></a>00175          <span class="keywordflow">while</span> (i &lt; textlen &amp;&amp; text[i] != <span class="charliteral">&apos;m&apos;</span>) {
<a name="l00176"></a>00176             i++;
<a name="l00177"></a>00177          }
<a name="l00178"></a>00178       } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (text[i] == <span class="charliteral">&apos; &apos;</span> || text[i] == <span class="charliteral">&apos;\n&apos;</span>) {
<a name="l00179"></a>00179          <span class="comment">/* Found the next space or linefeed */</span>
<a name="l00180"></a>00180          <span class="keywordflow">return</span> 1;
<a name="l00181"></a>00181       } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (i - currentpos &gt; maxdiff) {
<a name="l00182"></a>00182          <span class="comment">/* We have looked the max distance and didn&apos;t find it */</span>
<a name="l00183"></a>00183          <span class="keywordflow">return</span> 0;
<a name="l00184"></a>00184       }
<a name="l00185"></a>00185    }
<a name="l00186"></a>00186 
<a name="l00187"></a>00187    <span class="comment">/* Reached the end and did not find it */</span>
<a name="l00188"></a>00188 
<a name="l00189"></a>00189    <span class="keywordflow">return</span> 0;
<a name="l00190"></a>00190 }
<a name="l00191"></a>00191 <span class="comment"></span>
<a name="l00192"></a>00192 <span class="comment">/*! \internal</span>
<a name="l00193"></a>00193 <span class="comment"> *  \brief Helper function for xmldoc_string_wrap().</span>
<a name="l00194"></a>00194 <span class="comment"> *    Try to found a space or a break inside text moving backward</span>
<a name="l00195"></a>00195 <span class="comment"> *    not more than maxdiff positions.</span>
<a name="l00196"></a>00196 <span class="comment"> *  \param text The input string where to search for a space.</span>
<a name="l00197"></a>00197 <span class="comment"> *  \param currentpos The current cursor position.</span>
<a name="l00198"></a>00198 <span class="comment"> *  \param maxdiff The max number of positions to move within text.</span>
<a name="l00199"></a>00199 <span class="comment"> *  \retval 0 If no space is found (Notice that text[currentpos] is not a space or a break)</span>
<a name="l00200"></a>00200 <span class="comment"> *  \retval &gt; 0 If a space or a break is found, and the result is the position relative to</span>
<a name="l00201"></a>00201 <span class="comment"> *    currentpos.</span>
<a name="l00202"></a>00202 <span class="comment"> */</span>
<a name="l00203"></a><a class="code" href="xmldoc_8c.html#a82e7a749317f16d01f359015f1ad95e8">00203</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="xmldoc_8c.html#a82e7a749317f16d01f359015f1ad95e8">xmldoc_foundspace_backward</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> *<a class="code" href="app__queue_8c.html#a5633b1433389cec21ade3811bbe9ca5b">text</a>, <span class="keywordtype">int</span> currentpos, <span class="keywordtype">int</span> maxdiff)
<a name="l00204"></a>00204 {
<a name="l00205"></a>00205    <span class="keywordtype">int</span> i;
<a name="l00206"></a>00206 
<a name="l00207"></a>00207    <span class="keywordflow">for</span> (i = currentpos; i &gt; 0; i--) {
<a name="l00208"></a>00208       <span class="keywordflow">if</span> (text[i] == <span class="charliteral">&apos; &apos;</span> || text[i] == <span class="charliteral">&apos;\n&apos;</span>) {
<a name="l00209"></a>00209          <span class="keywordflow">return</span> (currentpos - i);
<a name="l00210"></a>00210       } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (text[i] == <span class="charliteral">&apos;m&apos;</span> &amp;&amp; (text[i - 1] &gt;= <span class="charliteral">&apos;0&apos;</span> || text[i - 1] &lt;= <span class="charliteral">&apos;9&apos;</span>)) {
<a name="l00211"></a>00211          <span class="comment">/* give up, we found the end of a possible ESC sequence. */</span>
<a name="l00212"></a>00212          <span class="keywordflow">return</span> 0;
<a name="l00213"></a>00213       } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (currentpos - i &gt; maxdiff) {
<a name="l00214"></a>00214          <span class="comment">/* give up, we can&apos;t move anymore. */</span>
<a name="l00215"></a>00215          <span class="keywordflow">return</span> 0;
<a name="l00216"></a>00216       }
<a name="l00217"></a>00217    }
<a name="l00218"></a>00218 
<a name="l00219"></a>00219    <span class="comment">/* we found the beginning of the text */</span>
<a name="l00220"></a>00220 
<a name="l00221"></a>00221    <span class="keywordflow">return</span> 0;
<a name="l00222"></a>00222 }
<a name="l00223"></a>00223 <span class="comment"></span>
<a name="l00224"></a>00224 <span class="comment">/*! \internal</span>
<a name="l00225"></a>00225 <span class="comment"> *  \brief Justify a text to a number of columns.</span>
<a name="l00226"></a>00226 <span class="comment"> *  \param text Input text to be justified.</span>
<a name="l00227"></a>00227 <span class="comment"> *  \param columns Number of columns to preserve in the text.</span>
<a name="l00228"></a>00228 <span class="comment"> *  \param maxdiff Try to not cut a word when goinf down.</span>
<a name="l00229"></a>00229 <span class="comment"> *  \retval NULL on error.</span>
<a name="l00230"></a>00230 <span class="comment"> *  \retval The wrapped text.</span>
<a name="l00231"></a>00231 <span class="comment"> */</span>
<a name="l00232"></a><a class="code" href="xmldoc_8c.html#a487c5c730276403d585b07d5b4a43cd9">00232</a> <span class="keyword">static</span> <span class="keywordtype">char</span> *<a class="code" href="xmldoc_8c.html#a487c5c730276403d585b07d5b4a43cd9">xmldoc_string_wrap</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> *<a class="code" href="app__queue_8c.html#a5633b1433389cec21ade3811bbe9ca5b">text</a>, <span class="keywordtype">int</span> <a class="code" href="structcolumns.html">columns</a>, <span class="keywordtype">int</span> maxdiff)
<a name="l00233"></a>00233 {
<a name="l00234"></a>00234    <span class="keyword">struct </span><a class="code" href="structast__str.html" title="The descriptor of a dynamic string XXX storage will be optimized later if needed...">ast_str</a> *tmp;
<a name="l00235"></a>00235    <span class="keywordtype">char</span> *ret, postbr[160];
<a name="l00236"></a>00236    <span class="keywordtype">int</span> count = 1, i, backspace, needtobreak = 0, colmax, textlen;
<a name="l00237"></a>00237 
<a name="l00238"></a>00238    <span class="comment">/* sanity check */</span>
<a name="l00239"></a>00239    <span class="keywordflow">if</span> (!text || columns &lt;= 0 || maxdiff &lt; 0) {
<a name="l00240"></a>00240       <a class="code" href="logger_8h.html#a93dd824dff97fe84941d6d71b7a3710e" title="Used for sending a log message This is the standard logger function. Probably the...">ast_log</a>(<a class="code" href="logger_8h.html#adf4476a6a4ea6c74231c826e899d7189">LOG_WARNING</a>, <span class="stringliteral">&quot;Passing wrong arguments while trying to wrap the text\n&quot;</span>);
<a name="l00241"></a>00241       <span class="keywordflow">return</span> NULL;
<a name="l00242"></a>00242    }
<a name="l00243"></a>00243 
<a name="l00244"></a>00244    tmp = <a class="code" href="strings_8h.html#a8ec37e4acb6ecb20eb6f6edd1141cd76" title="Create a malloc&amp;#39;ed dynamic length string.">ast_str_create</a>(strlen(text) * 3);
<a name="l00245"></a>00245 
<a name="l00246"></a>00246    <span class="keywordflow">if</span> (!tmp) {
<a name="l00247"></a>00247       <span class="keywordflow">return</span> NULL;
<a name="l00248"></a>00248    }
<a name="l00249"></a>00249 
<a name="l00250"></a>00250    <span class="comment">/* Check for blanks and tabs and put them in postbr. */</span>
<a name="l00251"></a>00251    <a class="code" href="xmldoc_8c.html#a3b72a58671e87dfa14710116b8d3c8ae">xmldoc_setpostbr</a>(postbr, <span class="keyword">sizeof</span>(postbr), text);
<a name="l00252"></a>00252    colmax = columns - <a class="code" href="xmldoc_8c.html#a9ba7dd0f62e3dc33f80acef7fc08ee4a">xmldoc_postbrlen</a>(postbr);
<a name="l00253"></a>00253 
<a name="l00254"></a>00254    textlen = strlen(text);
<a name="l00255"></a>00255    <span class="keywordflow">for</span> (i = 0; i &lt; textlen; i++) {
<a name="l00256"></a>00256       <span class="keywordflow">if</span> (needtobreak || !(count % colmax)) {
<a name="l00257"></a>00257          <span class="keywordflow">if</span> (text[i] == <span class="charliteral">&apos; &apos;</span>) {
<a name="l00258"></a>00258             <a class="code" href="strings_8h.html#a85cd5a8ef499e39d22b4bfeb8b9a64f7" title="Append to a thread local dynamic string.">ast_str_append</a>(&amp;tmp, 0, <span class="stringliteral">&quot;\n%s&quot;</span>, postbr);
<a name="l00259"></a>00259             needtobreak = 0;
<a name="l00260"></a>00260             count = 1;
<a name="l00261"></a>00261          } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (text[i] != <span class="charliteral">&apos;\n&apos;</span>) {
<a name="l00262"></a>00262             needtobreak = 1;
<a name="l00263"></a>00263             <span class="keywordflow">if</span> (<a class="code" href="xmldoc_8c.html#a3c6ef9878491cdc35b58f632317391b1">xmldoc_wait_nextspace</a>(text, i, maxdiff)) {
<a name="l00264"></a>00264                <span class="comment">/* wait for the next space */</span>
<a name="l00265"></a>00265                <a class="code" href="strings_8h.html#a85cd5a8ef499e39d22b4bfeb8b9a64f7" title="Append to a thread local dynamic string.">ast_str_append</a>(&amp;tmp, 0, <span class="stringliteral">&quot;%c&quot;</span>, text[i]);
<a name="l00266"></a>00266                <span class="keywordflow">continue</span>;
<a name="l00267"></a>00267             }
<a name="l00268"></a>00268             <span class="comment">/* Try to look backwards */</span>
<a name="l00269"></a>00269             backspace = <a class="code" href="xmldoc_8c.html#a82e7a749317f16d01f359015f1ad95e8">xmldoc_foundspace_backward</a>(text, i, maxdiff);
<a name="l00270"></a>00270             <span class="keywordflow">if</span> (backspace) {
<a name="l00271"></a>00271                needtobreak = 1;
<a name="l00272"></a>00272                <a class="code" href="strings_8h.html#a5744f4b4f751c19399c955971f36ecfa" title="Truncates the enclosed string to the given length.">ast_str_truncate</a>(tmp, -backspace);
<a name="l00273"></a>00273                i -= backspace + 1;
<a name="l00274"></a>00274                <span class="keywordflow">continue</span>;
<a name="l00275"></a>00275             }
<a name="l00276"></a>00276             <a class="code" href="strings_8h.html#a85cd5a8ef499e39d22b4bfeb8b9a64f7" title="Append to a thread local dynamic string.">ast_str_append</a>(&amp;tmp, 0, <span class="stringliteral">&quot;\n%s&quot;</span>, postbr);
<a name="l00277"></a>00277             needtobreak = 0;
<a name="l00278"></a>00278             count = 1;
<a name="l00279"></a>00279          }
<a name="l00280"></a>00280          <span class="comment">/* skip blanks after a \n */</span>
<a name="l00281"></a>00281          <span class="keywordflow">while</span> (text[i] == <span class="charliteral">&apos; &apos;</span>) {
<a name="l00282"></a>00282             i++;
<a name="l00283"></a>00283          }
<a name="l00284"></a>00284       }
<a name="l00285"></a>00285       <span class="keywordflow">if</span> (text[i] == <span class="charliteral">&apos;\n&apos;</span>) {
<a name="l00286"></a>00286          <a class="code" href="xmldoc_8c.html#a3b72a58671e87dfa14710116b8d3c8ae">xmldoc_setpostbr</a>(postbr, <span class="keyword">sizeof</span>(postbr), &amp;text[i] + 1);
<a name="l00287"></a>00287          colmax = columns - <a class="code" href="xmldoc_8c.html#a9ba7dd0f62e3dc33f80acef7fc08ee4a">xmldoc_postbrlen</a>(postbr);
<a name="l00288"></a>00288          needtobreak = 0;
<a name="l00289"></a>00289          count = 1;
<a name="l00290"></a>00290       }
<a name="l00291"></a>00291       <span class="keywordflow">if</span> (text[i] == <a class="code" href="term_8h.html#a4af1b6159e447ba72652bb7fcdfa726e">ESC</a>) {
<a name="l00292"></a>00292          <span class="comment">/* Ignore Escape sequences. */</span>
<a name="l00293"></a>00293          <span class="keywordflow">do</span> {
<a name="l00294"></a>00294             <a class="code" href="strings_8h.html#a85cd5a8ef499e39d22b4bfeb8b9a64f7" title="Append to a thread local dynamic string.">ast_str_append</a>(&amp;tmp, 0, <span class="stringliteral">&quot;%c&quot;</span>, text[i]);
<a name="l00295"></a>00295             i++;
<a name="l00296"></a>00296          } <span class="keywordflow">while</span> (i &lt; textlen &amp;&amp; text[i] != <span class="charliteral">&apos;m&apos;</span>);
<a name="l00297"></a>00297       } <span class="keywordflow">else</span> {
<a name="l00298"></a>00298          count++;
<a name="l00299"></a>00299       }
<a name="l00300"></a>00300       <a class="code" href="strings_8h.html#a85cd5a8ef499e39d22b4bfeb8b9a64f7" title="Append to a thread local dynamic string.">ast_str_append</a>(&amp;tmp, 0, <span class="stringliteral">&quot;%c&quot;</span>, text[i]);
<a name="l00301"></a>00301    }
<a name="l00302"></a>00302 
<a name="l00303"></a>00303    ret = <a class="code" href="astmm_8h.html#a2ef2401ade6b4b773138a82c86c40903">ast_strdup</a>(<a class="code" href="strings_8h.html#a053bdfc229997a75f112bdd7b995e00b" title="Returns the string buffer within the ast_str buf.">ast_str_buffer</a>(tmp));
<a name="l00304"></a>00304    <a class="code" href="astmm_8h.html#a402072d6789f6ed9e3a81da27504127e">ast_free</a>(tmp);
<a name="l00305"></a>00305 
<a name="l00306"></a>00306    <span class="keywordflow">return</span> ret;
<a name="l00307"></a>00307 }
<a name="l00308"></a>00308 
<a name="l00309"></a><a class="code" href="xmldoc_8c.html#a637de870dfc83d0694f588c5a814ce38">00309</a> <span class="keywordtype">char</span> *<a class="code" href="xmldoc_8h.html#a637de870dfc83d0694f588c5a814ce38" title="Colorize and put delimiters (instead of tags) to the xmldoc output.">ast_xmldoc_printable</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> *bwinput, <span class="keywordtype">int</span> withcolors)
<a name="l00310"></a>00310 {
<a name="l00311"></a>00311    <span class="keyword">struct </span><a class="code" href="structast__str.html" title="The descriptor of a dynamic string XXX storage will be optimized later if needed...">ast_str</a> *colorized;
<a name="l00312"></a>00312    <span class="keywordtype">char</span> *wrapped = NULL;
<a name="l00313"></a>00313    <span class="keywordtype">int</span> i, c, <a class="code" href="func__strings_8c.html#af24e73aaf92f3000fda15d285e66df24">len</a>, colorsection;
<a name="l00314"></a>00314    <span class="keywordtype">char</span> *tmp;
<a name="l00315"></a>00315    <span class="keywordtype">size_t</span> bwinputlen;
<a name="l00316"></a>00316    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">int</span> base_fg = <a class="code" href="term_8h.html#a82573859711fce56f1aa0a76b18a9b18">COLOR_CYAN</a>;
<a name="l00317"></a>00317 
<a name="l00318"></a>00318    <span class="keywordflow">if</span> (!bwinput) {
<a name="l00319"></a>00319       <span class="keywordflow">return</span> NULL;
<a name="l00320"></a>00320    }
<a name="l00321"></a>00321 
<a name="l00322"></a>00322    bwinputlen = strlen(bwinput);
<a name="l00323"></a>00323 
<a name="l00324"></a>00324    <span class="keywordflow">if</span> (!(colorized = <a class="code" href="strings_8h.html#a8ec37e4acb6ecb20eb6f6edd1141cd76" title="Create a malloc&amp;#39;ed dynamic length string.">ast_str_create</a>(256))) {
<a name="l00325"></a>00325       <span class="keywordflow">return</span> NULL;
<a name="l00326"></a>00326    }
<a name="l00327"></a>00327 
<a name="l00328"></a>00328    <span class="keywordflow">if</span> (withcolors) {
<a name="l00329"></a>00329       <a class="code" href="term_8h.html#a5793417e507670e905f441b1d6e30f86" title="Append a color sequence to an ast_str.">ast_term_color_code</a>(&amp;colorized, base_fg, 0);
<a name="l00330"></a>00330       <span class="keywordflow">if</span> (!colorized) {
<a name="l00331"></a>00331          <span class="keywordflow">return</span> NULL;
<a name="l00332"></a>00332       }
<a name="l00333"></a>00333    }
<a name="l00334"></a>00334 
<a name="l00335"></a>00335    <span class="keywordflow">for</span> (i = 0; i &lt; bwinputlen; i++) {
<a name="l00336"></a>00336       colorsection = 0;
<a name="l00337"></a>00337       <span class="comment">/* Check if we are at the beginning of a tag to be colorized. */</span>
<a name="l00338"></a>00338       <span class="keywordflow">for</span> (c = 0; c &lt; <a class="code" href="isdn__lib_8c.html#ab9129b977a587b50ea801daac75e178f">ARRAY_LEN</a>(<a class="code" href="xmldoc_8c.html#a9712901310108a9614a9a28136e6754a">colorized_tags</a>); c++) {
<a name="l00339"></a>00339          <span class="keywordflow">if</span> (strncasecmp(bwinput + i, <a class="code" href="xmldoc_8c.html#a9712901310108a9614a9a28136e6754a">colorized_tags</a>[c].inittag, strlen(<a class="code" href="xmldoc_8c.html#a9712901310108a9614a9a28136e6754a">colorized_tags</a>[c].inittag))) {
<a name="l00340"></a>00340             <span class="keywordflow">continue</span>;
<a name="l00341"></a>00341          }
<a name="l00342"></a>00342 
<a name="l00343"></a>00343          <span class="keywordflow">if</span> (!(tmp = <a class="code" href="agi_2strcompat_8c.html#ae9229017a4501f8d6a637b4498cfed2e">strcasestr</a>(bwinput + i + strlen(<a class="code" href="xmldoc_8c.html#a9712901310108a9614a9a28136e6754a">colorized_tags</a>[c].inittag), <a class="code" href="xmldoc_8c.html#a9712901310108a9614a9a28136e6754a">colorized_tags</a>[c].endtag))) {
<a name="l00344"></a>00344             <span class="keywordflow">continue</span>;
<a name="l00345"></a>00345          }
<a name="l00346"></a>00346 
<a name="l00347"></a>00347          len = tmp - (bwinput + i + strlen(<a class="code" href="xmldoc_8c.html#a9712901310108a9614a9a28136e6754a">colorized_tags</a>[c].inittag));
<a name="l00348"></a>00348 
<a name="l00349"></a>00349          <span class="comment">/* Setup color */</span>
<a name="l00350"></a>00350          <span class="keywordflow">if</span> (withcolors) {
<a name="l00351"></a>00351             <a class="code" href="term_8h.html#a5793417e507670e905f441b1d6e30f86" title="Append a color sequence to an ast_str.">ast_term_color_code</a>(&amp;colorized, <a class="code" href="xmldoc_8c.html#a9712901310108a9614a9a28136e6754a">colorized_tags</a>[c].colorfg, 0);
<a name="l00352"></a>00352             <span class="keywordflow">if</span> (!colorized) {
<a name="l00353"></a>00353                <span class="keywordflow">return</span> NULL;
<a name="l00354"></a>00354             }
<a name="l00355"></a>00355          }
<a name="l00356"></a>00356 
<a name="l00357"></a>00357          <span class="comment">/* copy initial string replace */</span>
<a name="l00358"></a>00358          <a class="code" href="strings_8h.html#a85cd5a8ef499e39d22b4bfeb8b9a64f7" title="Append to a thread local dynamic string.">ast_str_append</a>(&amp;colorized, 0, <span class="stringliteral">&quot;%s&quot;</span>, <a class="code" href="xmldoc_8c.html#a9712901310108a9614a9a28136e6754a">colorized_tags</a>[c].init);
<a name="l00359"></a>00359          <span class="keywordflow">if</span> (!colorized) {
<a name="l00360"></a>00360             <span class="keywordflow">return</span> NULL;
<a name="l00361"></a>00361          }
<a name="l00362"></a>00362          {
<a name="l00363"></a>00363             <span class="keywordtype">char</span> <a class="code" href="adsistub_8c.html#aa95cbf1d00929438101e64ee5a216d0c">buf</a>[len + 1];
<a name="l00364"></a>00364             <a class="code" href="strings_8h.html#a17df4d252f3e2ecb230b526475ac4d93" title="Size-limited null-terminating string copy.">ast_copy_string</a>(buf, bwinput + i + strlen(<a class="code" href="xmldoc_8c.html#a9712901310108a9614a9a28136e6754a">colorized_tags</a>[c].inittag), <span class="keyword">sizeof</span>(buf));
<a name="l00365"></a>00365             <a class="code" href="strings_8h.html#a85cd5a8ef499e39d22b4bfeb8b9a64f7" title="Append to a thread local dynamic string.">ast_str_append</a>(&amp;colorized, 0, <span class="stringliteral">&quot;%s&quot;</span>, buf);
<a name="l00366"></a>00366          }
<a name="l00367"></a>00367          <span class="keywordflow">if</span> (!colorized) {
<a name="l00368"></a>00368             <span class="keywordflow">return</span> NULL;
<a name="l00369"></a>00369          }
<a name="l00370"></a>00370 
<a name="l00371"></a>00371          <span class="comment">/* copy the ending string replace */</span>
<a name="l00372"></a>00372          <a class="code" href="strings_8h.html#a85cd5a8ef499e39d22b4bfeb8b9a64f7" title="Append to a thread local dynamic string.">ast_str_append</a>(&amp;colorized, 0, <span class="stringliteral">&quot;%s&quot;</span>, <a class="code" href="xmldoc_8c.html#a9712901310108a9614a9a28136e6754a">colorized_tags</a>[c].end);
<a name="l00373"></a>00373          <span class="keywordflow">if</span> (!colorized) {
<a name="l00374"></a>00374             <span class="keywordflow">return</span> NULL;
<a name="l00375"></a>00375          }
<a name="l00376"></a>00376 
<a name="l00377"></a>00377          <span class="comment">/* Continue with the last color. */</span>
<a name="l00378"></a>00378          <span class="keywordflow">if</span> (withcolors) {
<a name="l00379"></a>00379             <a class="code" href="term_8h.html#a5793417e507670e905f441b1d6e30f86" title="Append a color sequence to an ast_str.">ast_term_color_code</a>(&amp;colorized, base_fg, 0);
<a name="l00380"></a>00380             <span class="keywordflow">if</span> (!colorized) {
<a name="l00381"></a>00381                <span class="keywordflow">return</span> NULL;
<a name="l00382"></a>00382             }
<a name="l00383"></a>00383          }
<a name="l00384"></a>00384 
<a name="l00385"></a>00385          i += len + strlen(<a class="code" href="xmldoc_8c.html#a9712901310108a9614a9a28136e6754a">colorized_tags</a>[c].endtag) + strlen(<a class="code" href="xmldoc_8c.html#a9712901310108a9614a9a28136e6754a">colorized_tags</a>[c].inittag) - 1;
<a name="l00386"></a>00386          colorsection = 1;
<a name="l00387"></a>00387          <span class="keywordflow">break</span>;
<a name="l00388"></a>00388       }
<a name="l00389"></a>00389 
<a name="l00390"></a>00390       <span class="keywordflow">if</span> (!colorsection) {
<a name="l00391"></a>00391          <a class="code" href="strings_8h.html#a85cd5a8ef499e39d22b4bfeb8b9a64f7" title="Append to a thread local dynamic string.">ast_str_append</a>(&amp;colorized, 0, <span class="stringliteral">&quot;%c&quot;</span>, bwinput[i]);
<a name="l00392"></a>00392          <span class="keywordflow">if</span> (!colorized) {
<a name="l00393"></a>00393             <span class="keywordflow">return</span> NULL;
<a name="l00394"></a>00394          }
<a name="l00395"></a>00395       }
<a name="l00396"></a>00396    }
<a name="l00397"></a>00397 
<a name="l00398"></a>00398    <span class="keywordflow">if</span> (withcolors) {
<a name="l00399"></a>00399       <a class="code" href="strings_8h.html#a85cd5a8ef499e39d22b4bfeb8b9a64f7" title="Append to a thread local dynamic string.">ast_str_append</a>(&amp;colorized, 0, <span class="stringliteral">&quot;%s&quot;</span>, <a class="code" href="term_8h.html#a7c737dda11a1138a30529adcffaf56ff">term_end</a>());
<a name="l00400"></a>00400       <span class="keywordflow">if</span> (!colorized) {
<a name="l00401"></a>00401          <span class="keywordflow">return</span> NULL;
<a name="l00402"></a>00402       }
<a name="l00403"></a>00403    }
<a name="l00404"></a>00404 
<a name="l00405"></a>00405    <span class="comment">/* Wrap the text, notice that string wrap will avoid cutting an ESC sequence. */</span>
<a name="l00406"></a>00406    wrapped = <a class="code" href="xmldoc_8c.html#a487c5c730276403d585b07d5b4a43cd9">xmldoc_string_wrap</a>(<a class="code" href="strings_8h.html#a053bdfc229997a75f112bdd7b995e00b" title="Returns the string buffer within the ast_str buf.">ast_str_buffer</a>(colorized), xmldoc_text_columns, xmldoc_max_diff);
<a name="l00407"></a>00407 
<a name="l00408"></a>00408    <a class="code" href="astmm_8h.html#a402072d6789f6ed9e3a81da27504127e">ast_free</a>(colorized);
<a name="l00409"></a>00409 
<a name="l00410"></a>00410    <span class="keywordflow">return</span> wrapped;
<a name="l00411"></a>00411 }
<a name="l00412"></a>00412 <span class="comment"></span>
<a name="l00413"></a>00413 <span class="comment">/*! \internal</span>
<a name="l00414"></a>00414 <span class="comment"> *  \brief Cleanup spaces and tabs after a \n</span>
<a name="l00415"></a>00415 <span class="comment"> *  \param text String to be cleaned up.</span>
<a name="l00416"></a>00416 <span class="comment"> *  \param output buffer (not already allocated).</span>
<a name="l00417"></a>00417 <span class="comment"> *  \param lastspaces Remove last spaces in the string.</span>
<a name="l00418"></a>00418 <span class="comment"> */</span>
<a name="l00419"></a><a class="code" href="xmldoc_8c.html#a9b126a6b2606df7e517d382fb9565295">00419</a> <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="xmldoc_8c.html#a9b126a6b2606df7e517d382fb9565295">xmldoc_string_cleanup</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> *<a class="code" href="app__queue_8c.html#a5633b1433389cec21ade3811bbe9ca5b">text</a>, <span class="keyword">struct</span> <a class="code" href="structast__str.html" title="The descriptor of a dynamic string XXX storage will be optimized later if needed...">ast_str</a> **output, <span class="keywordtype">int</span> lastspaces)
<a name="l00420"></a>00420 {
<a name="l00421"></a>00421    <span class="keywordtype">int</span> i;
<a name="l00422"></a>00422    <span class="keywordtype">size_t</span> textlen;
<a name="l00423"></a>00423 
<a name="l00424"></a>00424    <span class="keywordflow">if</span> (!text) {
<a name="l00425"></a>00425       *output = NULL;
<a name="l00426"></a>00426       <span class="keywordflow">return</span>;
<a name="l00427"></a>00427    }
<a name="l00428"></a>00428 
<a name="l00429"></a>00429    textlen = strlen(text);
<a name="l00430"></a>00430 
<a name="l00431"></a>00431    *output = <a class="code" href="strings_8h.html#a8ec37e4acb6ecb20eb6f6edd1141cd76" title="Create a malloc&amp;#39;ed dynamic length string.">ast_str_create</a>(textlen);
<a name="l00432"></a>00432    <span class="keywordflow">if</span> (!(*output)) {
<a name="l00433"></a>00433       <a class="code" href="logger_8h.html#a93dd824dff97fe84941d6d71b7a3710e" title="Used for sending a log message This is the standard logger function. Probably the...">ast_log</a>(<a class="code" href="logger_8h.html#aced66975c154ea0e2a8ec3bc818b4e08">LOG_ERROR</a>, <span class="stringliteral">&quot;Problem allocating output buffer\n&quot;</span>);
<a name="l00434"></a>00434       <span class="keywordflow">return</span>;
<a name="l00435"></a>00435    }
<a name="l00436"></a>00436 
<a name="l00437"></a>00437    <span class="keywordflow">for</span> (i = 0; i &lt; textlen; i++) {
<a name="l00438"></a>00438       <span class="keywordflow">if</span> (text[i] == <span class="charliteral">&apos;\n&apos;</span> || text[i] == <span class="charliteral">&apos;\r&apos;</span>) {
<a name="l00439"></a>00439          <span class="comment">/* remove spaces/tabs/\n after a \n. */</span>
<a name="l00440"></a>00440          <span class="keywordflow">while</span> (text[i + 1] == <span class="charliteral">&apos;\t&apos;</span> || text[i + 1] == <span class="charliteral">&apos;\r&apos;</span> || text[i + 1] == <span class="charliteral">&apos;\n&apos;</span>) {
<a name="l00441"></a>00441             i++;
<a name="l00442"></a>00442          }
<a name="l00443"></a>00443          <a class="code" href="strings_8h.html#a85cd5a8ef499e39d22b4bfeb8b9a64f7" title="Append to a thread local dynamic string.">ast_str_append</a>(output, 0, <span class="stringliteral">&quot; &quot;</span>);
<a name="l00444"></a>00444          <span class="keywordflow">continue</span>;
<a name="l00445"></a>00445       } <span class="keywordflow">else</span> {
<a name="l00446"></a>00446          <a class="code" href="strings_8h.html#a85cd5a8ef499e39d22b4bfeb8b9a64f7" title="Append to a thread local dynamic string.">ast_str_append</a>(output, 0, <span class="stringliteral">&quot;%c&quot;</span>, text[i]);
<a name="l00447"></a>00447       }
<a name="l00448"></a>00448    }
<a name="l00449"></a>00449 
<a name="l00450"></a>00450    <span class="comment">/* remove last spaces (we dont want always to remove the trailing spaces). */</span>
<a name="l00451"></a>00451    <span class="keywordflow">if</span> (lastspaces) {
<a name="l00452"></a>00452       <a class="code" href="strings_8h.html#ae3e706d91ba9d9c15352733d89750135" title="Trims trailing whitespace characters from an ast_str string.">ast_str_trim_blanks</a>(*output);
<a name="l00453"></a>00453    }
<a name="l00454"></a>00454 }
<a name="l00455"></a>00455 <span class="comment"></span>
<a name="l00456"></a>00456 <span class="comment">/*! \internal</span>
<a name="l00457"></a>00457 <span class="comment"> *  \brief Get the application/function node for &apos;name&apos; application/function with language &apos;language&apos;</span>
<a name="l00458"></a>00458 <span class="comment"> *         if we don&apos;t find any, get the first application with &apos;name&apos; no matter which language with.</span>
<a name="l00459"></a>00459 <span class="comment"> *  \param type &apos;application&apos;, &apos;function&apos;, ...</span>
<a name="l00460"></a>00460 <span class="comment"> *  \param name Application or Function name.</span>
<a name="l00461"></a>00461 <span class="comment"> *  \param language Try to get this language (if not found try with en_US)</span>
<a name="l00462"></a>00462 <span class="comment"> *  \retval NULL on error.</span>
<a name="l00463"></a>00463 <span class="comment"> *  \retval A node of type ast_xml_node.</span>
<a name="l00464"></a>00464 <span class="comment"> */</span>
<a name="l00465"></a><a class="code" href="xmldoc_8c.html#af1f439077def997dc752361c8dbdcb12">00465</a> <span class="keyword">static</span> <span class="keyword">struct </span>ast_xml_node *<a class="code" href="xmldoc_8c.html#af1f439077def997dc752361c8dbdcb12">xmldoc_get_node</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> *<a class="code" href="evt_8c.html#a69e2889a94aeb9ac881abb82d3c22116">type</a>, <span class="keyword">const</span> <span class="keywordtype">char</span> *<a class="code" href="cdr__adaptive__odbc_8c.html#a5ac083a645d964373f022d03df4849c8">name</a>, <span class="keyword">const</span> <span class="keywordtype">char</span> *<a class="code" href="chan__alsa_8c.html#adf416dc058363e2fd5750c77e2d78bee">language</a>)
<a name="l00466"></a>00466 {
<a name="l00467"></a>00467    <span class="keyword">struct </span>ast_xml_node *node = NULL;
<a name="l00468"></a>00468    <span class="keyword">struct </span><a class="code" href="structdocumentation__tree.html" title="XML documentation tree.">documentation_tree</a> *doctree;
<a name="l00469"></a>00469    <span class="keyword">const</span> <span class="keywordtype">char</span> *lang;
<a name="l00470"></a>00470 
<a name="l00471"></a>00471    <a class="code" href="linkedlists_8h.html#a0a0fe104cc2cc36a43784f886f3ae7dc" title="Read locks a list.">AST_RWLIST_RDLOCK</a>(&amp;<a class="code" href="structxmldoc__tree.html" title="Container of documentation trees.">xmldoc_tree</a>);
<a name="l00472"></a>00472    <a class="code" href="linkedlists_8h.html#a3008b2f4f236b72d8bcfb80e346324ef" title="Loops over (traverses) the entries in a list.">AST_LIST_TRAVERSE</a>(&amp;<a class="code" href="structxmldoc__tree.html" title="Container of documentation trees.">xmldoc_tree</a>, doctree, <a class="code" href="structdocumentation__tree.html#a9770eb03f735793008007de780d8b2f1">entry</a>) {
<a name="l00473"></a>00473       <span class="comment">/* the core xml documents have priority over thirdparty document. */</span>
<a name="l00474"></a>00474       node = <a class="code" href="xml_8h.html#af84bcc8281d822193294dcadd247ac75" title="Get the document root node.">ast_xml_get_root</a>(doctree-&gt;<a class="code" href="structdocumentation__tree.html#a8702ea03f4a7d2e0bcca01893d9dd5a6">doc</a>);
<a name="l00475"></a>00475       <span class="keywordflow">while</span> ((node = <a class="code" href="xml_8h.html#a8299a9da6d1e609761341b3ca45bc771" title="Find a node element by name.">ast_xml_find_element</a>(node, type, <span class="stringliteral">&quot;name&quot;</span>, name))) {
<a name="l00476"></a>00476          <span class="comment">/* Check language */</span>
<a name="l00477"></a>00477          lang = <a class="code" href="xml_8h.html#aa530ec72e11a97546295ede1736a1475" title="Get a node attribute by name.">ast_xml_get_attribute</a>(node, <span class="stringliteral">&quot;language&quot;</span>);
<a name="l00478"></a>00478          <span class="keywordflow">if</span> (lang &amp;&amp; !strcmp(lang, language)) {
<a name="l00479"></a>00479             <a class="code" href="xml_8h.html#a8a555ceb9dcd4102c73aad5304ff2f34" title="Free an attribute returned by ast_xml_get_attribute().">ast_xml_free_attr</a>(lang);
<a name="l00480"></a>00480             <span class="keywordflow">break</span>;
<a name="l00481"></a>00481          } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (lang) {
<a name="l00482"></a>00482             <a class="code" href="xml_8h.html#a8a555ceb9dcd4102c73aad5304ff2f34" title="Free an attribute returned by ast_xml_get_attribute().">ast_xml_free_attr</a>(lang);
<a name="l00483"></a>00483          }
<a name="l00484"></a>00484       }
<a name="l00485"></a>00485 
<a name="l00486"></a>00486       <span class="keywordflow">if</span> (node &amp;&amp; <a class="code" href="xml_8h.html#a6064a4b3e299bb92aa8c8c7c1b363527" title="Get the node&amp;#39;s children.">ast_xml_node_get_children</a>(node)) {
<a name="l00487"></a>00487          <span class="keywordflow">break</span>;
<a name="l00488"></a>00488       }
<a name="l00489"></a>00489 
<a name="l00490"></a>00490       <span class="comment">/* We didn&apos;t find the application documentation for the specified language,</span>
<a name="l00491"></a>00491 <span class="comment">      so, try to load documentation for any language */</span>
<a name="l00492"></a>00492       node = <a class="code" href="xml_8h.html#af84bcc8281d822193294dcadd247ac75" title="Get the document root node.">ast_xml_get_root</a>(doctree-&gt;<a class="code" href="structdocumentation__tree.html#a8702ea03f4a7d2e0bcca01893d9dd5a6">doc</a>);
<a name="l00493"></a>00493       <span class="keywordflow">if</span> (<a class="code" href="xml_8h.html#a6064a4b3e299bb92aa8c8c7c1b363527" title="Get the node&amp;#39;s children.">ast_xml_node_get_children</a>(node)) {
<a name="l00494"></a>00494          <span class="keywordflow">if</span> ((node = <a class="code" href="xml_8h.html#a8299a9da6d1e609761341b3ca45bc771" title="Find a node element by name.">ast_xml_find_element</a>(<a class="code" href="xml_8h.html#a6064a4b3e299bb92aa8c8c7c1b363527" title="Get the node&amp;#39;s children.">ast_xml_node_get_children</a>(node), type, <span class="stringliteral">&quot;name&quot;</span>, name))) {
<a name="l00495"></a>00495             <span class="keywordflow">break</span>;
<a name="l00496"></a>00496          }
<a name="l00497"></a>00497       }
<a name="l00498"></a>00498    }
<a name="l00499"></a>00499    <a class="code" href="linkedlists_8h.html#a2e9a2518b5029b96671aff6701bd5138" title="Attempts to unlock a read/write based list.">AST_RWLIST_UNLOCK</a>(&amp;<a class="code" href="structxmldoc__tree.html" title="Container of documentation trees.">xmldoc_tree</a>);
<a name="l00500"></a>00500 
<a name="l00501"></a>00501    <span class="keywordflow">return</span> node;
<a name="l00502"></a>00502 }
<a name="l00503"></a>00503 <span class="comment"></span>
<a name="l00504"></a>00504 <span class="comment">/*! \internal</span>
<a name="l00505"></a>00505 <span class="comment"> *  \brief Helper function used to build the syntax, it allocates the needed buffer (or reallocates it),</span>
<a name="l00506"></a>00506 <span class="comment"> *         and based on the reverse value it makes use of fmt to print the parameter list inside the</span>
<a name="l00507"></a>00507 <span class="comment"> *         realloced buffer (syntax).</span>
<a name="l00508"></a>00508 <span class="comment"> *  \param reverse We are going backwards while generating the syntax?</span>
<a name="l00509"></a>00509 <span class="comment"> *  \param len Current length of &apos;syntax&apos; buffer.</span>
<a name="l00510"></a>00510 <span class="comment"> *  \param syntax Output buffer for the concatenated values.</span>
<a name="l00511"></a>00511 <span class="comment"> *  \param fmt A format string that will be used in a sprintf call.</span>
<a name="l00512"></a>00512 <span class="comment"> */</span>
<a name="l00513"></a><a class="code" href="xmldoc_8c.html#a9d998b7270794b87e9ace7b566ac4795">00513</a> <span class="keyword">static</span> <span class="keywordtype">void</span> __attribute__((<a class="code" href="cdr__custom_8c.html#a2177723f86d0a496f395614f4493cd7f">format</a>(printf, 4, 5))) <a class="code" href="xmldoc_8c.html#a9d998b7270794b87e9ace7b566ac4795">xmldoc_reverse_helper</a>(<span class="keywordtype">int</span> reverse, <span class="keywordtype">int</span> *<a class="code" href="func__strings_8c.html#af24e73aaf92f3000fda15d285e66df24">len</a>, <span class="keywordtype">char</span> **syntax, const <span class="keywordtype">char</span> *fmt, ...)
<a name="l00514"></a>00514 {
<a name="l00515"></a>00515    <span class="keywordtype">int</span> totlen, tmpfmtlen;
<a name="l00516"></a>00516    <span class="keywordtype">char</span> *tmpfmt, tmp;
<a name="l00517"></a>00517    va_list ap;
<a name="l00518"></a>00518 
<a name="l00519"></a>00519    va_start(ap, fmt);
<a name="l00520"></a>00520    <span class="keywordflow">if</span> (<a class="code" href="astmm_8h.html#a5a4c348a0a93c313c8463d4756e86270">ast_vasprintf</a>(&amp;tmpfmt, fmt, ap) &lt; 0) {
<a name="l00521"></a>00521       va_end(ap);
<a name="l00522"></a>00522       <span class="keywordflow">return</span>;
<a name="l00523"></a>00523    }
<a name="l00524"></a>00524    va_end(ap);
<a name="l00525"></a>00525 
<a name="l00526"></a>00526    tmpfmtlen = strlen(tmpfmt);
<a name="l00527"></a>00527    totlen = *len + tmpfmtlen + 1;
<a name="l00528"></a>00528 
<a name="l00529"></a>00529    *syntax = <a class="code" href="astmm_8h.html#aa852314efa0cfeecee97ffc51b649734">ast_realloc</a>(*syntax, totlen);
<a name="l00530"></a>00530 
<a name="l00531"></a>00531    <span class="keywordflow">if</span> (!*syntax) {
<a name="l00532"></a>00532       <a class="code" href="astmm_8h.html#a402072d6789f6ed9e3a81da27504127e">ast_free</a>(tmpfmt);
<a name="l00533"></a>00533       <span class="keywordflow">return</span>;
<a name="l00534"></a>00534    }
<a name="l00535"></a>00535 
<a name="l00536"></a>00536    <span class="keywordflow">if</span> (reverse) {
<a name="l00537"></a>00537       memmove(*syntax + tmpfmtlen, *syntax, *len);
<a name="l00538"></a>00538       <span class="comment">/* Save this char, it will be overwritten by the \0 of strcpy. */</span>
<a name="l00539"></a>00539       tmp = (*syntax)[0];
<a name="l00540"></a>00540       strcpy(*syntax, tmpfmt);
<a name="l00541"></a>00541       <span class="comment">/* Restore the already saved char. */</span>
<a name="l00542"></a>00542       (*syntax)[tmpfmtlen] = tmp;
<a name="l00543"></a>00543       (*syntax)[totlen - 1] = <span class="charliteral">&apos;\0&apos;</span>;
<a name="l00544"></a>00544    } <span class="keywordflow">else</span> {
<a name="l00545"></a>00545       strcpy(*syntax + *len, tmpfmt);
<a name="l00546"></a>00546    }
<a name="l00547"></a>00547 
<a name="l00548"></a>00548    *len = totlen - 1;
<a name="l00549"></a>00549    <a class="code" href="astmm_8h.html#a402072d6789f6ed9e3a81da27504127e">ast_free</a>(tmpfmt);
<a name="l00550"></a>00550 }
<a name="l00551"></a>00551 <span class="comment"></span>
<a name="l00552"></a>00552 <span class="comment">/*! \internal</span>
<a name="l00553"></a>00553 <span class="comment"> *  \brief Check if the passed node has &apos;what&apos; tags inside it.</span>
<a name="l00554"></a>00554 <span class="comment"> *  \param node Root node to search &apos;what&apos; elements.</span>
<a name="l00555"></a>00555 <span class="comment"> *  \param what node name to search inside node.</span>
<a name="l00556"></a>00556 <span class="comment"> *  \retval 1 If a &apos;what&apos; element is found inside &apos;node&apos;.</span>
<a name="l00557"></a>00557 <span class="comment"> *  \retval 0 If no &apos;what&apos; is found inside &apos;node&apos;.</span>
<a name="l00558"></a>00558 <span class="comment"> */</span>
<a name="l00559"></a><a class="code" href="xmldoc_8c.html#ab9142298d52f52d3e9bf70ed451d6fdd">00559</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="xmldoc_8c.html#ab9142298d52f52d3e9bf70ed451d6fdd">xmldoc_has_inside</a>(<span class="keyword">struct</span> ast_xml_node *fixnode, <span class="keyword">const</span> <span class="keywordtype">char</span> *what)
<a name="l00560"></a>00560 {
<a name="l00561"></a>00561    <span class="keyword">struct </span>ast_xml_node *node = fixnode;
<a name="l00562"></a>00562 
<a name="l00563"></a>00563    <span class="keywordflow">for</span> (node = <a class="code" href="xml_8h.html#a6064a4b3e299bb92aa8c8c7c1b363527" title="Get the node&amp;#39;s children.">ast_xml_node_get_children</a>(fixnode); node; node = <a class="code" href="xml_8h.html#aa7d34402682c9bc1dfb9aea971f9eba7" title="Get the next node in the same level.">ast_xml_node_get_next</a>(node)) {
<a name="l00564"></a>00564       <span class="keywordflow">if</span> (!strcasecmp(<a class="code" href="xml_8h.html#a02cd60b8b2d5d96e78c858429b1b1d11" title="Get the name of a node.">ast_xml_node_get_name</a>(node), what)) {
<a name="l00565"></a>00565          <span class="keywordflow">return</span> 1;
<a name="l00566"></a>00566       }
<a name="l00567"></a>00567    }
<a name="l00568"></a>00568    <span class="keywordflow">return</span> 0;
<a name="l00569"></a>00569 }
<a name="l00570"></a>00570 <span class="comment"></span>
<a name="l00571"></a>00571 <span class="comment">/*! \internal</span>
<a name="l00572"></a>00572 <span class="comment"> *  \brief Check if the passed node has at least one node inside it.</span>
<a name="l00573"></a>00573 <span class="comment"> *  \param node Root node to search node elements.</span>
<a name="l00574"></a>00574 <span class="comment"> *  \retval 1 If a node element is found inside &apos;node&apos;.</span>
<a name="l00575"></a>00575 <span class="comment"> *  \retval 0 If no node is found inside &apos;node&apos;.</span>
<a name="l00576"></a>00576 <span class="comment"> */</span>
<a name="l00577"></a><a class="code" href="xmldoc_8c.html#a052d764bc5bb5448d5da692e8ec9fdaa">00577</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="xmldoc_8c.html#a052d764bc5bb5448d5da692e8ec9fdaa">xmldoc_has_nodes</a>(<span class="keyword">struct</span> ast_xml_node *fixnode)
<a name="l00578"></a>00578 {
<a name="l00579"></a>00579    <span class="keyword">struct </span>ast_xml_node *node = fixnode;
<a name="l00580"></a>00580 
<a name="l00581"></a>00581    <span class="keywordflow">for</span> (node = <a class="code" href="xml_8h.html#a6064a4b3e299bb92aa8c8c7c1b363527" title="Get the node&amp;#39;s children.">ast_xml_node_get_children</a>(fixnode); node; node = <a class="code" href="xml_8h.html#aa7d34402682c9bc1dfb9aea971f9eba7" title="Get the next node in the same level.">ast_xml_node_get_next</a>(node)) {
<a name="l00582"></a>00582       <span class="keywordflow">if</span> (strcasecmp(<a class="code" href="xml_8h.html#a02cd60b8b2d5d96e78c858429b1b1d11" title="Get the name of a node.">ast_xml_node_get_name</a>(node), <span class="stringliteral">&quot;text&quot;</span>)) {
<a name="l00583"></a>00583          <span class="keywordflow">return</span> 1;
<a name="l00584"></a>00584       }
<a name="l00585"></a>00585    }
<a name="l00586"></a>00586    <span class="keywordflow">return</span> 0;
<a name="l00587"></a>00587 }
<a name="l00588"></a>00588 <span class="comment"></span>
<a name="l00589"></a>00589 <span class="comment">/*! \internal</span>
<a name="l00590"></a>00590 <span class="comment"> *  \brief Check if the passed node has at least one specialtag.</span>
<a name="l00591"></a>00591 <span class="comment"> *  \param node Root node to search &quot;specialtags&quot; elements.</span>
<a name="l00592"></a>00592 <span class="comment"> *  \retval 1 If a &quot;specialtag&quot; element is found inside &apos;node&apos;.</span>
<a name="l00593"></a>00593 <span class="comment"> *  \retval 0 If no &quot;specialtag&quot; is found inside &apos;node&apos;.</span>
<a name="l00594"></a>00594 <span class="comment"> */</span>
<a name="l00595"></a><a class="code" href="xmldoc_8c.html#a91c8dec3abf7f3ca868e5fd33d81f866">00595</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="xmldoc_8c.html#a91c8dec3abf7f3ca868e5fd33d81f866">xmldoc_has_specialtags</a>(<span class="keyword">struct</span> ast_xml_node *fixnode)
<a name="l00596"></a>00596 {
<a name="l00597"></a>00597    <span class="keyword">struct </span>ast_xml_node *node = fixnode;
<a name="l00598"></a>00598    <span class="keywordtype">int</span> i;
<a name="l00599"></a>00599 
<a name="l00600"></a>00600    <span class="keywordflow">for</span> (node = <a class="code" href="xml_8h.html#a6064a4b3e299bb92aa8c8c7c1b363527" title="Get the node&amp;#39;s children.">ast_xml_node_get_children</a>(fixnode); node; node = <a class="code" href="xml_8h.html#aa7d34402682c9bc1dfb9aea971f9eba7" title="Get the next node in the same level.">ast_xml_node_get_next</a>(node)) {
<a name="l00601"></a>00601       <span class="keywordflow">for</span> (i = 0; i &lt; <a class="code" href="isdn__lib_8c.html#ab9129b977a587b50ea801daac75e178f">ARRAY_LEN</a>(<a class="code" href="xmldoc_8c.html#a2779d1b00e3343992468fe48be466553">special_tags</a>); i++) {
<a name="l00602"></a>00602          <span class="keywordflow">if</span> (!strcasecmp(<a class="code" href="xml_8h.html#a02cd60b8b2d5d96e78c858429b1b1d11" title="Get the name of a node.">ast_xml_node_get_name</a>(node), <a class="code" href="xmldoc_8c.html#a2779d1b00e3343992468fe48be466553">special_tags</a>[i].tagname)) {
<a name="l00603"></a>00603             <span class="keywordflow">return</span> 1;
<a name="l00604"></a>00604          }
<a name="l00605"></a>00605       }
<a name="l00606"></a>00606    }
<a name="l00607"></a>00607    <span class="keywordflow">return</span> 0;
<a name="l00608"></a>00608 }
<a name="l00609"></a>00609 <span class="comment"></span>
<a name="l00610"></a>00610 <span class="comment">/*! \internal</span>
<a name="l00611"></a>00611 <span class="comment"> *  \brief Build the syntax for a specified starting node.</span>
<a name="l00612"></a>00612 <span class="comment"> *  \param rootnode A pointer to the ast_xml root node.</span>
<a name="l00613"></a>00613 <span class="comment"> *  \param rootname Name of the application, function, option, etc. to build the syntax.</span>
<a name="l00614"></a>00614 <span class="comment"> *  \param childname The name of each parameter node.</span>
<a name="l00615"></a>00615 <span class="comment"> *  \param printparenthesis Boolean if we must print parenthesis if not parameters are found in the rootnode.</span>
<a name="l00616"></a>00616 <span class="comment"> *  \param printrootname Boolean if we must print the rootname before the syntax and parenthesis at the begining/end.</span>
<a name="l00617"></a>00617 <span class="comment"> *  \retval NULL on error.</span>
<a name="l00618"></a>00618 <span class="comment"> *  \retval An ast_malloc&apos;ed string with the syntax generated.</span>
<a name="l00619"></a>00619 <span class="comment"> */</span>
<a name="l00620"></a><a class="code" href="xmldoc_8c.html#a6cc1d90ffce561545d1d4d9e6d5a8df1">00620</a> <span class="keyword">static</span> <span class="keywordtype">char</span> *<a class="code" href="xmldoc_8c.html#a6cc1d90ffce561545d1d4d9e6d5a8df1">xmldoc_get_syntax_fun</a>(<span class="keyword">struct</span> ast_xml_node *rootnode, <span class="keyword">const</span> <span class="keywordtype">char</span> *rootname, <span class="keyword">const</span> <span class="keywordtype">char</span> *childname, <span class="keywordtype">int</span> printparenthesis, <span class="keywordtype">int</span> printrootname)
<a name="l00621"></a>00621 {
<a name="l00622"></a>00622 <span class="preprocessor">#define GOTONEXT(__rev, __a) (__rev ? ast_xml_node_get_prev(__a) : ast_xml_node_get_next(__a))</span>
<a name="l00623"></a>00623 <span class="preprocessor"></span><span class="preprocessor">#define ISLAST(__rev, __a)  (__rev == 1 ? (ast_xml_node_get_prev(__a) ? 0 : 1) : (ast_xml_node_get_next(__a) ? 0 : 1))</span>
<a name="l00624"></a>00624 <span class="preprocessor"></span><span class="preprocessor">#define MP(__a) ((multiple ? __a : &quot;&quot;))</span>
<a name="l00625"></a>00625 <span class="preprocessor"></span>   <span class="keyword">struct </span>ast_xml_node *node = NULL, *firstparam = NULL, *lastparam = NULL;
<a name="l00626"></a>00626    <span class="keyword">const</span> <span class="keywordtype">char</span> *paramtype, *multipletype, *paramnameattr, *attrargsep, *parenthesis, *argname;
<a name="l00627"></a>00627    <span class="keywordtype">int</span> reverse, required, paramcount = 0, openbrackets = 0, <a class="code" href="func__strings_8c.html#af24e73aaf92f3000fda15d285e66df24">len</a> = 0, hasparams=0;
<a name="l00628"></a>00628    <span class="keywordtype">int</span> reqfinode = 0, reqlanode = 0, optmidnode = 0, prnparenthesis, multiple;
<a name="l00629"></a>00629    <span class="keywordtype">char</span> *syntax = NULL, *argsep, *paramname;
<a name="l00630"></a>00630 
<a name="l00631"></a>00631    <span class="keywordflow">if</span> (<a class="code" href="strings_8h.html#a5c8aa5212ecb665fb072eac00c799da6">ast_strlen_zero</a>(rootname) || <a class="code" href="strings_8h.html#a5c8aa5212ecb665fb072eac00c799da6">ast_strlen_zero</a>(childname)) {
<a name="l00632"></a>00632       <a class="code" href="logger_8h.html#a93dd824dff97fe84941d6d71b7a3710e" title="Used for sending a log message This is the standard logger function. Probably the...">ast_log</a>(<a class="code" href="logger_8h.html#adf4476a6a4ea6c74231c826e899d7189">LOG_WARNING</a>, <span class="stringliteral">&quot;Tried to look in XML tree with faulty rootname or childname while creating a syntax.\n&quot;</span>);
<a name="l00633"></a>00633       <span class="keywordflow">return</span> NULL;
<a name="l00634"></a>00634    }
<a name="l00635"></a>00635 
<a name="l00636"></a>00636    <span class="keywordflow">if</span> (!rootnode || !<a class="code" href="xml_8h.html#a6064a4b3e299bb92aa8c8c7c1b363527" title="Get the node&amp;#39;s children.">ast_xml_node_get_children</a>(rootnode)) {
<a name="l00637"></a>00637       <span class="comment">/* If the rootnode field is not found, at least print name. */</span>
<a name="l00638"></a>00638       <a class="code" href="astmm_8h.html#aee6f1d27500ac19fa0b842022f987817">ast_asprintf</a>(&amp;syntax, <span class="stringliteral">&quot;%s%s&quot;</span>, (printrootname ? rootname : <span class="stringliteral">&quot;&quot;</span>), (printparenthesis ? <span class="stringliteral">&quot;()&quot;</span> : <span class="stringliteral">&quot;&quot;</span>));
<a name="l00639"></a>00639       <span class="keywordflow">return</span> syntax;
<a name="l00640"></a>00640    }
<a name="l00641"></a>00641 
<a name="l00642"></a>00642    <span class="comment">/* Get the argument separator from the root node attribute name &apos;argsep&apos;, if not found</span>
<a name="l00643"></a>00643 <span class="comment">   defaults to &apos;,&apos;. */</span>
<a name="l00644"></a>00644    attrargsep = <a class="code" href="xml_8h.html#aa530ec72e11a97546295ede1736a1475" title="Get a node attribute by name.">ast_xml_get_attribute</a>(rootnode, <span class="stringliteral">&quot;argsep&quot;</span>);
<a name="l00645"></a>00645    <span class="keywordflow">if</span> (attrargsep) {
<a name="l00646"></a>00646       argsep = <a class="code" href="utils_8h.html#ab5f0750cc80ba337fdcbddea2d3a1ee6" title="duplicate a string in memory from the stack">ast_strdupa</a>(attrargsep);
<a name="l00647"></a>00647       <a class="code" href="xml_8h.html#a8a555ceb9dcd4102c73aad5304ff2f34" title="Free an attribute returned by ast_xml_get_attribute().">ast_xml_free_attr</a>(attrargsep);
<a name="l00648"></a>00648    } <span class="keywordflow">else</span> {
<a name="l00649"></a>00649       argsep = <a class="code" href="utils_8h.html#ab5f0750cc80ba337fdcbddea2d3a1ee6" title="duplicate a string in memory from the stack">ast_strdupa</a>(<span class="stringliteral">&quot;,&quot;</span>);
<a name="l00650"></a>00650    }
<a name="l00651"></a>00651 
<a name="l00652"></a>00652    <span class="comment">/* Get order of evaluation. */</span>
<a name="l00653"></a>00653    <span class="keywordflow">for</span> (node = <a class="code" href="xml_8h.html#a6064a4b3e299bb92aa8c8c7c1b363527" title="Get the node&amp;#39;s children.">ast_xml_node_get_children</a>(rootnode); node; node = <a class="code" href="xml_8h.html#aa7d34402682c9bc1dfb9aea971f9eba7" title="Get the next node in the same level.">ast_xml_node_get_next</a>(node)) {
<a name="l00654"></a>00654       <span class="keywordflow">if</span> (strcasecmp(<a class="code" href="xml_8h.html#a02cd60b8b2d5d96e78c858429b1b1d11" title="Get the name of a node.">ast_xml_node_get_name</a>(node), childname)) {
<a name="l00655"></a>00655          <span class="keywordflow">continue</span>;
<a name="l00656"></a>00656       }
<a name="l00657"></a>00657       required = 0;
<a name="l00658"></a>00658       hasparams = 1;
<a name="l00659"></a>00659       <span class="keywordflow">if</span> ((paramtype = <a class="code" href="xml_8h.html#aa530ec72e11a97546295ede1736a1475" title="Get a node attribute by name.">ast_xml_get_attribute</a>(node, <span class="stringliteral">&quot;required&quot;</span>))) {
<a name="l00660"></a>00660          <span class="keywordflow">if</span> (<a class="code" href="strings_8h.html#a387a69b3871ca31061566a73f45d20f4" title="Make sure something is true. Determine if a string containing a boolean value is...">ast_true</a>(paramtype)) {
<a name="l00661"></a>00661             required = 1;
<a name="l00662"></a>00662          }
<a name="l00663"></a>00663          <a class="code" href="xml_8h.html#a8a555ceb9dcd4102c73aad5304ff2f34" title="Free an attribute returned by ast_xml_get_attribute().">ast_xml_free_attr</a>(paramtype);
<a name="l00664"></a>00664       }
<a name="l00665"></a>00665 
<a name="l00666"></a>00666       lastparam = node;
<a name="l00667"></a>00667       reqlanode = required;
<a name="l00668"></a>00668 
<a name="l00669"></a>00669       <span class="keywordflow">if</span> (!firstparam) {
<a name="l00670"></a>00670          <span class="comment">/* first parameter node */</span>
<a name="l00671"></a>00671          firstparam = node;
<a name="l00672"></a>00672          reqfinode = required;
<a name="l00673"></a>00673       }
<a name="l00674"></a>00674    }
<a name="l00675"></a>00675 
<a name="l00676"></a>00676    <span class="keywordflow">if</span> (!hasparams) {
<a name="l00677"></a>00677       <span class="comment">/* This application, function, option, etc, doesn&apos;t have any params. */</span>
<a name="l00678"></a>00678       <a class="code" href="astmm_8h.html#aee6f1d27500ac19fa0b842022f987817">ast_asprintf</a>(&amp;syntax, <span class="stringliteral">&quot;%s%s&quot;</span>, (printrootname ? rootname : <span class="stringliteral">&quot;&quot;</span>), (printparenthesis ? <span class="stringliteral">&quot;()&quot;</span> : <span class="stringliteral">&quot;&quot;</span>));
<a name="l00679"></a>00679       <span class="keywordflow">return</span> syntax;
<a name="l00680"></a>00680    }
<a name="l00681"></a>00681 
<a name="l00682"></a>00682    <span class="keywordflow">if</span> (reqfinode &amp;&amp; reqlanode) {
<a name="l00683"></a>00683       <span class="comment">/* check midnode */</span>
<a name="l00684"></a>00684       <span class="keywordflow">for</span> (node = <a class="code" href="xml_8h.html#a6064a4b3e299bb92aa8c8c7c1b363527" title="Get the node&amp;#39;s children.">ast_xml_node_get_children</a>(rootnode); node; node = <a class="code" href="xml_8h.html#aa7d34402682c9bc1dfb9aea971f9eba7" title="Get the next node in the same level.">ast_xml_node_get_next</a>(node)) {
<a name="l00685"></a>00685          <span class="keywordflow">if</span> (strcasecmp(<a class="code" href="xml_8h.html#a02cd60b8b2d5d96e78c858429b1b1d11" title="Get the name of a node.">ast_xml_node_get_name</a>(node), childname)) {
<a name="l00686"></a>00686             <span class="keywordflow">continue</span>;
<a name="l00687"></a>00687          }
<a name="l00688"></a>00688          <span class="keywordflow">if</span> (node != firstparam &amp;&amp; node != lastparam) {
<a name="l00689"></a>00689             <span class="keywordflow">if</span> ((paramtype = <a class="code" href="xml_8h.html#aa530ec72e11a97546295ede1736a1475" title="Get a node attribute by name.">ast_xml_get_attribute</a>(node, <span class="stringliteral">&quot;required&quot;</span>))) {
<a name="l00690"></a>00690                <span class="keywordflow">if</span> (!<a class="code" href="strings_8h.html#a387a69b3871ca31061566a73f45d20f4" title="Make sure something is true. Determine if a string containing a boolean value is...">ast_true</a>(paramtype)) {
<a name="l00691"></a>00691                   optmidnode = 1;
<a name="l00692"></a>00692                   <span class="keywordflow">break</span>;
<a name="l00693"></a>00693                }
<a name="l00694"></a>00694                <a class="code" href="xml_8h.html#a8a555ceb9dcd4102c73aad5304ff2f34" title="Free an attribute returned by ast_xml_get_attribute().">ast_xml_free_attr</a>(paramtype);
<a name="l00695"></a>00695             }
<a name="l00696"></a>00696          }
<a name="l00697"></a>00697       }
<a name="l00698"></a>00698    }
<a name="l00699"></a>00699 
<a name="l00700"></a>00700    <span class="keywordflow">if</span> ((!reqfinode &amp;&amp; reqlanode) || (reqfinode &amp;&amp; reqlanode &amp;&amp; optmidnode)) {
<a name="l00701"></a>00701       reverse = 1;
<a name="l00702"></a>00702       node = lastparam;
<a name="l00703"></a>00703    } <span class="keywordflow">else</span> {
<a name="l00704"></a>00704       reverse = 0;
<a name="l00705"></a>00705       node = firstparam;
<a name="l00706"></a>00706    }
<a name="l00707"></a>00707 
<a name="l00708"></a>00708    <span class="comment">/* init syntax string. */</span>
<a name="l00709"></a>00709    <span class="keywordflow">if</span> (reverse) {
<a name="l00710"></a>00710       <a class="code" href="xmldoc_8c.html#a9d998b7270794b87e9ace7b566ac4795">xmldoc_reverse_helper</a>(reverse, &amp;<a class="code" href="func__strings_8c.html#af24e73aaf92f3000fda15d285e66df24">len</a>, &amp;syntax,
<a name="l00711"></a>00711          (printrootname ? (printrootname == 2 ? <span class="stringliteral">&quot;)]&quot;</span> : <span class="stringliteral">&quot;)&quot;</span>): <span class="stringliteral">&quot;&quot;</span>));
<a name="l00712"></a>00712    } <span class="keywordflow">else</span> {
<a name="l00713"></a>00713       <a class="code" href="xmldoc_8c.html#a9d998b7270794b87e9ace7b566ac4795">xmldoc_reverse_helper</a>(reverse, &amp;<a class="code" href="func__strings_8c.html#af24e73aaf92f3000fda15d285e66df24">len</a>, &amp;syntax, <span class="stringliteral">&quot;%s%s&quot;</span>, (printrootname ? rootname : <span class="stringliteral">&quot;&quot;</span>),
<a name="l00714"></a>00714          (printrootname ? (printrootname == 2 ? <span class="stringliteral">&quot;[(&quot;</span> : <span class="stringliteral">&quot;(&quot;</span>) : <span class="stringliteral">&quot;&quot;</span>));
<a name="l00715"></a>00715    }
<a name="l00716"></a>00716 
<a name="l00717"></a>00717    <span class="keywordflow">for</span> (; node; node = <a class="code" href="xmldoc_8c.html#ac3183a381ef15aaa6dcfb7a307bd7de8">GOTONEXT</a>(reverse, node)) {
<a name="l00718"></a>00718       <span class="keywordflow">if</span> (strcasecmp(<a class="code" href="xml_8h.html#a02cd60b8b2d5d96e78c858429b1b1d11" title="Get the name of a node.">ast_xml_node_get_name</a>(node), childname)) {
<a name="l00719"></a>00719          <span class="keywordflow">continue</span>;
<a name="l00720"></a>00720       }
<a name="l00721"></a>00721 
<a name="l00722"></a>00722       <span class="comment">/* Get the argument name, if it is not the leaf, go inside that parameter. */</span>
<a name="l00723"></a>00723       <span class="keywordflow">if</span> (<a class="code" href="xmldoc_8c.html#ab9142298d52f52d3e9bf70ed451d6fdd">xmldoc_has_inside</a>(node, <span class="stringliteral">&quot;argument&quot;</span>)) {
<a name="l00724"></a>00724          parenthesis = <a class="code" href="xml_8h.html#aa530ec72e11a97546295ede1736a1475" title="Get a node attribute by name.">ast_xml_get_attribute</a>(node, <span class="stringliteral">&quot;hasparams&quot;</span>);
<a name="l00725"></a>00725          prnparenthesis = 0;
<a name="l00726"></a>00726          <span class="keywordflow">if</span> (parenthesis) {
<a name="l00727"></a>00727             prnparenthesis = <a class="code" href="strings_8h.html#a387a69b3871ca31061566a73f45d20f4" title="Make sure something is true. Determine if a string containing a boolean value is...">ast_true</a>(parenthesis);
<a name="l00728"></a>00728             <span class="keywordflow">if</span> (!strcasecmp(parenthesis, <span class="stringliteral">&quot;optional&quot;</span>)) {
<a name="l00729"></a>00729                prnparenthesis = 2;
<a name="l00730"></a>00730             }
<a name="l00731"></a>00731             <a class="code" href="xml_8h.html#a8a555ceb9dcd4102c73aad5304ff2f34" title="Free an attribute returned by ast_xml_get_attribute().">ast_xml_free_attr</a>(parenthesis);
<a name="l00732"></a>00732          }
<a name="l00733"></a>00733          argname = <a class="code" href="xml_8h.html#aa530ec72e11a97546295ede1736a1475" title="Get a node attribute by name.">ast_xml_get_attribute</a>(node, <span class="stringliteral">&quot;name&quot;</span>);
<a name="l00734"></a>00734          <span class="keywordflow">if</span> (argname) {
<a name="l00735"></a>00735             paramname = <a class="code" href="xmldoc_8c.html#a6cc1d90ffce561545d1d4d9e6d5a8df1">xmldoc_get_syntax_fun</a>(node, argname, <span class="stringliteral">&quot;argument&quot;</span>, prnparenthesis, prnparenthesis);
<a name="l00736"></a>00736             <a class="code" href="xml_8h.html#a8a555ceb9dcd4102c73aad5304ff2f34" title="Free an attribute returned by ast_xml_get_attribute().">ast_xml_free_attr</a>(argname);
<a name="l00737"></a>00737          } <span class="keywordflow">else</span> {
<a name="l00738"></a>00738             <span class="comment">/* Malformed XML, print **UNKOWN** */</span>
<a name="l00739"></a>00739             paramname = <a class="code" href="astmm_8h.html#a2ef2401ade6b4b773138a82c86c40903">ast_strdup</a>(<span class="stringliteral">&quot;**unknown**&quot;</span>);
<a name="l00740"></a>00740          }
<a name="l00741"></a>00741       } <span class="keywordflow">else</span> {
<a name="l00742"></a>00742          paramnameattr = <a class="code" href="xml_8h.html#aa530ec72e11a97546295ede1736a1475" title="Get a node attribute by name.">ast_xml_get_attribute</a>(node, <span class="stringliteral">&quot;name&quot;</span>);
<a name="l00743"></a>00743          <span class="keywordflow">if</span> (!paramnameattr) {
<a name="l00744"></a>00744             <a class="code" href="logger_8h.html#a93dd824dff97fe84941d6d71b7a3710e" title="Used for sending a log message This is the standard logger function. Probably the...">ast_log</a>(<a class="code" href="logger_8h.html#adf4476a6a4ea6c74231c826e899d7189">LOG_WARNING</a>, <span class="stringliteral">&quot;Malformed XML %s: no %s name\n&quot;</span>, rootname, childname);
<a name="l00745"></a>00745             <span class="keywordflow">if</span> (syntax) {
<a name="l00746"></a>00746                <span class="comment">/* Free already allocated syntax */</span>
<a name="l00747"></a>00747                <a class="code" href="astmm_8h.html#a402072d6789f6ed9e3a81da27504127e">ast_free</a>(syntax);
<a name="l00748"></a>00748             }
<a name="l00749"></a>00749             <span class="comment">/* to give up is ok? */</span>
<a name="l00750"></a>00750             <a class="code" href="astmm_8h.html#aee6f1d27500ac19fa0b842022f987817">ast_asprintf</a>(&amp;syntax, <span class="stringliteral">&quot;%s%s&quot;</span>, (printrootname ? rootname : <span class="stringliteral">&quot;&quot;</span>), (printparenthesis ? <span class="stringliteral">&quot;()&quot;</span> : <span class="stringliteral">&quot;&quot;</span>));
<a name="l00751"></a>00751             <span class="keywordflow">return</span> syntax;
<a name="l00752"></a>00752          }
<a name="l00753"></a>00753          paramname = <a class="code" href="astmm_8h.html#a2ef2401ade6b4b773138a82c86c40903">ast_strdup</a>(paramnameattr);
<a name="l00754"></a>00754          <a class="code" href="xml_8h.html#a8a555ceb9dcd4102c73aad5304ff2f34" title="Free an attribute returned by ast_xml_get_attribute().">ast_xml_free_attr</a>(paramnameattr);
<a name="l00755"></a>00755       }
<a name="l00756"></a>00756 
<a name="l00757"></a>00757       <span class="comment">/* Defaults to &apos;false&apos;. */</span>
<a name="l00758"></a>00758       multiple = 0;
<a name="l00759"></a>00759       <span class="keywordflow">if</span> ((multipletype = <a class="code" href="xml_8h.html#aa530ec72e11a97546295ede1736a1475" title="Get a node attribute by name.">ast_xml_get_attribute</a>(node, <span class="stringliteral">&quot;multiple&quot;</span>))) {
<a name="l00760"></a>00760          <span class="keywordflow">if</span> (<a class="code" href="strings_8h.html#a387a69b3871ca31061566a73f45d20f4" title="Make sure something is true. Determine if a string containing a boolean value is...">ast_true</a>(multipletype)) {
<a name="l00761"></a>00761             multiple = 1;
<a name="l00762"></a>00762          }
<a name="l00763"></a>00763          <a class="code" href="xml_8h.html#a8a555ceb9dcd4102c73aad5304ff2f34" title="Free an attribute returned by ast_xml_get_attribute().">ast_xml_free_attr</a>(multipletype);
<a name="l00764"></a>00764       }
<a name="l00765"></a>00765 
<a name="l00766"></a>00766       required = 0;  <span class="comment">/* Defaults to &apos;false&apos;. */</span>
<a name="l00767"></a>00767       <span class="keywordflow">if</span> ((paramtype = <a class="code" href="xml_8h.html#aa530ec72e11a97546295ede1736a1475" title="Get a node attribute by name.">ast_xml_get_attribute</a>(node, <span class="stringliteral">&quot;required&quot;</span>))) {
<a name="l00768"></a>00768          <span class="keywordflow">if</span> (<a class="code" href="strings_8h.html#a387a69b3871ca31061566a73f45d20f4" title="Make sure something is true. Determine if a string containing a boolean value is...">ast_true</a>(paramtype)) {
<a name="l00769"></a>00769             required = 1;
<a name="l00770"></a>00770          }
<a name="l00771"></a>00771          <a class="code" href="xml_8h.html#a8a555ceb9dcd4102c73aad5304ff2f34" title="Free an attribute returned by ast_xml_get_attribute().">ast_xml_free_attr</a>(paramtype);
<a name="l00772"></a>00772       }
<a name="l00773"></a>00773 
<a name="l00774"></a>00774       <span class="comment">/* build syntax core. */</span>
<a name="l00775"></a>00775 
<a name="l00776"></a>00776       <span class="keywordflow">if</span> (required) {
<a name="l00777"></a>00777          <span class="comment">/* First parameter */</span>
<a name="l00778"></a>00778          <span class="keywordflow">if</span> (!paramcount) {
<a name="l00779"></a>00779             <a class="code" href="xmldoc_8c.html#a9d998b7270794b87e9ace7b566ac4795">xmldoc_reverse_helper</a>(reverse, &amp;<a class="code" href="func__strings_8c.html#af24e73aaf92f3000fda15d285e66df24">len</a>, &amp;syntax, <span class="stringliteral">&quot;%s%s%s%s&quot;</span>, paramname, <a class="code" href="xmldoc_8c.html#a765563bf5349f0baf28c3235e8552787">MP</a>(<span class="stringliteral">&quot;[&quot;</span>), <a class="code" href="xmldoc_8c.html#a765563bf5349f0baf28c3235e8552787">MP</a>(argsep), <a class="code" href="xmldoc_8c.html#a765563bf5349f0baf28c3235e8552787">MP</a>(<span class="stringliteral">&quot;...]&quot;</span>));
<a name="l00780"></a>00780          } <span class="keywordflow">else</span> {
<a name="l00781"></a>00781             <span class="comment">/* Time to close open brackets. */</span>
<a name="l00782"></a>00782             <span class="keywordflow">while</span> (openbrackets &gt; 0) {
<a name="l00783"></a>00783                <a class="code" href="xmldoc_8c.html#a9d998b7270794b87e9ace7b566ac4795">xmldoc_reverse_helper</a>(reverse, &amp;<a class="code" href="func__strings_8c.html#af24e73aaf92f3000fda15d285e66df24">len</a>, &amp;syntax, (reverse ? <span class="stringliteral">&quot;[&quot;</span> : <span class="stringliteral">&quot;]&quot;</span>));
<a name="l00784"></a>00784                openbrackets--;
<a name="l00785"></a>00785             }
<a name="l00786"></a>00786             <span class="keywordflow">if</span> (reverse) {
<a name="l00787"></a>00787                <a class="code" href="xmldoc_8c.html#a9d998b7270794b87e9ace7b566ac4795">xmldoc_reverse_helper</a>(reverse, &amp;<a class="code" href="func__strings_8c.html#af24e73aaf92f3000fda15d285e66df24">len</a>, &amp;syntax, <span class="stringliteral">&quot;%s%s&quot;</span>, paramname, argsep);
<a name="l00788"></a>00788             } <span class="keywordflow">else</span> {
<a name="l00789"></a>00789                <a class="code" href="xmldoc_8c.html#a9d998b7270794b87e9ace7b566ac4795">xmldoc_reverse_helper</a>(reverse, &amp;<a class="code" href="func__strings_8c.html#af24e73aaf92f3000fda15d285e66df24">len</a>, &amp;syntax, <span class="stringliteral">&quot;%s%s&quot;</span>, argsep, paramname);
<a name="l00790"></a>00790             }
<a name="l00791"></a>00791             <a class="code" href="xmldoc_8c.html#a9d998b7270794b87e9ace7b566ac4795">xmldoc_reverse_helper</a>(reverse, &amp;<a class="code" href="func__strings_8c.html#af24e73aaf92f3000fda15d285e66df24">len</a>, &amp;syntax, <span class="stringliteral">&quot;%s%s%s&quot;</span>, <a class="code" href="xmldoc_8c.html#a765563bf5349f0baf28c3235e8552787">MP</a>(<span class="stringliteral">&quot;[&quot;</span>), <a class="code" href="xmldoc_8c.html#a765563bf5349f0baf28c3235e8552787">MP</a>(argsep), <a class="code" href="xmldoc_8c.html#a765563bf5349f0baf28c3235e8552787">MP</a>(<span class="stringliteral">&quot;...]&quot;</span>));
<a name="l00792"></a>00792          }
<a name="l00793"></a>00793       } <span class="keywordflow">else</span> {
<a name="l00794"></a>00794          <span class="comment">/* First parameter */</span>
<a name="l00795"></a>00795          <span class="keywordflow">if</span> (!paramcount) {
<a name="l00796"></a>00796             <a class="code" href="xmldoc_8c.html#a9d998b7270794b87e9ace7b566ac4795">xmldoc_reverse_helper</a>(reverse, &amp;<a class="code" href="func__strings_8c.html#af24e73aaf92f3000fda15d285e66df24">len</a>, &amp;syntax, <span class="stringliteral">&quot;[%s%s%s%s]&quot;</span>, paramname, <a class="code" href="xmldoc_8c.html#a765563bf5349f0baf28c3235e8552787">MP</a>(<span class="stringliteral">&quot;[&quot;</span>), <a class="code" href="xmldoc_8c.html#a765563bf5349f0baf28c3235e8552787">MP</a>(argsep), <a class="code" href="xmldoc_8c.html#a765563bf5349f0baf28c3235e8552787">MP</a>(<span class="stringliteral">&quot;...]&quot;</span>));
<a name="l00797"></a>00797          } <span class="keywordflow">else</span> {
<a name="l00798"></a>00798             <span class="keywordflow">if</span> (<a class="code" href="xmldoc_8c.html#af8737d35be8e0b844d6e8ab55a173ed7">ISLAST</a>(reverse, node)) {
<a name="l00799"></a>00799                <span class="comment">/* This is the last parameter. */</span>
<a name="l00800"></a>00800                <span class="keywordflow">if</span> (reverse) {
<a name="l00801"></a>00801                   <a class="code" href="xmldoc_8c.html#a9d998b7270794b87e9ace7b566ac4795">xmldoc_reverse_helper</a>(reverse, &amp;<a class="code" href="func__strings_8c.html#af24e73aaf92f3000fda15d285e66df24">len</a>, &amp;syntax, <span class="stringliteral">&quot;[%s%s%s%s]%s&quot;</span>, paramname,
<a name="l00802"></a>00802                            <a class="code" href="xmldoc_8c.html#a765563bf5349f0baf28c3235e8552787">MP</a>(<span class="stringliteral">&quot;[&quot;</span>), <a class="code" href="xmldoc_8c.html#a765563bf5349f0baf28c3235e8552787">MP</a>(argsep), <a class="code" href="xmldoc_8c.html#a765563bf5349f0baf28c3235e8552787">MP</a>(<span class="stringliteral">&quot;...]&quot;</span>), argsep);
<a name="l00803"></a>00803                } <span class="keywordflow">else</span> {
<a name="l00804"></a>00804                   <a class="code" href="xmldoc_8c.html#a9d998b7270794b87e9ace7b566ac4795">xmldoc_reverse_helper</a>(reverse, &amp;<a class="code" href="func__strings_8c.html#af24e73aaf92f3000fda15d285e66df24">len</a>, &amp;syntax, <span class="stringliteral">&quot;%s[%s%s%s%s]&quot;</span>, argsep, paramname,
<a name="l00805"></a>00805                            <a class="code" href="xmldoc_8c.html#a765563bf5349f0baf28c3235e8552787">MP</a>(<span class="stringliteral">&quot;[&quot;</span>), <a class="code" href="xmldoc_8c.html#a765563bf5349f0baf28c3235e8552787">MP</a>(argsep), <a class="code" href="xmldoc_8c.html#a765563bf5349f0baf28c3235e8552787">MP</a>(<span class="stringliteral">&quot;...]&quot;</span>));
<a name="l00806"></a>00806                }
<a name="l00807"></a>00807             } <span class="keywordflow">else</span> {
<a name="l00808"></a>00808                <span class="keywordflow">if</span> (reverse) {
<a name="l00809"></a>00809                   <a class="code" href="xmldoc_8c.html#a9d998b7270794b87e9ace7b566ac4795">xmldoc_reverse_helper</a>(reverse, &amp;<a class="code" href="func__strings_8c.html#af24e73aaf92f3000fda15d285e66df24">len</a>, &amp;syntax, <span class="stringliteral">&quot;%s%s%s%s%s]&quot;</span>, paramname, argsep,
<a name="l00810"></a>00810                            <a class="code" href="xmldoc_8c.html#a765563bf5349f0baf28c3235e8552787">MP</a>(<span class="stringliteral">&quot;[&quot;</span>), <a class="code" href="xmldoc_8c.html#a765563bf5349f0baf28c3235e8552787">MP</a>(argsep), <a class="code" href="xmldoc_8c.html#a765563bf5349f0baf28c3235e8552787">MP</a>(<span class="stringliteral">&quot;...]&quot;</span>));
<a name="l00811"></a>00811                } <span class="keywordflow">else</span> {
<a name="l00812"></a>00812                   <a class="code" href="xmldoc_8c.html#a9d998b7270794b87e9ace7b566ac4795">xmldoc_reverse_helper</a>(reverse, &amp;<a class="code" href="func__strings_8c.html#af24e73aaf92f3000fda15d285e66df24">len</a>, &amp;syntax, <span class="stringliteral">&quot;[%s%s%s%s%s&quot;</span>, argsep, paramname,
<a name="l00813"></a>00813                            <a class="code" href="xmldoc_8c.html#a765563bf5349f0baf28c3235e8552787">MP</a>(<span class="stringliteral">&quot;[&quot;</span>), <a class="code" href="xmldoc_8c.html#a765563bf5349f0baf28c3235e8552787">MP</a>(argsep), <a class="code" href="xmldoc_8c.html#a765563bf5349f0baf28c3235e8552787">MP</a>(<span class="stringliteral">&quot;...]&quot;</span>));
<a name="l00814"></a>00814                }
<a name="l00815"></a>00815                openbrackets++;
<a name="l00816"></a>00816             }
<a name="l00817"></a>00817          }
<a name="l00818"></a>00818       }
<a name="l00819"></a>00819       <a class="code" href="astmm_8h.html#a402072d6789f6ed9e3a81da27504127e">ast_free</a>(paramname);
<a name="l00820"></a>00820 
<a name="l00821"></a>00821       paramcount++;
<a name="l00822"></a>00822    }
<a name="l00823"></a>00823 
<a name="l00824"></a>00824    <span class="comment">/* Time to close open brackets. */</span>
<a name="l00825"></a>00825    <span class="keywordflow">while</span> (openbrackets &gt; 0) {
<a name="l00826"></a>00826       <a class="code" href="xmldoc_8c.html#a9d998b7270794b87e9ace7b566ac4795">xmldoc_reverse_helper</a>(reverse, &amp;<a class="code" href="func__strings_8c.html#af24e73aaf92f3000fda15d285e66df24">len</a>, &amp;syntax, (reverse ? <span class="stringliteral">&quot;[&quot;</span> : <span class="stringliteral">&quot;]&quot;</span>));
<a name="l00827"></a>00827       openbrackets--;
<a name="l00828"></a>00828    }
<a name="l00829"></a>00829 
<a name="l00830"></a>00830    <span class="comment">/* close syntax string. */</span>
<a name="l00831"></a>00831    <span class="keywordflow">if</span> (reverse) {
<a name="l00832"></a>00832       <a class="code" href="xmldoc_8c.html#a9d998b7270794b87e9ace7b566ac4795">xmldoc_reverse_helper</a>(reverse, &amp;<a class="code" href="func__strings_8c.html#af24e73aaf92f3000fda15d285e66df24">len</a>, &amp;syntax, <span class="stringliteral">&quot;%s%s&quot;</span>, (printrootname ? rootname : <span class="stringliteral">&quot;&quot;</span>),
<a name="l00833"></a>00833          (printrootname ? (printrootname == 2 ? <span class="stringliteral">&quot;[(&quot;</span> : <span class="stringliteral">&quot;(&quot;</span>) : <span class="stringliteral">&quot;&quot;</span>));
<a name="l00834"></a>00834    } <span class="keywordflow">else</span> {
<a name="l00835"></a>00835       <a class="code" href="xmldoc_8c.html#a9d998b7270794b87e9ace7b566ac4795">xmldoc_reverse_helper</a>(reverse, &amp;<a class="code" href="func__strings_8c.html#af24e73aaf92f3000fda15d285e66df24">len</a>, &amp;syntax, (printrootname ? (printrootname == 2 ? <span class="stringliteral">&quot;)]&quot;</span> : <span class="stringliteral">&quot;)&quot;</span>) : <span class="stringliteral">&quot;&quot;</span>));
<a name="l00836"></a>00836    }
<a name="l00837"></a>00837 
<a name="l00838"></a>00838    <span class="keywordflow">return</span> syntax;
<a name="l00839"></a>00839 <span class="preprocessor">#undef ISLAST</span>
<a name="l00840"></a>00840 <span class="preprocessor"></span><span class="preprocessor">#undef GOTONEXT</span>
<a name="l00841"></a>00841 <span class="preprocessor"></span><span class="preprocessor">#undef MP</span>
<a name="l00842"></a>00842 <span class="preprocessor"></span>}
<a name="l00843"></a>00843 <span class="comment"></span>
<a name="l00844"></a>00844 <span class="comment">/*! \internal</span>
<a name="l00845"></a>00845 <span class="comment"> *  \brief Parse an enumlist inside a &lt;parameter&gt; to generate a COMMAND</span>
<a name="l00846"></a>00846 <span class="comment"> *         syntax.</span>
<a name="l00847"></a>00847 <span class="comment"> *  \param fixnode A pointer to the &lt;enumlist&gt; node.</span>
<a name="l00848"></a>00848 <span class="comment"> *  \retval {&lt;unknown&gt;} on error.</span>
<a name="l00849"></a>00849 <span class="comment"> *  \retval A string inside brackets {} with the enum&apos;s separated by pipes |.</span>
<a name="l00850"></a>00850 <span class="comment"> */</span>
<a name="l00851"></a><a class="code" href="xmldoc_8c.html#a6ce340c0c786d0dac1fb3ab1387db78f">00851</a> <span class="keyword">static</span> <span class="keywordtype">char</span> *<a class="code" href="xmldoc_8c.html#a6ce340c0c786d0dac1fb3ab1387db78f">xmldoc_parse_cmd_enumlist</a>(<span class="keyword">struct</span> ast_xml_node *fixnode)
<a name="l00852"></a>00852 {
<a name="l00853"></a>00853    <span class="keyword">struct </span>ast_xml_node *node = fixnode;
<a name="l00854"></a>00854    <span class="keyword">struct </span><a class="code" href="structast__str.html" title="The descriptor of a dynamic string XXX storage will be optimized later if needed...">ast_str</a> *paramname;
<a name="l00855"></a>00855    <span class="keywordtype">char</span> *enumname, *ret;
<a name="l00856"></a>00856    <span class="keywordtype">int</span> <a class="code" href="devicestate_8c.html#abd2135e6f8a41bc900933b1985d97165">first</a> = 1;
<a name="l00857"></a>00857 
<a name="l00858"></a>00858    paramname = <a class="code" href="strings_8h.html#a8ec37e4acb6ecb20eb6f6edd1141cd76" title="Create a malloc&amp;#39;ed dynamic length string.">ast_str_create</a>(128);
<a name="l00859"></a>00859    <span class="keywordflow">if</span> (!paramname) {
<a name="l00860"></a>00860       <span class="keywordflow">return</span> <a class="code" href="astmm_8h.html#a2ef2401ade6b4b773138a82c86c40903">ast_strdup</a>(<span class="stringliteral">&quot;{&lt;unkown&gt;}&quot;</span>);
<a name="l00861"></a>00861    }
<a name="l00862"></a>00862 
<a name="l00863"></a>00863    <a class="code" href="strings_8h.html#a85cd5a8ef499e39d22b4bfeb8b9a64f7" title="Append to a thread local dynamic string.">ast_str_append</a>(&amp;paramname, 0, <span class="stringliteral">&quot;{&quot;</span>);
<a name="l00864"></a>00864 
<a name="l00865"></a>00865    <span class="keywordflow">for</span> (node = <a class="code" href="xml_8h.html#a6064a4b3e299bb92aa8c8c7c1b363527" title="Get the node&amp;#39;s children.">ast_xml_node_get_children</a>(node); node; node = <a class="code" href="xml_8h.html#aa7d34402682c9bc1dfb9aea971f9eba7" title="Get the next node in the same level.">ast_xml_node_get_next</a>(node)) {
<a name="l00866"></a>00866       <span class="keywordflow">if</span> (strcasecmp(<a class="code" href="xml_8h.html#a02cd60b8b2d5d96e78c858429b1b1d11" title="Get the name of a node.">ast_xml_node_get_name</a>(node), <span class="stringliteral">&quot;enum&quot;</span>)) {
<a name="l00867"></a>00867          <span class="keywordflow">continue</span>;
<a name="l00868"></a>00868       }
<a name="l00869"></a>00869 
<a name="l00870"></a>00870       enumname = <a class="code" href="xmldoc_8c.html#a715470224f007f05ca6940fee40132ef">xmldoc_get_syntax_cmd</a>(node, <span class="stringliteral">&quot;&quot;</span>, 0);
<a name="l00871"></a>00871       <span class="keywordflow">if</span> (!enumname) {
<a name="l00872"></a>00872          <span class="keywordflow">continue</span>;
<a name="l00873"></a>00873       }
<a name="l00874"></a>00874       <span class="keywordflow">if</span> (!first) {
<a name="l00875"></a>00875          <a class="code" href="strings_8h.html#a85cd5a8ef499e39d22b4bfeb8b9a64f7" title="Append to a thread local dynamic string.">ast_str_append</a>(&amp;paramname, 0, <span class="stringliteral">&quot;|&quot;</span>);
<a name="l00876"></a>00876       }
<a name="l00877"></a>00877       <a class="code" href="strings_8h.html#a85cd5a8ef499e39d22b4bfeb8b9a64f7" title="Append to a thread local dynamic string.">ast_str_append</a>(&amp;paramname, 0, <span class="stringliteral">&quot;%s&quot;</span>, enumname);
<a name="l00878"></a>00878       first = 0;
<a name="l00879"></a>00879       <a class="code" href="astmm_8h.html#a402072d6789f6ed9e3a81da27504127e">ast_free</a>(enumname);
<a name="l00880"></a>00880    }
<a name="l00881"></a>00881 
<a name="l00882"></a>00882    <a class="code" href="strings_8h.html#a85cd5a8ef499e39d22b4bfeb8b9a64f7" title="Append to a thread local dynamic string.">ast_str_append</a>(&amp;paramname, 0, <span class="stringliteral">&quot;}&quot;</span>);
<a name="l00883"></a>00883 
<a name="l00884"></a>00884    ret = <a class="code" href="astmm_8h.html#a2ef2401ade6b4b773138a82c86c40903">ast_strdup</a>(<a class="code" href="strings_8h.html#a053bdfc229997a75f112bdd7b995e00b" title="Returns the string buffer within the ast_str buf.">ast_str_buffer</a>(paramname));
<a name="l00885"></a>00885    <a class="code" href="astmm_8h.html#a402072d6789f6ed9e3a81da27504127e">ast_free</a>(paramname);
<a name="l00886"></a>00886 
<a name="l00887"></a>00887    <span class="keywordflow">return</span> ret;
<a name="l00888"></a>00888 }
<a name="l00889"></a>00889 <span class="comment"></span>
<a name="l00890"></a>00890 <span class="comment">/*! \internal</span>
<a name="l00891"></a>00891 <span class="comment"> *  \brief Generate a syntax of COMMAND type.</span>
<a name="l00892"></a>00892 <span class="comment"> *  \param fixnode The &lt;syntax&gt; node pointer.</span>
<a name="l00893"></a>00893 <span class="comment"> *  \param name The name of the &apos;command&apos;.</span>
<a name="l00894"></a>00894 <span class="comment"> *  \param printname Print the name of the command before the paramters?</span>
<a name="l00895"></a>00895 <span class="comment"> *  \retval On error, return just &apos;name&apos;.</span>
<a name="l00896"></a>00896 <span class="comment"> *  \retval On success return the generated syntax.</span>
<a name="l00897"></a>00897 <span class="comment"> */</span>
<a name="l00898"></a><a class="code" href="xmldoc_8c.html#a715470224f007f05ca6940fee40132ef">00898</a> <span class="keyword">static</span> <span class="keywordtype">char</span> *<a class="code" href="xmldoc_8c.html#a715470224f007f05ca6940fee40132ef">xmldoc_get_syntax_cmd</a>(<span class="keyword">struct</span> ast_xml_node *fixnode, <span class="keyword">const</span> <span class="keywordtype">char</span> *<a class="code" href="cdr__adaptive__odbc_8c.html#a5ac083a645d964373f022d03df4849c8">name</a>, <span class="keywordtype">int</span> printname)
<a name="l00899"></a>00899 {
<a name="l00900"></a>00900    <span class="keyword">struct </span><a class="code" href="structast__str.html" title="The descriptor of a dynamic string XXX storage will be optimized later if needed...">ast_str</a> *syntax;
<a name="l00901"></a>00901    <span class="keyword">struct </span>ast_xml_node *tmpnode, *node = fixnode;
<a name="l00902"></a>00902    <span class="keywordtype">char</span> *ret, *paramname;
<a name="l00903"></a>00903    <span class="keyword">const</span> <span class="keywordtype">char</span> *paramtype, *attrname, *literal;
<a name="l00904"></a>00904    <span class="keywordtype">int</span> required, isenum, <a class="code" href="devicestate_8c.html#abd2135e6f8a41bc900933b1985d97165">first</a> = 1, isliteral;
<a name="l00905"></a>00905 
<a name="l00906"></a>00906    syntax = <a class="code" href="strings_8h.html#a8ec37e4acb6ecb20eb6f6edd1141cd76" title="Create a malloc&amp;#39;ed dynamic length string.">ast_str_create</a>(128);
<a name="l00907"></a>00907    <span class="keywordflow">if</span> (!syntax) {
<a name="l00908"></a>00908       <span class="comment">/* at least try to return something... */</span>
<a name="l00909"></a>00909       <span class="keywordflow">return</span> <a class="code" href="astmm_8h.html#a2ef2401ade6b4b773138a82c86c40903">ast_strdup</a>(name);
<a name="l00910"></a>00910    }
<a name="l00911"></a>00911 
<a name="l00912"></a>00912    <span class="comment">/* append name to output string. */</span>
<a name="l00913"></a>00913    <span class="keywordflow">if</span> (printname) {
<a name="l00914"></a>00914       <a class="code" href="strings_8h.html#a85cd5a8ef499e39d22b4bfeb8b9a64f7" title="Append to a thread local dynamic string.">ast_str_append</a>(&amp;syntax, 0, <span class="stringliteral">&quot;%s&quot;</span>, name);
<a name="l00915"></a>00915       first = 0;
<a name="l00916"></a>00916    }
<a name="l00917"></a>00917 
<a name="l00918"></a>00918    <span class="keywordflow">for</span> (node = <a class="code" href="xml_8h.html#a6064a4b3e299bb92aa8c8c7c1b363527" title="Get the node&amp;#39;s children.">ast_xml_node_get_children</a>(node); node; node = <a class="code" href="xml_8h.html#aa7d34402682c9bc1dfb9aea971f9eba7" title="Get the next node in the same level.">ast_xml_node_get_next</a>(node)) {
<a name="l00919"></a>00919       <span class="keywordflow">if</span> (strcasecmp(<a class="code" href="xml_8h.html#a02cd60b8b2d5d96e78c858429b1b1d11" title="Get the name of a node.">ast_xml_node_get_name</a>(node), <span class="stringliteral">&quot;parameter&quot;</span>)) {
<a name="l00920"></a>00920          <span class="keywordflow">continue</span>;
<a name="l00921"></a>00921       }
<a name="l00922"></a>00922 
<a name="l00923"></a>00923       <span class="keywordflow">if</span> (<a class="code" href="xmldoc_8c.html#ab9142298d52f52d3e9bf70ed451d6fdd">xmldoc_has_inside</a>(node, <span class="stringliteral">&quot;parameter&quot;</span>)) {
<a name="l00924"></a>00924          <span class="comment">/* is this a recursive parameter. */</span>
<a name="l00925"></a>00925          paramname = <a class="code" href="xmldoc_8c.html#a715470224f007f05ca6940fee40132ef">xmldoc_get_syntax_cmd</a>(node, <span class="stringliteral">&quot;&quot;</span>, 0);
<a name="l00926"></a>00926          isenum = 1;
<a name="l00927"></a>00927       } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (!<a class="code" href="xmldoc_8c.html#ab9142298d52f52d3e9bf70ed451d6fdd">xmldoc_has_inside</a>(node, <span class="stringliteral">&quot;enumlist&quot;</span>)) {
<a name="l00928"></a>00928          <span class="comment">/* this is a simple parameter. */</span>
<a name="l00929"></a>00929          attrname = <a class="code" href="xml_8h.html#aa530ec72e11a97546295ede1736a1475" title="Get a node attribute by name.">ast_xml_get_attribute</a>(node, <span class="stringliteral">&quot;name&quot;</span>);
<a name="l00930"></a>00930          <span class="keywordflow">if</span> (!attrname) {
<a name="l00931"></a>00931             <span class="comment">/* ignore this bogus parameter and continue. */</span>
<a name="l00932"></a>00932             <span class="keywordflow">continue</span>;
<a name="l00933"></a>00933          }
<a name="l00934"></a>00934          paramname = <a class="code" href="astmm_8h.html#a2ef2401ade6b4b773138a82c86c40903">ast_strdup</a>(attrname);
<a name="l00935"></a>00935          <a class="code" href="xml_8h.html#a8a555ceb9dcd4102c73aad5304ff2f34" title="Free an attribute returned by ast_xml_get_attribute().">ast_xml_free_attr</a>(attrname);
<a name="l00936"></a>00936          isenum = 0;
<a name="l00937"></a>00937       } <span class="keywordflow">else</span> {
<a name="l00938"></a>00938          <span class="comment">/* parse enumlist (note that this is a special enumlist</span>
<a name="l00939"></a>00939 <span class="comment">         that is used to describe a syntax like {&lt;param1&gt;|&lt;param2&gt;|...} */</span>
<a name="l00940"></a>00940          <span class="keywordflow">for</span> (tmpnode = <a class="code" href="xml_8h.html#a6064a4b3e299bb92aa8c8c7c1b363527" title="Get the node&amp;#39;s children.">ast_xml_node_get_children</a>(node); tmpnode; tmpnode = <a class="code" href="xml_8h.html#aa7d34402682c9bc1dfb9aea971f9eba7" title="Get the next node in the same level.">ast_xml_node_get_next</a>(tmpnode)) {
<a name="l00941"></a>00941             <span class="keywordflow">if</span> (!strcasecmp(<a class="code" href="xml_8h.html#a02cd60b8b2d5d96e78c858429b1b1d11" title="Get the name of a node.">ast_xml_node_get_name</a>(tmpnode), <span class="stringliteral">&quot;enumlist&quot;</span>)) {
<a name="l00942"></a>00942                <span class="keywordflow">break</span>;
<a name="l00943"></a>00943             }
<a name="l00944"></a>00944          }
<a name="l00945"></a>00945          paramname = <a class="code" href="xmldoc_8c.html#a6ce340c0c786d0dac1fb3ab1387db78f">xmldoc_parse_cmd_enumlist</a>(tmpnode);
<a name="l00946"></a>00946          isenum = 1;
<a name="l00947"></a>00947       }
<a name="l00948"></a>00948 
<a name="l00949"></a>00949       <span class="comment">/* Is this parameter required? */</span>
<a name="l00950"></a>00950       required = 0;
<a name="l00951"></a>00951       paramtype = <a class="code" href="xml_8h.html#aa530ec72e11a97546295ede1736a1475" title="Get a node attribute by name.">ast_xml_get_attribute</a>(node, <span class="stringliteral">&quot;required&quot;</span>);
<a name="l00952"></a>00952       <span class="keywordflow">if</span> (paramtype) {
<a name="l00953"></a>00953          required = <a class="code" href="strings_8h.html#a387a69b3871ca31061566a73f45d20f4" title="Make sure something is true. Determine if a string containing a boolean value is...">ast_true</a>(paramtype);
<a name="l00954"></a>00954          <a class="code" href="xml_8h.html#a8a555ceb9dcd4102c73aad5304ff2f34" title="Free an attribute returned by ast_xml_get_attribute().">ast_xml_free_attr</a>(paramtype);
<a name="l00955"></a>00955       }
<a name="l00956"></a>00956 
<a name="l00957"></a>00957       <span class="comment">/* Is this a replaceable value or a fixed parameter value? */</span>
<a name="l00958"></a>00958       isliteral = 0;
<a name="l00959"></a>00959       literal = <a class="code" href="xml_8h.html#aa530ec72e11a97546295ede1736a1475" title="Get a node attribute by name.">ast_xml_get_attribute</a>(node, <span class="stringliteral">&quot;literal&quot;</span>);
<a name="l00960"></a>00960       <span class="keywordflow">if</span> (literal) {
<a name="l00961"></a>00961          isliteral = <a class="code" href="strings_8h.html#a387a69b3871ca31061566a73f45d20f4" title="Make sure something is true. Determine if a string containing a boolean value is...">ast_true</a>(literal);
<a name="l00962"></a>00962          <a class="code" href="xml_8h.html#a8a555ceb9dcd4102c73aad5304ff2f34" title="Free an attribute returned by ast_xml_get_attribute().">ast_xml_free_attr</a>(literal);
<a name="l00963"></a>00963       }
<a name="l00964"></a>00964 
<a name="l00965"></a>00965       <span class="comment">/* if required=&quot;false&quot; print with [...].</span>
<a name="l00966"></a>00966 <span class="comment">       * if literal=&quot;true&quot; or is enum print without &lt;..&gt;.</span>
<a name="l00967"></a>00967 <span class="comment">       * if not first print a space at the beginning.</span>
<a name="l00968"></a>00968 <span class="comment">       */</span>
<a name="l00969"></a>00969       <a class="code" href="strings_8h.html#a85cd5a8ef499e39d22b4bfeb8b9a64f7" title="Append to a thread local dynamic string.">ast_str_append</a>(&amp;syntax, 0, <span class="stringliteral">&quot;%s%s%s%s%s%s&quot;</span>,
<a name="l00970"></a>00970             (first ? <span class="stringliteral">&quot;&quot;</span> : <span class="stringliteral">&quot; &quot;</span>),
<a name="l00971"></a>00971             (required ? <span class="stringliteral">&quot;&quot;</span> : <span class="stringliteral">&quot;[&quot;</span>),
<a name="l00972"></a>00972             (isenum || isliteral ? <span class="stringliteral">&quot;&quot;</span> : <span class="stringliteral">&quot;&lt;&quot;</span>),
<a name="l00973"></a>00973             paramname,
<a name="l00974"></a>00974             (isenum || isliteral ? <span class="stringliteral">&quot;&quot;</span> : <span class="stringliteral">&quot;&gt;&quot;</span>),
<a name="l00975"></a>00975             (required ? <span class="stringliteral">&quot;&quot;</span> : <span class="stringliteral">&quot;]&quot;</span>));
<a name="l00976"></a>00976       first = 0;
<a name="l00977"></a>00977       <a class="code" href="astmm_8h.html#a402072d6789f6ed9e3a81da27504127e">ast_free</a>(paramname);
<a name="l00978"></a>00978    }
<a name="l00979"></a>00979 
<a name="l00980"></a>00980    <span class="comment">/* return a common string. */</span>
<a name="l00981"></a>00981    ret = <a class="code" href="astmm_8h.html#a2ef2401ade6b4b773138a82c86c40903">ast_strdup</a>(<a class="code" href="strings_8h.html#a053bdfc229997a75f112bdd7b995e00b" title="Returns the string buffer within the ast_str buf.">ast_str_buffer</a>(syntax));
<a name="l00982"></a>00982    <a class="code" href="astmm_8h.html#a402072d6789f6ed9e3a81da27504127e">ast_free</a>(syntax);
<a name="l00983"></a>00983 
<a name="l00984"></a>00984    <span class="keywordflow">return</span> ret;
<a name="l00985"></a>00985 }
<a name="l00986"></a>00986 <span class="comment"></span>
<a name="l00987"></a>00987 <span class="comment">/*! \brief Types of syntax that we are able to generate. */</span>
<a name="l00988"></a><a class="code" href="xmldoc_8c.html#a595475242aec01e7323361b70fb5f567">00988</a> <span class="keyword">enum</span> <a class="code" href="xmldoc_8c.html#a595475242aec01e7323361b70fb5f567" title="Types of syntax that we are able to generate.">syntaxtype</a> {
<a name="l00989"></a><a class="code" href="xmldoc_8c.html#a595475242aec01e7323361b70fb5f567a2f5c1738e74ee48467e4c16ba168e163">00989</a>    <a class="code" href="xmldoc_8c.html#a595475242aec01e7323361b70fb5f567a2f5c1738e74ee48467e4c16ba168e163">FUNCTION_SYNTAX</a>,
<a name="l00990"></a><a class="code" href="xmldoc_8c.html#a595475242aec01e7323361b70fb5f567adf7a08dcf0078f6bb2534f72fcbf6c83">00990</a>    <a class="code" href="xmldoc_8c.html#a595475242aec01e7323361b70fb5f567adf7a08dcf0078f6bb2534f72fcbf6c83">COMMAND_SYNTAX</a>
<a name="l00991"></a>00991 };
<a name="l00992"></a>00992 <span class="comment"></span>
<a name="l00993"></a>00993 <span class="comment">/*! \brief Mapping between type of node and type of syntax to generate. */</span>
<a name="l00994"></a><a class="code" href="structstrsyntaxtype.html">00994</a> <span class="keyword">struct </span><a class="code" href="structstrsyntaxtype.html" title="Mapping between type of node and type of syntax to generate.">strsyntaxtype</a> {
<a name="l00995"></a><a class="code" href="structstrsyntaxtype.html#a763fd8db6bba8fbbbc113ca0d61c47c2">00995</a>    <span class="keyword">const</span> <span class="keywordtype">char</span> *<a class="code" href="evt_8c.html#a69e2889a94aeb9ac881abb82d3c22116">type</a>;
<a name="l00996"></a><a class="code" href="structstrsyntaxtype.html#a2802a12bb8c911d1da9522006b28f1ed">00996</a>    <span class="keyword">enum</span> <a class="code" href="xmldoc_8c.html#a595475242aec01e7323361b70fb5f567" title="Types of syntax that we are able to generate.">syntaxtype</a> <a class="code" href="xmldoc_8c.html#ab4149062a8a193cf35aaae215226840b" title="Mapping between type of node and type of syntax to generate.">stxtype</a>;
<a name="l00997"></a>00997 } <a class="code" href="xmldoc_8c.html#ab4149062a8a193cf35aaae215226840b" title="Mapping between type of node and type of syntax to generate.">stxtype</a>[] = {
<a name="l00998"></a>00998    { <span class="stringliteral">&quot;function&quot;</span>,     <a class="code" href="xmldoc_8c.html#a595475242aec01e7323361b70fb5f567a2f5c1738e74ee48467e4c16ba168e163">FUNCTION_SYNTAX</a>   },
<a name="l00999"></a>00999    { <span class="stringliteral">&quot;application&quot;</span>,  <a class="code" href="xmldoc_8c.html#a595475242aec01e7323361b70fb5f567a2f5c1738e74ee48467e4c16ba168e163">FUNCTION_SYNTAX</a>   },
<a name="l01000"></a>01000    { <span class="stringliteral">&quot;agi&quot;</span>,    <a class="code" href="xmldoc_8c.html#a595475242aec01e7323361b70fb5f567adf7a08dcf0078f6bb2534f72fcbf6c83">COMMAND_SYNTAX</a> }
<a name="l01001"></a>01001 };
<a name="l01002"></a>01002 <span class="comment"></span>
<a name="l01003"></a>01003 <span class="comment">/*! \internal</span>
<a name="l01004"></a>01004 <span class="comment"> *  \brief Get syntax type based on type of node.</span>
<a name="l01005"></a>01005 <span class="comment"> *  \param type Type of node.</span>
<a name="l01006"></a>01006 <span class="comment"> *  \retval The type of syntax to generate based on the type of node.</span>
<a name="l01007"></a>01007 <span class="comment"> */</span>
<a name="l01008"></a><a class="code" href="xmldoc_8c.html#a5b51a11f16e9d07806af135522e258be">01008</a> <span class="keyword">static</span> <span class="keyword">enum</span> <a class="code" href="xmldoc_8c.html#a595475242aec01e7323361b70fb5f567" title="Types of syntax that we are able to generate.">syntaxtype</a> <a class="code" href="xmldoc_8c.html#a5b51a11f16e9d07806af135522e258be">xmldoc_get_syntax_type</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> *<a class="code" href="evt_8c.html#a69e2889a94aeb9ac881abb82d3c22116">type</a>)
<a name="l01009"></a>01009 {
<a name="l01010"></a>01010    <span class="keywordtype">int</span> i;
<a name="l01011"></a>01011    <span class="keywordflow">for</span> (i=0; i &lt; <a class="code" href="isdn__lib_8c.html#ab9129b977a587b50ea801daac75e178f">ARRAY_LEN</a>(<a class="code" href="xmldoc_8c.html#ab4149062a8a193cf35aaae215226840b" title="Mapping between type of node and type of syntax to generate.">stxtype</a>); i++) {
<a name="l01012"></a>01012       <span class="keywordflow">if</span> (!strcasecmp(<a class="code" href="xmldoc_8c.html#ab4149062a8a193cf35aaae215226840b" title="Mapping between type of node and type of syntax to generate.">stxtype</a>[i].type, type)) {
<a name="l01013"></a>01013          <span class="keywordflow">return</span> <a class="code" href="xmldoc_8c.html#ab4149062a8a193cf35aaae215226840b" title="Mapping between type of node and type of syntax to generate.">stxtype</a>[i].<a class="code" href="structstrsyntaxtype.html#a2802a12bb8c911d1da9522006b28f1ed">stxtype</a>;
<a name="l01014"></a>01014       }
<a name="l01015"></a>01015    }
<a name="l01016"></a>01016 
<a name="l01017"></a>01017    <span class="keywordflow">return</span> <a class="code" href="xmldoc_8c.html#a595475242aec01e7323361b70fb5f567a2f5c1738e74ee48467e4c16ba168e163">FUNCTION_SYNTAX</a>;
<a name="l01018"></a>01018 }
<a name="l01019"></a>01019 
<a name="l01020"></a><a class="code" href="xmldoc_8c.html#a54a5b2e3ff1b6b6f06d9bab70e70c924">01020</a> <span class="keywordtype">char</span> *<a class="code" href="xmldoc_8h.html#a54a5b2e3ff1b6b6f06d9bab70e70c924" title="Get the syntax for a specified application or function.">ast_xmldoc_build_syntax</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> *<a class="code" href="evt_8c.html#a69e2889a94aeb9ac881abb82d3c22116">type</a>, <span class="keyword">const</span> <span class="keywordtype">char</span> *<a class="code" href="cdr__adaptive__odbc_8c.html#a5ac083a645d964373f022d03df4849c8">name</a>)
<a name="l01021"></a>01021 {
<a name="l01022"></a>01022    <span class="keyword">struct </span>ast_xml_node *node;
<a name="l01023"></a>01023    <span class="keywordtype">char</span> *syntax = NULL;
<a name="l01024"></a>01024 
<a name="l01025"></a>01025    node = <a class="code" href="xmldoc_8c.html#af1f439077def997dc752361c8dbdcb12">xmldoc_get_node</a>(type, name, documentation_language);
<a name="l01026"></a>01026    <span class="keywordflow">if</span> (!node) {
<a name="l01027"></a>01027       <span class="keywordflow">return</span> NULL;
<a name="l01028"></a>01028    }
<a name="l01029"></a>01029 
<a name="l01030"></a>01030    <span class="keywordflow">for</span> (node = <a class="code" href="xml_8h.html#a6064a4b3e299bb92aa8c8c7c1b363527" title="Get the node&amp;#39;s children.">ast_xml_node_get_children</a>(node); node; node = <a class="code" href="xml_8h.html#aa7d34402682c9bc1dfb9aea971f9eba7" title="Get the next node in the same level.">ast_xml_node_get_next</a>(node)) {
<a name="l01031"></a>01031       <span class="keywordflow">if</span> (!strcasecmp(<a class="code" href="xml_8h.html#a02cd60b8b2d5d96e78c858429b1b1d11" title="Get the name of a node.">ast_xml_node_get_name</a>(node), <span class="stringliteral">&quot;syntax&quot;</span>)) {
<a name="l01032"></a>01032          <span class="keywordflow">break</span>;
<a name="l01033"></a>01033       }
<a name="l01034"></a>01034    }
<a name="l01035"></a>01035 
<a name="l01036"></a>01036    <span class="keywordflow">if</span> (node) {
<a name="l01037"></a>01037       <span class="keywordflow">if</span> (<a class="code" href="xmldoc_8c.html#a5b51a11f16e9d07806af135522e258be">xmldoc_get_syntax_type</a>(type) == <a class="code" href="xmldoc_8c.html#a595475242aec01e7323361b70fb5f567a2f5c1738e74ee48467e4c16ba168e163">FUNCTION_SYNTAX</a>) {
<a name="l01038"></a>01038          syntax = <a class="code" href="xmldoc_8c.html#a6cc1d90ffce561545d1d4d9e6d5a8df1">xmldoc_get_syntax_fun</a>(node, name, <span class="stringliteral">&quot;parameter&quot;</span>, 1, 1);
<a name="l01039"></a>01039       } <span class="keywordflow">else</span> {
<a name="l01040"></a>01040          syntax = <a class="code" href="xmldoc_8c.html#a715470224f007f05ca6940fee40132ef">xmldoc_get_syntax_cmd</a>(node, name, 1);
<a name="l01041"></a>01041       }
<a name="l01042"></a>01042    }
<a name="l01043"></a>01043    <span class="keywordflow">return</span> syntax;
<a name="l01044"></a>01044 }
<a name="l01045"></a>01045 <span class="comment"></span>
<a name="l01046"></a>01046 <span class="comment">/*! \internal</span>
<a name="l01047"></a>01047 <span class="comment"> *  \brief Parse a &lt;para&gt; element.</span>
<a name="l01048"></a>01048 <span class="comment"> *  \param node The &lt;para&gt; element pointer.</span>
<a name="l01049"></a>01049 <span class="comment"> *  \param tabs Added this string before the content of the &lt;para&gt; element.</span>
<a name="l01050"></a>01050 <span class="comment"> *  \param posttabs Added this string after the content of the &lt;para&gt; element.</span>
<a name="l01051"></a>01051 <span class="comment"> *  \param buffer This must be an already allocated ast_str. It will be used</span>
<a name="l01052"></a>01052 <span class="comment"> *         to store the result (if already has something it will be appended to the current</span>
<a name="l01053"></a>01053 <span class="comment"> *         string).</span>
<a name="l01054"></a>01054 <span class="comment"> *  \retval 1 If &apos;node&apos; is a named &apos;para&apos;.</span>
<a name="l01055"></a>01055 <span class="comment"> *  \retval 2 If data is appended in buffer.</span>
<a name="l01056"></a>01056 <span class="comment"> *  \retval 0 on error.</span>
<a name="l01057"></a>01057 <span class="comment"> */</span>
<a name="l01058"></a><a class="code" href="xmldoc_8c.html#ae919d164af8a8f3e6cfbff1238a647cd">01058</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="xmldoc_8c.html#ae919d164af8a8f3e6cfbff1238a647cd">xmldoc_parse_para</a>(<span class="keyword">struct</span> ast_xml_node *node, <span class="keyword">const</span> <span class="keywordtype">char</span> *tabs, <span class="keyword">const</span> <span class="keywordtype">char</span> *posttabs, <span class="keyword">struct</span> <a class="code" href="structast__str.html" title="The descriptor of a dynamic string XXX storage will be optimized later if needed...">ast_str</a> **buffer)
<a name="l01059"></a>01059 {
<a name="l01060"></a>01060    <span class="keyword">const</span> <span class="keywordtype">char</span> *tmptext;
<a name="l01061"></a>01061    <span class="keyword">struct </span>ast_xml_node *tmp;
<a name="l01062"></a>01062    <span class="keywordtype">int</span> ret = 0;
<a name="l01063"></a>01063    <span class="keyword">struct </span><a class="code" href="structast__str.html" title="The descriptor of a dynamic string XXX storage will be optimized later if needed...">ast_str</a> *tmpstr;
<a name="l01064"></a>01064 
<a name="l01065"></a>01065    <span class="keywordflow">if</span> (!node || !<a class="code" href="xml_8h.html#a6064a4b3e299bb92aa8c8c7c1b363527" title="Get the node&amp;#39;s children.">ast_xml_node_get_children</a>(node)) {
<a name="l01066"></a>01066       <span class="keywordflow">return</span> ret;
<a name="l01067"></a>01067    }
<a name="l01068"></a>01068 
<a name="l01069"></a>01069    <span class="keywordflow">if</span> (strcasecmp(<a class="code" href="xml_8h.html#a02cd60b8b2d5d96e78c858429b1b1d11" title="Get the name of a node.">ast_xml_node_get_name</a>(node), <span class="stringliteral">&quot;para&quot;</span>)) {
<a name="l01070"></a>01070       <span class="keywordflow">return</span> ret;
<a name="l01071"></a>01071    }
<a name="l01072"></a>01072 
<a name="l01073"></a>01073    <a class="code" href="strings_8h.html#a85cd5a8ef499e39d22b4bfeb8b9a64f7" title="Append to a thread local dynamic string.">ast_str_append</a>(buffer, 0, <span class="stringliteral">&quot;%s&quot;</span>, tabs);
<a name="l01074"></a>01074 
<a name="l01075"></a>01075    ret = 1;
<a name="l01076"></a>01076 
<a name="l01077"></a>01077    <span class="keywordflow">for</span> (tmp = <a class="code" href="xml_8h.html#a6064a4b3e299bb92aa8c8c7c1b363527" title="Get the node&amp;#39;s children.">ast_xml_node_get_children</a>(node); tmp; tmp = <a class="code" href="xml_8h.html#aa7d34402682c9bc1dfb9aea971f9eba7" title="Get the next node in the same level.">ast_xml_node_get_next</a>(tmp)) {
<a name="l01078"></a>01078       <span class="comment">/* Get the text inside the &lt;para&gt; element and append it to buffer. */</span>
<a name="l01079"></a>01079       tmptext = <a class="code" href="xml_8h.html#ad113291cd96631f7b440d82fbc33dd13" title="Get an element content string.">ast_xml_get_text</a>(tmp);
<a name="l01080"></a>01080       <span class="keywordflow">if</span> (tmptext) {
<a name="l01081"></a>01081          <span class="comment">/* Strip \n etc. */</span>
<a name="l01082"></a>01082          <a class="code" href="xmldoc_8c.html#a9b126a6b2606df7e517d382fb9565295">xmldoc_string_cleanup</a>(tmptext, &amp;tmpstr, 0);
<a name="l01083"></a>01083          <a class="code" href="xml_8h.html#ae428c2b44d463e2fe692360f4d530cdb" title="Free a content element that was returned by ast_xml_get_text().">ast_xml_free_text</a>(tmptext);
<a name="l01084"></a>01084          <span class="keywordflow">if</span> (tmpstr) {
<a name="l01085"></a>01085             <span class="keywordflow">if</span> (strcasecmp(<a class="code" href="xml_8h.html#a02cd60b8b2d5d96e78c858429b1b1d11" title="Get the name of a node.">ast_xml_node_get_name</a>(tmp), <span class="stringliteral">&quot;text&quot;</span>)) {
<a name="l01086"></a>01086                <a class="code" href="strings_8h.html#a85cd5a8ef499e39d22b4bfeb8b9a64f7" title="Append to a thread local dynamic string.">ast_str_append</a>(buffer, 0, <span class="stringliteral">&quot;&lt;%s&gt;%s&lt;/%s&gt;&quot;</span>, <a class="code" href="xml_8h.html#a02cd60b8b2d5d96e78c858429b1b1d11" title="Get the name of a node.">ast_xml_node_get_name</a>(tmp),
<a name="l01087"></a>01087                      <a class="code" href="strings_8h.html#a053bdfc229997a75f112bdd7b995e00b" title="Returns the string buffer within the ast_str buf.">ast_str_buffer</a>(tmpstr), <a class="code" href="xml_8h.html#a02cd60b8b2d5d96e78c858429b1b1d11" title="Get the name of a node.">ast_xml_node_get_name</a>(tmp));
<a name="l01088"></a>01088             } <span class="keywordflow">else</span> {
<a name="l01089"></a>01089                <a class="code" href="strings_8h.html#a85cd5a8ef499e39d22b4bfeb8b9a64f7" title="Append to a thread local dynamic string.">ast_str_append</a>(buffer, 0, <span class="stringliteral">&quot;%s&quot;</span>, <a class="code" href="strings_8h.html#a053bdfc229997a75f112bdd7b995e00b" title="Returns the string buffer within the ast_str buf.">ast_str_buffer</a>(tmpstr));
<a name="l01090"></a>01090             }
<a name="l01091"></a>01091             <a class="code" href="astmm_8h.html#a402072d6789f6ed9e3a81da27504127e">ast_free</a>(tmpstr);
<a name="l01092"></a>01092             ret = 2;
<a name="l01093"></a>01093          }
<a name="l01094"></a>01094       }
<a name="l01095"></a>01095    }
<a name="l01096"></a>01096 
<a name="l01097"></a>01097    <a class="code" href="strings_8h.html#a85cd5a8ef499e39d22b4bfeb8b9a64f7" title="Append to a thread local dynamic string.">ast_str_append</a>(buffer, 0, <span class="stringliteral">&quot;%s&quot;</span>, posttabs);
<a name="l01098"></a>01098 
<a name="l01099"></a>01099    <span class="keywordflow">return</span> ret;
<a name="l01100"></a>01100 }
<a name="l01101"></a>01101 <span class="comment"></span>
<a name="l01102"></a>01102 <span class="comment">/*! \internal</span>
<a name="l01103"></a>01103 <span class="comment"> *  \brief Parse special elements defined in &apos;struct special_tags&apos; special elements must have a &lt;para&gt; element inside them.</span>
<a name="l01104"></a>01104 <span class="comment"> *  \param fixnode special tag node pointer.</span>
<a name="l01105"></a>01105 <span class="comment"> *  \param tabs put tabs before printing the node content.</span>
<a name="l01106"></a>01106 <span class="comment"> *  \param posttabs put posttabs after printing node content.</span>
<a name="l01107"></a>01107 <span class="comment"> *  \param buffer Output buffer, the special tags will be appended here.</span>
<a name="l01108"></a>01108 <span class="comment"> *  \retval 0 if no special element is parsed.</span>
<a name="l01109"></a>01109 <span class="comment"> *  \retval 1 if a special element is parsed (data is appended to buffer).</span>
<a name="l01110"></a>01110 <span class="comment"> *  \retval 2 if a special element is parsed and also a &lt;para&gt; element is parsed inside the specialtag.</span>
<a name="l01111"></a>01111 <span class="comment"> */</span>
<a name="l01112"></a><a class="code" href="xmldoc_8c.html#a494124315bb990544dc492592446352c">01112</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="xmldoc_8c.html#a494124315bb990544dc492592446352c">xmldoc_parse_specialtags</a>(<span class="keyword">struct</span> ast_xml_node *fixnode, <span class="keyword">const</span> <span class="keywordtype">char</span> *tabs, <span class="keyword">const</span> <span class="keywordtype">char</span> *posttabs, <span class="keyword">struct</span> <a class="code" href="structast__str.html" title="The descriptor of a dynamic string XXX storage will be optimized later if needed...">ast_str</a> **buffer)
<a name="l01113"></a>01113 {
<a name="l01114"></a>01114    <span class="keyword">struct </span>ast_xml_node *node = fixnode;
<a name="l01115"></a>01115    <span class="keywordtype">int</span> ret = 0, i, count = 0;
<a name="l01116"></a>01116 
<a name="l01117"></a>01117    <span class="keywordflow">if</span> (!node || !<a class="code" href="xml_8h.html#a6064a4b3e299bb92aa8c8c7c1b363527" title="Get the node&amp;#39;s children.">ast_xml_node_get_children</a>(node)) {
<a name="l01118"></a>01118       <span class="keywordflow">return</span> ret;
<a name="l01119"></a>01119    }
<a name="l01120"></a>01120 
<a name="l01121"></a>01121    <span class="keywordflow">for</span> (i = 0; i &lt; <a class="code" href="isdn__lib_8c.html#ab9129b977a587b50ea801daac75e178f">ARRAY_LEN</a>(<a class="code" href="xmldoc_8c.html#a2779d1b00e3343992468fe48be466553">special_tags</a>); i++) {
<a name="l01122"></a>01122       <span class="keywordflow">if</span> (strcasecmp(<a class="code" href="xml_8h.html#a02cd60b8b2d5d96e78c858429b1b1d11" title="Get the name of a node.">ast_xml_node_get_name</a>(node), <a class="code" href="xmldoc_8c.html#a2779d1b00e3343992468fe48be466553">special_tags</a>[i].tagname)) {
<a name="l01123"></a>01123          <span class="keywordflow">continue</span>;
<a name="l01124"></a>01124       }
<a name="l01125"></a>01125 
<a name="l01126"></a>01126       ret = 1;
<a name="l01127"></a>01127       <span class="comment">/* This is a special tag. */</span>
<a name="l01128"></a>01128 
<a name="l01129"></a>01129       <span class="comment">/* concat data */</span>
<a name="l01130"></a>01130       <span class="keywordflow">if</span> (!<a class="code" href="strings_8h.html#a5c8aa5212ecb665fb072eac00c799da6">ast_strlen_zero</a>(<a class="code" href="xmldoc_8c.html#a2779d1b00e3343992468fe48be466553">special_tags</a>[i].init)) {
<a name="l01131"></a>01131          <a class="code" href="strings_8h.html#a85cd5a8ef499e39d22b4bfeb8b9a64f7" title="Append to a thread local dynamic string.">ast_str_append</a>(buffer, 0, <span class="stringliteral">&quot;%s%s&quot;</span>, tabs, <a class="code" href="xmldoc_8c.html#a2779d1b00e3343992468fe48be466553">special_tags</a>[i].init);
<a name="l01132"></a>01132       }
<a name="l01133"></a>01133 
<a name="l01134"></a>01134       <span class="comment">/* parse &lt;para&gt; elements inside special tags. */</span>
<a name="l01135"></a>01135       <span class="keywordflow">for</span> (node = <a class="code" href="xml_8h.html#a6064a4b3e299bb92aa8c8c7c1b363527" title="Get the node&amp;#39;s children.">ast_xml_node_get_children</a>(node); node; node = <a class="code" href="xml_8h.html#aa7d34402682c9bc1dfb9aea971f9eba7" title="Get the next node in the same level.">ast_xml_node_get_next</a>(node)) {
<a name="l01136"></a>01136          <span class="comment">/* first &lt;para&gt; just print it without tabs at the begining. */</span>
<a name="l01137"></a>01137          <span class="keywordflow">if</span> (<a class="code" href="xmldoc_8c.html#ae919d164af8a8f3e6cfbff1238a647cd">xmldoc_parse_para</a>(node, (!count ? <span class="stringliteral">&quot;&quot;</span> : tabs), posttabs, buffer) == 2) {
<a name="l01138"></a>01138             ret = 2;
<a name="l01139"></a>01139          }
<a name="l01140"></a>01140       }
<a name="l01141"></a>01141 
<a name="l01142"></a>01142       <span class="keywordflow">if</span> (!<a class="code" href="strings_8h.html#a5c8aa5212ecb665fb072eac00c799da6">ast_strlen_zero</a>(<a class="code" href="xmldoc_8c.html#a2779d1b00e3343992468fe48be466553">special_tags</a>[i].end)) {
<a name="l01143"></a>01143          <a class="code" href="strings_8h.html#a85cd5a8ef499e39d22b4bfeb8b9a64f7" title="Append to a thread local dynamic string.">ast_str_append</a>(buffer, 0, <span class="stringliteral">&quot;%s%s&quot;</span>, <a class="code" href="xmldoc_8c.html#a2779d1b00e3343992468fe48be466553">special_tags</a>[i].end, posttabs);
<a name="l01144"></a>01144       }
<a name="l01145"></a>01145 
<a name="l01146"></a>01146       <span class="keywordflow">break</span>;
<a name="l01147"></a>01147    }
<a name="l01148"></a>01148 
<a name="l01149"></a>01149    <span class="keywordflow">return</span> ret;
<a name="l01150"></a>01150 }
<a name="l01151"></a>01151 <span class="comment"></span>
<a name="l01152"></a>01152 <span class="comment">/*! \internal</span>
<a name="l01153"></a>01153 <span class="comment"> *  \brief Parse an &lt;argument&gt; element from the xml documentation.</span>
<a name="l01154"></a>01154 <span class="comment"> *  \param fixnode Pointer to the &apos;argument&apos; xml node.</span>
<a name="l01155"></a>01155 <span class="comment"> *  \param insideparameter If we are parsing an &lt;argument&gt; inside a &lt;parameter&gt;.</span>
<a name="l01156"></a>01156 <span class="comment"> *  \param paramtabs pre tabs if we are inside a parameter element.</span>
<a name="l01157"></a>01157 <span class="comment"> *  \param tabs What to be printed before the argument name.</span>
<a name="l01158"></a>01158 <span class="comment"> *  \param buffer Output buffer to put values found inside the &lt;argument&gt; element.</span>
<a name="l01159"></a>01159 <span class="comment"> *  \retval 1 If there is content inside the argument.</span>
<a name="l01160"></a>01160 <span class="comment"> *  \retval 0 If the argument element is not parsed, or there is no content inside it.</span>
<a name="l01161"></a>01161 <span class="comment"> */</span>
<a name="l01162"></a><a class="code" href="xmldoc_8c.html#a9611c47bd9a6bdb174fca9fdd4f7352a">01162</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="xmldoc_8c.html#a9611c47bd9a6bdb174fca9fdd4f7352a">xmldoc_parse_argument</a>(<span class="keyword">struct</span> ast_xml_node *fixnode, <span class="keywordtype">int</span> insideparameter, <span class="keyword">const</span> <span class="keywordtype">char</span> *paramtabs, <span class="keyword">const</span> <span class="keywordtype">char</span> *tabs, <span class="keyword">struct</span> <a class="code" href="structast__str.html" title="The descriptor of a dynamic string XXX storage will be optimized later if needed...">ast_str</a> **buffer)
<a name="l01163"></a>01163 {
<a name="l01164"></a>01164    <span class="keyword">struct </span>ast_xml_node *node = fixnode;
<a name="l01165"></a>01165    <span class="keyword">const</span> <span class="keywordtype">char</span> *argname;
<a name="l01166"></a>01166    <span class="keywordtype">int</span> count = 0, ret = 0;
<a name="l01167"></a>01167 
<a name="l01168"></a>01168    <span class="keywordflow">if</span> (!node || !<a class="code" href="xml_8h.html#a6064a4b3e299bb92aa8c8c7c1b363527" title="Get the node&amp;#39;s children.">ast_xml_node_get_children</a>(node)) {
<a name="l01169"></a>01169       <span class="keywordflow">return</span> ret;
<a name="l01170"></a>01170    }
<a name="l01171"></a>01171 
<a name="l01172"></a>01172    <span class="comment">/* Print the argument names */</span>
<a name="l01173"></a>01173    argname = <a class="code" href="xml_8h.html#aa530ec72e11a97546295ede1736a1475" title="Get a node attribute by name.">ast_xml_get_attribute</a>(node, <span class="stringliteral">&quot;name&quot;</span>);
<a name="l01174"></a>01174    <span class="keywordflow">if</span> (!argname) {
<a name="l01175"></a>01175       <span class="keywordflow">return</span> 0;
<a name="l01176"></a>01176    }
<a name="l01177"></a>01177    <span class="keywordflow">if</span> (<a class="code" href="xmldoc_8c.html#ab9142298d52f52d3e9bf70ed451d6fdd">xmldoc_has_inside</a>(node, <span class="stringliteral">&quot;para&quot;</span>) || <a class="code" href="xmldoc_8c.html#a91c8dec3abf7f3ca868e5fd33d81f866">xmldoc_has_specialtags</a>(node)) {
<a name="l01178"></a>01178       <a class="code" href="strings_8h.html#a85cd5a8ef499e39d22b4bfeb8b9a64f7" title="Append to a thread local dynamic string.">ast_str_append</a>(buffer, 0, <span class="stringliteral">&quot;%s%s%s&quot;</span>, tabs, argname, (insideparameter ? <span class="stringliteral">&quot;\n&quot;</span> : <span class="stringliteral">&quot;&quot;</span>));
<a name="l01179"></a>01179       <a class="code" href="xml_8h.html#a8a555ceb9dcd4102c73aad5304ff2f34" title="Free an attribute returned by ast_xml_get_attribute().">ast_xml_free_attr</a>(argname);
<a name="l01180"></a>01180    } <span class="keywordflow">else</span> {
<a name="l01181"></a>01181       <a class="code" href="xml_8h.html#a8a555ceb9dcd4102c73aad5304ff2f34" title="Free an attribute returned by ast_xml_get_attribute().">ast_xml_free_attr</a>(argname);
<a name="l01182"></a>01182       <span class="keywordflow">return</span> 0;
<a name="l01183"></a>01183    }
<a name="l01184"></a>01184 
<a name="l01185"></a>01185    <span class="keywordflow">for</span> (node = <a class="code" href="xml_8h.html#a6064a4b3e299bb92aa8c8c7c1b363527" title="Get the node&amp;#39;s children.">ast_xml_node_get_children</a>(node); node; node = <a class="code" href="xml_8h.html#aa7d34402682c9bc1dfb9aea971f9eba7" title="Get the next node in the same level.">ast_xml_node_get_next</a>(node)) {
<a name="l01186"></a>01186       <span class="keywordflow">if</span> (<a class="code" href="xmldoc_8c.html#ae919d164af8a8f3e6cfbff1238a647cd">xmldoc_parse_para</a>(node, (insideparameter ? paramtabs : (!count ? <span class="stringliteral">&quot; - &quot;</span> : tabs)), <span class="stringliteral">&quot;\n&quot;</span>, buffer) == 2) {
<a name="l01187"></a>01187          count++;
<a name="l01188"></a>01188          ret = 1;
<a name="l01189"></a>01189       } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="xmldoc_8c.html#a494124315bb990544dc492592446352c">xmldoc_parse_specialtags</a>(node, (insideparameter ? paramtabs : (!count ? <span class="stringliteral">&quot; - &quot;</span> : tabs)), <span class="stringliteral">&quot;\n&quot;</span>, buffer) == 2) {
<a name="l01190"></a>01190          count++;
<a name="l01191"></a>01191          ret = 1;
<a name="l01192"></a>01192       }
<a name="l01193"></a>01193    }
<a name="l01194"></a>01194 
<a name="l01195"></a>01195    <span class="keywordflow">return</span> ret;
<a name="l01196"></a>01196 }
<a name="l01197"></a>01197 <span class="comment"></span>
<a name="l01198"></a>01198 <span class="comment">/*! \internal</span>
<a name="l01199"></a>01199 <span class="comment"> *  \brief Parse a &lt;variable&gt; node inside a &lt;variablelist&gt; node.</span>
<a name="l01200"></a>01200 <span class="comment"> *  \param node The variable node to parse.</span>
<a name="l01201"></a>01201 <span class="comment"> *  \param tabs A string to be appended at the begining of the output that will be stored</span>
<a name="l01202"></a>01202 <span class="comment"> *         in buffer.</span>
<a name="l01203"></a>01203 <span class="comment"> *  \param buffer This must be an already created ast_str. It will be used</span>
<a name="l01204"></a>01204 <span class="comment"> *         to store the result (if already has something it will be appended to the current</span>
<a name="l01205"></a>01205 <span class="comment"> *         string).</span>
<a name="l01206"></a>01206 <span class="comment"> *  \retval 0 if no data is appended.</span>
<a name="l01207"></a>01207 <span class="comment"> *  \retval 1 if data is appended.</span>
<a name="l01208"></a>01208 <span class="comment"> */</span>
<a name="l01209"></a><a class="code" href="xmldoc_8c.html#a37edc02a5bf87103fcecb56a16fa8d05">01209</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="xmldoc_8c.html#a37edc02a5bf87103fcecb56a16fa8d05">xmldoc_parse_variable</a>(<span class="keyword">struct</span> ast_xml_node *node, <span class="keyword">const</span> <span class="keywordtype">char</span> *tabs, <span class="keyword">struct</span> <a class="code" href="structast__str.html" title="The descriptor of a dynamic string XXX storage will be optimized later if needed...">ast_str</a> **buffer)
<a name="l01210"></a>01210 {
<a name="l01211"></a>01211    <span class="keyword">struct </span>ast_xml_node *tmp;
<a name="l01212"></a>01212    <span class="keyword">const</span> <span class="keywordtype">char</span> *valname;
<a name="l01213"></a>01213    <span class="keyword">const</span> <span class="keywordtype">char</span> *tmptext;
<a name="l01214"></a>01214    <span class="keyword">struct </span><a class="code" href="structast__str.html" title="The descriptor of a dynamic string XXX storage will be optimized later if needed...">ast_str</a> *cleanstr;
<a name="l01215"></a>01215    <span class="keywordtype">int</span> ret = 0, printedpara=0;
<a name="l01216"></a>01216 
<a name="l01217"></a>01217    <span class="keywordflow">for</span> (tmp = <a class="code" href="xml_8h.html#a6064a4b3e299bb92aa8c8c7c1b363527" title="Get the node&amp;#39;s children.">ast_xml_node_get_children</a>(node); tmp; tmp = <a class="code" href="xml_8h.html#aa7d34402682c9bc1dfb9aea971f9eba7" title="Get the next node in the same level.">ast_xml_node_get_next</a>(tmp)) {
<a name="l01218"></a>01218       <span class="keywordflow">if</span> (<a class="code" href="xmldoc_8c.html#ae919d164af8a8f3e6cfbff1238a647cd">xmldoc_parse_para</a>(tmp, (ret ? tabs : <span class="stringliteral">&quot;&quot;</span>), <span class="stringliteral">&quot;\n&quot;</span>, buffer)) {
<a name="l01219"></a>01219          printedpara = 1;
<a name="l01220"></a>01220          <span class="keywordflow">continue</span>;
<a name="l01221"></a>01221       } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="xmldoc_8c.html#a494124315bb990544dc492592446352c">xmldoc_parse_specialtags</a>(tmp, (ret ? tabs : <span class="stringliteral">&quot;&quot;</span>), <span class="stringliteral">&quot;\n&quot;</span>, buffer)) {
<a name="l01222"></a>01222          printedpara = 1;
<a name="l01223"></a>01223          <span class="keywordflow">continue</span>;
<a name="l01224"></a>01224       }
<a name="l01225"></a>01225 
<a name="l01226"></a>01226       <span class="keywordflow">if</span> (strcasecmp(<a class="code" href="xml_8h.html#a02cd60b8b2d5d96e78c858429b1b1d11" title="Get the name of a node.">ast_xml_node_get_name</a>(tmp), <span class="stringliteral">&quot;value&quot;</span>)) {
<a name="l01227"></a>01227          <span class="keywordflow">continue</span>;
<a name="l01228"></a>01228       }
<a name="l01229"></a>01229 
<a name="l01230"></a>01230       <span class="comment">/* Parse a &lt;value&gt; tag only. */</span>
<a name="l01231"></a>01231       <span class="keywordflow">if</span> (!printedpara) {
<a name="l01232"></a>01232          <a class="code" href="strings_8h.html#a85cd5a8ef499e39d22b4bfeb8b9a64f7" title="Append to a thread local dynamic string.">ast_str_append</a>(buffer, 0, <span class="stringliteral">&quot;\n&quot;</span>);
<a name="l01233"></a>01233          printedpara = 1;
<a name="l01234"></a>01234       }
<a name="l01235"></a>01235       <span class="comment">/* Parse each &lt;value name=&apos;valuename&apos;&gt;desciption&lt;/value&gt; */</span>
<a name="l01236"></a>01236       valname = <a class="code" href="xml_8h.html#aa530ec72e11a97546295ede1736a1475" title="Get a node attribute by name.">ast_xml_get_attribute</a>(tmp, <span class="stringliteral">&quot;name&quot;</span>);
<a name="l01237"></a>01237       <span class="keywordflow">if</span> (valname) {
<a name="l01238"></a>01238          ret = 1;
<a name="l01239"></a>01239          <a class="code" href="strings_8h.html#a85cd5a8ef499e39d22b4bfeb8b9a64f7" title="Append to a thread local dynamic string.">ast_str_append</a>(buffer, 0, <span class="stringliteral">&quot;%s&lt;value&gt;%s&lt;/value&gt;&quot;</span>, tabs, valname);
<a name="l01240"></a>01240          <a class="code" href="xml_8h.html#a8a555ceb9dcd4102c73aad5304ff2f34" title="Free an attribute returned by ast_xml_get_attribute().">ast_xml_free_attr</a>(valname);
<a name="l01241"></a>01241       }
<a name="l01242"></a>01242       tmptext = <a class="code" href="xml_8h.html#ad113291cd96631f7b440d82fbc33dd13" title="Get an element content string.">ast_xml_get_text</a>(tmp);
<a name="l01243"></a>01243       <span class="comment">/* Check inside this node for any explanation about its meaning. */</span>
<a name="l01244"></a>01244       <span class="keywordflow">if</span> (tmptext) {
<a name="l01245"></a>01245          <span class="comment">/* Cleanup text. */</span>
<a name="l01246"></a>01246          <a class="code" href="xmldoc_8c.html#a9b126a6b2606df7e517d382fb9565295">xmldoc_string_cleanup</a>(tmptext, &amp;cleanstr, 1);
<a name="l01247"></a>01247          <a class="code" href="xml_8h.html#ae428c2b44d463e2fe692360f4d530cdb" title="Free a content element that was returned by ast_xml_get_text().">ast_xml_free_text</a>(tmptext);
<a name="l01248"></a>01248          <span class="keywordflow">if</span> (cleanstr &amp;&amp; <a class="code" href="strings_8h.html#a99409c17a1d20e1c3dc00039b7925a2d" title="Returns the current length of the string stored within buf.">ast_str_strlen</a>(cleanstr) &gt; 0) {
<a name="l01249"></a>01249             <a class="code" href="strings_8h.html#a85cd5a8ef499e39d22b4bfeb8b9a64f7" title="Append to a thread local dynamic string.">ast_str_append</a>(buffer, 0, <span class="stringliteral">&quot;:%s&quot;</span>, <a class="code" href="strings_8h.html#a053bdfc229997a75f112bdd7b995e00b" title="Returns the string buffer within the ast_str buf.">ast_str_buffer</a>(cleanstr));
<a name="l01250"></a>01250          }
<a name="l01251"></a>01251          <a class="code" href="astmm_8h.html#a402072d6789f6ed9e3a81da27504127e">ast_free</a>(cleanstr);
<a name="l01252"></a>01252       }
<a name="l01253"></a>01253       <a class="code" href="strings_8h.html#a85cd5a8ef499e39d22b4bfeb8b9a64f7" title="Append to a thread local dynamic string.">ast_str_append</a>(buffer, 0, <span class="stringliteral">&quot;\n&quot;</span>);
<a name="l01254"></a>01254    }
<a name="l01255"></a>01255 
<a name="l01256"></a>01256    <span class="keywordflow">return</span> ret;
<a name="l01257"></a>01257 }
<a name="l01258"></a>01258 <span class="comment"></span>
<a name="l01259"></a>01259 <span class="comment">/*! \internal</span>
<a name="l01260"></a>01260 <span class="comment"> *  \brief Parse a &lt;variablelist&gt; node and put all the output inside &apos;buffer&apos;.</span>
<a name="l01261"></a>01261 <span class="comment"> *  \param node The variablelist node pointer.</span>
<a name="l01262"></a>01262 <span class="comment"> *  \param tabs A string to be appended at the begining of the output that will be stored</span>
<a name="l01263"></a>01263 <span class="comment"> *         in buffer.</span>
<a name="l01264"></a>01264 <span class="comment"> *  \param buffer This must be an already created ast_str. It will be used</span>
<a name="l01265"></a>01265 <span class="comment"> *         to store the result (if already has something it will be appended to the current</span>
<a name="l01266"></a>01266 <span class="comment"> *         string).</span>
<a name="l01267"></a>01267 <span class="comment"> *  \retval 1 If a &lt;variablelist&gt; element is parsed.</span>
<a name="l01268"></a>01268 <span class="comment"> *  \retval 0 On error.</span>
<a name="l01269"></a>01269 <span class="comment"> */</span>
<a name="l01270"></a><a class="code" href="xmldoc_8c.html#a93edbb9740c7ab09ead22d614cafdad1">01270</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="xmldoc_8c.html#a93edbb9740c7ab09ead22d614cafdad1">xmldoc_parse_variablelist</a>(<span class="keyword">struct</span> ast_xml_node *node, <span class="keyword">const</span> <span class="keywordtype">char</span> *tabs, <span class="keyword">struct</span> <a class="code" href="structast__str.html" title="The descriptor of a dynamic string XXX storage will be optimized later if needed...">ast_str</a> **buffer)
<a name="l01271"></a>01271 {
<a name="l01272"></a>01272    <span class="keyword">struct </span>ast_xml_node *tmp;
<a name="l01273"></a>01273    <span class="keyword">const</span> <span class="keywordtype">char</span> *varname;
<a name="l01274"></a>01274    <span class="keywordtype">char</span> *vartabs;
<a name="l01275"></a>01275    <span class="keywordtype">int</span> ret = 0;
<a name="l01276"></a>01276 
<a name="l01277"></a>01277    <span class="keywordflow">if</span> (!node || !<a class="code" href="xml_8h.html#a6064a4b3e299bb92aa8c8c7c1b363527" title="Get the node&amp;#39;s children.">ast_xml_node_get_children</a>(node)) {
<a name="l01278"></a>01278       <span class="keywordflow">return</span> ret;
<a name="l01279"></a>01279    }
<a name="l01280"></a>01280 
<a name="l01281"></a>01281    <span class="keywordflow">if</span> (strcasecmp(<a class="code" href="xml_8h.html#a02cd60b8b2d5d96e78c858429b1b1d11" title="Get the name of a node.">ast_xml_node_get_name</a>(node), <span class="stringliteral">&quot;variablelist&quot;</span>)) {
<a name="l01282"></a>01282       <span class="keywordflow">return</span> ret;
<a name="l01283"></a>01283    }
<a name="l01284"></a>01284 
<a name="l01285"></a>01285    <span class="comment">/* use this spacing (add 4 spaces) inside a variablelist node. */</span>
<a name="l01286"></a>01286    <a class="code" href="astmm_8h.html#aee6f1d27500ac19fa0b842022f987817">ast_asprintf</a>(&amp;vartabs, <span class="stringliteral">&quot;%s    &quot;</span>, tabs);
<a name="l01287"></a>01287    <span class="keywordflow">if</span> (!vartabs) {
<a name="l01288"></a>01288       <span class="keywordflow">return</span> ret;
<a name="l01289"></a>01289    }
<a name="l01290"></a>01290    <span class="keywordflow">for</span> (tmp = <a class="code" href="xml_8h.html#a6064a4b3e299bb92aa8c8c7c1b363527" title="Get the node&amp;#39;s children.">ast_xml_node_get_children</a>(node); tmp; tmp = <a class="code" href="xml_8h.html#aa7d34402682c9bc1dfb9aea971f9eba7" title="Get the next node in the same level.">ast_xml_node_get_next</a>(tmp)) {
<a name="l01291"></a>01291       <span class="comment">/* We can have a &lt;para&gt; element inside the variable list */</span>
<a name="l01292"></a>01292       <span class="keywordflow">if</span> ((<a class="code" href="xmldoc_8c.html#ae919d164af8a8f3e6cfbff1238a647cd">xmldoc_parse_para</a>(tmp, (ret ? tabs : <span class="stringliteral">&quot;&quot;</span>), <span class="stringliteral">&quot;\n&quot;</span>, buffer))) {
<a name="l01293"></a>01293          ret = 1;
<a name="l01294"></a>01294          <span class="keywordflow">continue</span>;
<a name="l01295"></a>01295       } <span class="keywordflow">else</span> <span class="keywordflow">if</span> ((<a class="code" href="xmldoc_8c.html#a494124315bb990544dc492592446352c">xmldoc_parse_specialtags</a>(tmp, (ret ? tabs : <span class="stringliteral">&quot;&quot;</span>), <span class="stringliteral">&quot;\n&quot;</span>, buffer))) {
<a name="l01296"></a>01296          ret = 1;
<a name="l01297"></a>01297          <span class="keywordflow">continue</span>;
<a name="l01298"></a>01298       }
<a name="l01299"></a>01299 
<a name="l01300"></a>01300       <span class="keywordflow">if</span> (!strcasecmp(<a class="code" href="xml_8h.html#a02cd60b8b2d5d96e78c858429b1b1d11" title="Get the name of a node.">ast_xml_node_get_name</a>(tmp), <span class="stringliteral">&quot;variable&quot;</span>)) {
<a name="l01301"></a>01301          <span class="comment">/* Store the variable name in buffer. */</span>
<a name="l01302"></a>01302          varname = <a class="code" href="xml_8h.html#aa530ec72e11a97546295ede1736a1475" title="Get a node attribute by name.">ast_xml_get_attribute</a>(tmp, <span class="stringliteral">&quot;name&quot;</span>);
<a name="l01303"></a>01303          <span class="keywordflow">if</span> (varname) {
<a name="l01304"></a>01304             <a class="code" href="strings_8h.html#a85cd5a8ef499e39d22b4bfeb8b9a64f7" title="Append to a thread local dynamic string.">ast_str_append</a>(buffer, 0, <span class="stringliteral">&quot;%s&lt;variable&gt;%s&lt;/variable&gt;: &quot;</span>, tabs, varname);
<a name="l01305"></a>01305             <a class="code" href="xml_8h.html#a8a555ceb9dcd4102c73aad5304ff2f34" title="Free an attribute returned by ast_xml_get_attribute().">ast_xml_free_attr</a>(varname);
<a name="l01306"></a>01306             <span class="comment">/* Parse the &lt;variable&gt; possible values. */</span>
<a name="l01307"></a>01307             <a class="code" href="xmldoc_8c.html#a37edc02a5bf87103fcecb56a16fa8d05">xmldoc_parse_variable</a>(tmp, vartabs, buffer);
<a name="l01308"></a>01308             ret = 1;
<a name="l01309"></a>01309          }
<a name="l01310"></a>01310       }
<a name="l01311"></a>01311    }
<a name="l01312"></a>01312 
<a name="l01313"></a>01313    <a class="code" href="astmm_8h.html#a402072d6789f6ed9e3a81da27504127e">ast_free</a>(vartabs);
<a name="l01314"></a>01314 
<a name="l01315"></a>01315    <span class="keywordflow">return</span> ret;
<a name="l01316"></a>01316 }
<a name="l01317"></a>01317 
<a name="l01318"></a><a class="code" href="xmldoc_8c.html#a51987b5bfa995cc9b76c81dd1a1d6ad4">01318</a> <span class="keywordtype">char</span> *<a class="code" href="xmldoc_8h.html#a51987b5bfa995cc9b76c81dd1a1d6ad4" title="Parse the &amp;lt;see-also&amp;gt; node content.">ast_xmldoc_build_seealso</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> *<a class="code" href="evt_8c.html#a69e2889a94aeb9ac881abb82d3c22116">type</a>, <span class="keyword">const</span> <span class="keywordtype">char</span> *<a class="code" href="cdr__adaptive__odbc_8c.html#a5ac083a645d964373f022d03df4849c8">name</a>)
<a name="l01319"></a>01319 {
<a name="l01320"></a>01320    <span class="keyword">struct </span><a class="code" href="structast__str.html" title="The descriptor of a dynamic string XXX storage will be optimized later if needed...">ast_str</a> *outputstr;
<a name="l01321"></a>01321    <span class="keywordtype">char</span> *output;
<a name="l01322"></a>01322    <span class="keyword">struct </span>ast_xml_node *node;
<a name="l01323"></a>01323    <span class="keyword">const</span> <span class="keywordtype">char</span> *<span class="keyword">typename</span>;
<a name="l01324"></a>01324    <span class="keyword">const</span> <span class="keywordtype">char</span> *content;
<a name="l01325"></a>01325    <span class="keywordtype">int</span> <a class="code" href="devicestate_8c.html#abd2135e6f8a41bc900933b1985d97165">first</a> = 1;
<a name="l01326"></a>01326 
<a name="l01327"></a>01327    <span class="keywordflow">if</span> (<a class="code" href="strings_8h.html#a5c8aa5212ecb665fb072eac00c799da6">ast_strlen_zero</a>(type) || <a class="code" href="strings_8h.html#a5c8aa5212ecb665fb072eac00c799da6">ast_strlen_zero</a>(name)) {
<a name="l01328"></a>01328       <span class="keywordflow">return</span> NULL;
<a name="l01329"></a>01329    }
<a name="l01330"></a>01330 
<a name="l01331"></a>01331    <span class="comment">/* get the application/function root node. */</span>
<a name="l01332"></a>01332    node = <a class="code" href="xmldoc_8c.html#af1f439077def997dc752361c8dbdcb12">xmldoc_get_node</a>(type, name, documentation_language);
<a name="l01333"></a>01333    <span class="keywordflow">if</span> (!node || !<a class="code" href="xml_8h.html#a6064a4b3e299bb92aa8c8c7c1b363527" title="Get the node&amp;#39;s children.">ast_xml_node_get_children</a>(node)) {
<a name="l01334"></a>01334       <span class="keywordflow">return</span> NULL;
<a name="l01335"></a>01335    }
<a name="l01336"></a>01336 
<a name="l01337"></a>01337    <span class="comment">/* Find the &lt;see-also&gt; node. */</span>
<a name="l01338"></a>01338    <span class="keywordflow">for</span> (node = <a class="code" href="xml_8h.html#a6064a4b3e299bb92aa8c8c7c1b363527" title="Get the node&amp;#39;s children.">ast_xml_node_get_children</a>(node); node; node = <a class="code" href="xml_8h.html#aa7d34402682c9bc1dfb9aea971f9eba7" title="Get the next node in the same level.">ast_xml_node_get_next</a>(node)) {
<a name="l01339"></a>01339       <span class="keywordflow">if</span> (!strcasecmp(<a class="code" href="xml_8h.html#a02cd60b8b2d5d96e78c858429b1b1d11" title="Get the name of a node.">ast_xml_node_get_name</a>(node), <span class="stringliteral">&quot;see-also&quot;</span>)) {
<a name="l01340"></a>01340          <span class="keywordflow">break</span>;
<a name="l01341"></a>01341       }
<a name="l01342"></a>01342    }
<a name="l01343"></a>01343 
<a name="l01344"></a>01344    <span class="keywordflow">if</span> (!node || !<a class="code" href="xml_8h.html#a6064a4b3e299bb92aa8c8c7c1b363527" title="Get the node&amp;#39;s children.">ast_xml_node_get_children</a>(node)) {
<a name="l01345"></a>01345       <span class="comment">/* we couldnt find a &lt;see-also&gt; node. */</span>
<a name="l01346"></a>01346       <span class="keywordflow">return</span> NULL;
<a name="l01347"></a>01347    }
<a name="l01348"></a>01348 
<a name="l01349"></a>01349    <span class="comment">/* prepare the output string. */</span>
<a name="l01350"></a>01350    outputstr = <a class="code" href="strings_8h.html#a8ec37e4acb6ecb20eb6f6edd1141cd76" title="Create a malloc&amp;#39;ed dynamic length string.">ast_str_create</a>(128);
<a name="l01351"></a>01351    <span class="keywordflow">if</span> (!outputstr) {
<a name="l01352"></a>01352       <span class="keywordflow">return</span> NULL;
<a name="l01353"></a>01353    }
<a name="l01354"></a>01354 
<a name="l01355"></a>01355    <span class="comment">/* get into the &lt;see-also&gt; node. */</span>
<a name="l01356"></a>01356    <span class="keywordflow">for</span> (node = <a class="code" href="xml_8h.html#a6064a4b3e299bb92aa8c8c7c1b363527" title="Get the node&amp;#39;s children.">ast_xml_node_get_children</a>(node); node; node = <a class="code" href="xml_8h.html#aa7d34402682c9bc1dfb9aea971f9eba7" title="Get the next node in the same level.">ast_xml_node_get_next</a>(node)) {
<a name="l01357"></a>01357       <span class="keywordflow">if</span> (strcasecmp(<a class="code" href="xml_8h.html#a02cd60b8b2d5d96e78c858429b1b1d11" title="Get the name of a node.">ast_xml_node_get_name</a>(node), <span class="stringliteral">&quot;ref&quot;</span>)) {
<a name="l01358"></a>01358          <span class="keywordflow">continue</span>;
<a name="l01359"></a>01359       }
<a name="l01360"></a>01360 
<a name="l01361"></a>01361       <span class="comment">/* parse the &lt;ref&gt; node. &apos;type&apos; attribute is required. */</span>
<a name="l01362"></a>01362       <span class="keyword">typename</span> = <a class="code" href="xml_8h.html#aa530ec72e11a97546295ede1736a1475" title="Get a node attribute by name.">ast_xml_get_attribute</a>(node, <span class="stringliteral">&quot;type&quot;</span>);
<a name="l01363"></a>01363       <span class="keywordflow">if</span> (!<span class="keyword">typename</span>) {
<a name="l01364"></a>01364          <span class="keywordflow">continue</span>;
<a name="l01365"></a>01365       }
<a name="l01366"></a>01366       content = <a class="code" href="xml_8h.html#ad113291cd96631f7b440d82fbc33dd13" title="Get an element content string.">ast_xml_get_text</a>(node);
<a name="l01367"></a>01367       <span class="keywordflow">if</span> (!content) {
<a name="l01368"></a>01368          <a class="code" href="xml_8h.html#a8a555ceb9dcd4102c73aad5304ff2f34" title="Free an attribute returned by ast_xml_get_attribute().">ast_xml_free_attr</a>(<span class="keyword">typename</span>);
<a name="l01369"></a>01369          <span class="keywordflow">continue</span>;
<a name="l01370"></a>01370       }
<a name="l01371"></a>01371       <span class="keywordflow">if</span> (!strcasecmp(<span class="keyword">typename</span>, <span class="stringliteral">&quot;application&quot;</span>)) {
<a name="l01372"></a>01372          <a class="code" href="strings_8h.html#a85cd5a8ef499e39d22b4bfeb8b9a64f7" title="Append to a thread local dynamic string.">ast_str_append</a>(&amp;outputstr, 0, <span class="stringliteral">&quot;%s%s()&quot;</span>,   (first ? <span class="stringliteral">&quot;&quot;</span> : <span class="stringliteral">&quot;, &quot;</span>), content);
<a name="l01373"></a>01373       } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (!strcasecmp(<span class="keyword">typename</span>, <span class="stringliteral">&quot;function&quot;</span>)) {
<a name="l01374"></a>01374          <a class="code" href="strings_8h.html#a85cd5a8ef499e39d22b4bfeb8b9a64f7" title="Append to a thread local dynamic string.">ast_str_append</a>(&amp;outputstr, 0, <span class="stringliteral">&quot;%s%s&quot;</span>, (first ? <span class="stringliteral">&quot;&quot;</span> : <span class="stringliteral">&quot;, &quot;</span>), content);
<a name="l01375"></a>01375       } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (!strcasecmp(<span class="keyword">typename</span>, <span class="stringliteral">&quot;astcli&quot;</span>)) {
<a name="l01376"></a>01376          <a class="code" href="strings_8h.html#a85cd5a8ef499e39d22b4bfeb8b9a64f7" title="Append to a thread local dynamic string.">ast_str_append</a>(&amp;outputstr, 0, <span class="stringliteral">&quot;%s&lt;astcli&gt;%s&lt;/astcli&gt;&quot;</span>, (first ? <span class="stringliteral">&quot;&quot;</span> : <span class="stringliteral">&quot;, &quot;</span>), content);
<a name="l01377"></a>01377       } <span class="keywordflow">else</span> {
<a name="l01378"></a>01378          <a class="code" href="strings_8h.html#a85cd5a8ef499e39d22b4bfeb8b9a64f7" title="Append to a thread local dynamic string.">ast_str_append</a>(&amp;outputstr, 0, <span class="stringliteral">&quot;%s%s&quot;</span>, (first ? <span class="stringliteral">&quot;&quot;</span> : <span class="stringliteral">&quot;, &quot;</span>), content);
<a name="l01379"></a>01379       }
<a name="l01380"></a>01380       first = 0;
<a name="l01381"></a>01381       <a class="code" href="xml_8h.html#ae428c2b44d463e2fe692360f4d530cdb" title="Free a content element that was returned by ast_xml_get_text().">ast_xml_free_text</a>(content);
<a name="l01382"></a>01382       <a class="code" href="xml_8h.html#a8a555ceb9dcd4102c73aad5304ff2f34" title="Free an attribute returned by ast_xml_get_attribute().">ast_xml_free_attr</a>(<span class="keyword">typename</span>);
<a name="l01383"></a>01383    }
<a name="l01384"></a>01384 
<a name="l01385"></a>01385    output = <a class="code" href="astmm_8h.html#a2ef2401ade6b4b773138a82c86c40903">ast_strdup</a>(<a class="code" href="strings_8h.html#a053bdfc229997a75f112bdd7b995e00b" title="Returns the string buffer within the ast_str buf.">ast_str_buffer</a>(outputstr));
<a name="l01386"></a>01386    <a class="code" href="astmm_8h.html#a402072d6789f6ed9e3a81da27504127e">ast_free</a>(outputstr);
<a name="l01387"></a>01387 
<a name="l01388"></a>01388    <span class="keywordflow">return</span> output;
<a name="l01389"></a>01389 }
<a name="l01390"></a>01390 <span class="comment"></span>
<a name="l01391"></a>01391 <span class="comment">/*! \internal</span>
<a name="l01392"></a>01392 <span class="comment"> *  \brief Parse a &lt;enum&gt; node.</span>
<a name="l01393"></a>01393 <span class="comment"> *  \brief fixnode An ast_xml_node pointer to the &lt;enum&gt; node.</span>
<a name="l01394"></a>01394 <span class="comment"> *  \bried buffer The output buffer.</span>
<a name="l01395"></a>01395 <span class="comment"> *  \retval 0 if content is not found inside the enum element (data is not appended to buffer).</span>
<a name="l01396"></a>01396 <span class="comment"> *  \retval 1 if content is found and data is appended to buffer.</span>
<a name="l01397"></a>01397 <span class="comment"> */</span>
<a name="l01398"></a><a class="code" href="xmldoc_8c.html#a05fdccf1393d6c6733a27f08d7b0958d">01398</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="xmldoc_8c.html#a05fdccf1393d6c6733a27f08d7b0958d">xmldoc_parse_enum</a>(<span class="keyword">struct</span> ast_xml_node *fixnode, <span class="keyword">const</span> <span class="keywordtype">char</span> *tabs, <span class="keyword">struct</span> <a class="code" href="structast__str.html" title="The descriptor of a dynamic string XXX storage will be optimized later if needed...">ast_str</a> **buffer)
<a name="l01399"></a>01399 {
<a name="l01400"></a>01400    <span class="keyword">struct </span>ast_xml_node *node = fixnode;
<a name="l01401"></a>01401    <span class="keywordtype">int</span> ret = 0;
<a name="l01402"></a>01402    <span class="keywordtype">char</span> *optiontabs;
<a name="l01403"></a>01403 
<a name="l01404"></a>01404    <a class="code" href="astmm_8h.html#aee6f1d27500ac19fa0b842022f987817">ast_asprintf</a>(&amp;optiontabs, <span class="stringliteral">&quot;%s    &quot;</span>, tabs);
<a name="l01405"></a>01405 
<a name="l01406"></a>01406    <span class="keywordflow">for</span> (node = <a class="code" href="xml_8h.html#a6064a4b3e299bb92aa8c8c7c1b363527" title="Get the node&amp;#39;s children.">ast_xml_node_get_children</a>(node); node; node = <a class="code" href="xml_8h.html#aa7d34402682c9bc1dfb9aea971f9eba7" title="Get the next node in the same level.">ast_xml_node_get_next</a>(node)) {
<a name="l01407"></a>01407       <span class="keywordflow">if</span> ((<a class="code" href="xmldoc_8c.html#ae919d164af8a8f3e6cfbff1238a647cd">xmldoc_parse_para</a>(node, (ret ? tabs : <span class="stringliteral">&quot; - &quot;</span>), <span class="stringliteral">&quot;\n&quot;</span>, buffer))) {
<a name="l01408"></a>01408          ret = 1;
<a name="l01409"></a>01409       } <span class="keywordflow">else</span> <span class="keywordflow">if</span> ((<a class="code" href="xmldoc_8c.html#a494124315bb990544dc492592446352c">xmldoc_parse_specialtags</a>(node, (ret ? tabs : <span class="stringliteral">&quot; - &quot;</span>), <span class="stringliteral">&quot;\n&quot;</span>, buffer))) {
<a name="l01410"></a>01410          ret = 1;
<a name="l01411"></a>01411       }
<a name="l01412"></a>01412 
<a name="l01413"></a>01413       <a class="code" href="xmldoc_8c.html#aedc9e210a0057f5e7dc9f0caf3ba86a7">xmldoc_parse_enumlist</a>(node, optiontabs, buffer);
<a name="l01414"></a>01414    }
<a name="l01415"></a>01415 
<a name="l01416"></a>01416    <a class="code" href="astmm_8h.html#a402072d6789f6ed9e3a81da27504127e">ast_free</a>(optiontabs);
<a name="l01417"></a>01417 
<a name="l01418"></a>01418    <span class="keywordflow">return</span> ret;
<a name="l01419"></a>01419 }
<a name="l01420"></a>01420 <span class="comment"></span>
<a name="l01421"></a>01421 <span class="comment">/*! \internal</span>
<a name="l01422"></a>01422 <span class="comment"> *  \brief Parse a &lt;enumlist&gt; node.</span>
<a name="l01423"></a>01423 <span class="comment"> *  \param fixnode As ast_xml pointer to the &lt;enumlist&gt; node.</span>
<a name="l01424"></a>01424 <span class="comment"> *  \param buffer The ast_str output buffer.</span>
<a name="l01425"></a>01425 <span class="comment"> *  \retval 0 if no &lt;enumlist&gt; node was parsed.</span>
<a name="l01426"></a>01426 <span class="comment"> *  \retval 1 if a &lt;enumlist&gt; node was parsed.</span>
<a name="l01427"></a>01427 <span class="comment"> */</span>
<a name="l01428"></a><a class="code" href="xmldoc_8c.html#aedc9e210a0057f5e7dc9f0caf3ba86a7">01428</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="xmldoc_8c.html#aedc9e210a0057f5e7dc9f0caf3ba86a7">xmldoc_parse_enumlist</a>(<span class="keyword">struct</span> ast_xml_node *fixnode, <span class="keyword">const</span> <span class="keywordtype">char</span> *tabs, <span class="keyword">struct</span> <a class="code" href="structast__str.html" title="The descriptor of a dynamic string XXX storage will be optimized later if needed...">ast_str</a> **buffer)
<a name="l01429"></a>01429 {
<a name="l01430"></a>01430    <span class="keyword">struct </span>ast_xml_node *node = fixnode;
<a name="l01431"></a>01431    <span class="keyword">const</span> <span class="keywordtype">char</span> *enumname;
<a name="l01432"></a>01432    <span class="keywordtype">int</span> ret = 0;
<a name="l01433"></a>01433 
<a name="l01434"></a>01434    <span class="keywordflow">for</span> (node = <a class="code" href="xml_8h.html#a6064a4b3e299bb92aa8c8c7c1b363527" title="Get the node&amp;#39;s children.">ast_xml_node_get_children</a>(node); node; node = <a class="code" href="xml_8h.html#aa7d34402682c9bc1dfb9aea971f9eba7" title="Get the next node in the same level.">ast_xml_node_get_next</a>(node)) {
<a name="l01435"></a>01435       <span class="keywordflow">if</span> (strcasecmp(<a class="code" href="xml_8h.html#a02cd60b8b2d5d96e78c858429b1b1d11" title="Get the name of a node.">ast_xml_node_get_name</a>(node), <span class="stringliteral">&quot;enum&quot;</span>)) {
<a name="l01436"></a>01436          <span class="keywordflow">continue</span>;
<a name="l01437"></a>01437       }
<a name="l01438"></a>01438 
<a name="l01439"></a>01439       enumname = <a class="code" href="xml_8h.html#aa530ec72e11a97546295ede1736a1475" title="Get a node attribute by name.">ast_xml_get_attribute</a>(node, <span class="stringliteral">&quot;name&quot;</span>);
<a name="l01440"></a>01440       <span class="keywordflow">if</span> (enumname) {
<a name="l01441"></a>01441          <a class="code" href="strings_8h.html#a85cd5a8ef499e39d22b4bfeb8b9a64f7" title="Append to a thread local dynamic string.">ast_str_append</a>(buffer, 0, <span class="stringliteral">&quot;%s&lt;enum&gt;%s&lt;/enum&gt;&quot;</span>, tabs, enumname);
<a name="l01442"></a>01442          <a class="code" href="xml_8h.html#a8a555ceb9dcd4102c73aad5304ff2f34" title="Free an attribute returned by ast_xml_get_attribute().">ast_xml_free_attr</a>(enumname);
<a name="l01443"></a>01443 
<a name="l01444"></a>01444          <span class="comment">/* parse only enum elements inside a enumlist node. */</span>
<a name="l01445"></a>01445          <span class="keywordflow">if</span> ((<a class="code" href="xmldoc_8c.html#a05fdccf1393d6c6733a27f08d7b0958d">xmldoc_parse_enum</a>(node, tabs, buffer))) {
<a name="l01446"></a>01446             ret = 1;
<a name="l01447"></a>01447          } <span class="keywordflow">else</span> {
<a name="l01448"></a>01448             <a class="code" href="strings_8h.html#a85cd5a8ef499e39d22b4bfeb8b9a64f7" title="Append to a thread local dynamic string.">ast_str_append</a>(buffer, 0, <span class="stringliteral">&quot;\n&quot;</span>);
<a name="l01449"></a>01449          }
<a name="l01450"></a>01450       }
<a name="l01451"></a>01451    }
<a name="l01452"></a>01452    <span class="keywordflow">return</span> ret;
<a name="l01453"></a>01453 }
<a name="l01454"></a>01454 <span class="comment"></span>
<a name="l01455"></a>01455 <span class="comment">/*! \internal</span>
<a name="l01456"></a>01456 <span class="comment"> *  \brief Parse an &lt;option&gt; node.</span>
<a name="l01457"></a>01457 <span class="comment"> *  \param fixnode An ast_xml pointer to the &lt;option&gt; node.</span>
<a name="l01458"></a>01458 <span class="comment"> *  \param tabs A string to be appended at the begining of each line being added to the</span>
<a name="l01459"></a>01459 <span class="comment"> *              buffer string.</span>
<a name="l01460"></a>01460 <span class="comment"> *  \param buffer The output buffer.</span>
<a name="l01461"></a>01461 <span class="comment"> *  \retval 0 if no option node is parsed.</span>
<a name="l01462"></a>01462 <span class="comment"> *  \retval 1 if an option node is parsed.</span>
<a name="l01463"></a>01463 <span class="comment"> */</span>
<a name="l01464"></a><a class="code" href="xmldoc_8c.html#a2a3e24cac0951c65ba3c9e08eeb4c2df">01464</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="xmldoc_8c.html#a2a3e24cac0951c65ba3c9e08eeb4c2df">xmldoc_parse_option</a>(<span class="keyword">struct</span> ast_xml_node *fixnode, <span class="keyword">const</span> <span class="keywordtype">char</span> *tabs, <span class="keyword">struct</span> <a class="code" href="structast__str.html" title="The descriptor of a dynamic string XXX storage will be optimized later if needed...">ast_str</a> **buffer)
<a name="l01465"></a>01465 {
<a name="l01466"></a>01466    <span class="keyword">struct </span>ast_xml_node *node;
<a name="l01467"></a>01467    <span class="keywordtype">int</span> ret = 0;
<a name="l01468"></a>01468    <span class="keywordtype">char</span> *optiontabs;
<a name="l01469"></a>01469 
<a name="l01470"></a>01470    <a class="code" href="astmm_8h.html#aee6f1d27500ac19fa0b842022f987817">ast_asprintf</a>(&amp;optiontabs, <span class="stringliteral">&quot;%s    &quot;</span>, tabs);
<a name="l01471"></a>01471    <span class="keywordflow">if</span> (!optiontabs) {
<a name="l01472"></a>01472       <span class="keywordflow">return</span> ret;
<a name="l01473"></a>01473    }
<a name="l01474"></a>01474    <span class="keywordflow">for</span> (node = <a class="code" href="xml_8h.html#a6064a4b3e299bb92aa8c8c7c1b363527" title="Get the node&amp;#39;s children.">ast_xml_node_get_children</a>(fixnode); node; node = <a class="code" href="xml_8h.html#aa7d34402682c9bc1dfb9aea971f9eba7" title="Get the next node in the same level.">ast_xml_node_get_next</a>(node)) {
<a name="l01475"></a>01475       <span class="keywordflow">if</span> (!strcasecmp(<a class="code" href="xml_8h.html#a02cd60b8b2d5d96e78c858429b1b1d11" title="Get the name of a node.">ast_xml_node_get_name</a>(node), <span class="stringliteral">&quot;argument&quot;</span>)) {
<a name="l01476"></a>01476          <span class="comment">/* if this is the first data appended to buffer, print a \n*/</span>
<a name="l01477"></a>01477          <span class="keywordflow">if</span> (!ret &amp;&amp; <a class="code" href="xml_8h.html#a6064a4b3e299bb92aa8c8c7c1b363527" title="Get the node&amp;#39;s children.">ast_xml_node_get_children</a>(node)) {
<a name="l01478"></a>01478             <span class="comment">/* print \n */</span>
<a name="l01479"></a>01479             <a class="code" href="strings_8h.html#a85cd5a8ef499e39d22b4bfeb8b9a64f7" title="Append to a thread local dynamic string.">ast_str_append</a>(buffer, 0, <span class="stringliteral">&quot;\n&quot;</span>);
<a name="l01480"></a>01480          }
<a name="l01481"></a>01481          <span class="keywordflow">if</span> (<a class="code" href="xmldoc_8c.html#a9611c47bd9a6bdb174fca9fdd4f7352a">xmldoc_parse_argument</a>(node, 0, NULL, optiontabs, buffer)) {
<a name="l01482"></a>01482             ret = 1;
<a name="l01483"></a>01483          }
<a name="l01484"></a>01484          <span class="keywordflow">continue</span>;
<a name="l01485"></a>01485       }
<a name="l01486"></a>01486 
<a name="l01487"></a>01487       <span class="keywordflow">if</span> (<a class="code" href="xmldoc_8c.html#ae919d164af8a8f3e6cfbff1238a647cd">xmldoc_parse_para</a>(node, (ret ? tabs :  <span class="stringliteral">&quot;&quot;</span>), <span class="stringliteral">&quot;\n&quot;</span>, buffer)) {
<a name="l01488"></a>01488          ret = 1;
<a name="l01489"></a>01489       } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="xmldoc_8c.html#a494124315bb990544dc492592446352c">xmldoc_parse_specialtags</a>(node, (ret ? tabs :  <span class="stringliteral">&quot;&quot;</span>), <span class="stringliteral">&quot;\n&quot;</span>, buffer)) {
<a name="l01490"></a>01490          ret = 1;
<a name="l01491"></a>01491       }
<a name="l01492"></a>01492 
<a name="l01493"></a>01493       <a class="code" href="xmldoc_8c.html#a93edbb9740c7ab09ead22d614cafdad1">xmldoc_parse_variablelist</a>(node, optiontabs, buffer);
<a name="l01494"></a>01494 
<a name="l01495"></a>01495       <a class="code" href="xmldoc_8c.html#aedc9e210a0057f5e7dc9f0caf3ba86a7">xmldoc_parse_enumlist</a>(node, optiontabs, buffer);
<a name="l01496"></a>01496    }
<a name="l01497"></a>01497    <a class="code" href="astmm_8h.html#a402072d6789f6ed9e3a81da27504127e">ast_free</a>(optiontabs);
<a name="l01498"></a>01498 
<a name="l01499"></a>01499    <span class="keywordflow">return</span> ret;
<a name="l01500"></a>01500 }
<a name="l01501"></a>01501 <span class="comment"></span>
<a name="l01502"></a>01502 <span class="comment">/*! \internal</span>
<a name="l01503"></a>01503 <span class="comment"> *  \brief Parse an &lt;optionlist&gt; element from the xml documentation.</span>
<a name="l01504"></a>01504 <span class="comment"> *  \param fixnode Pointer to the optionlist xml node.</span>
<a name="l01505"></a>01505 <span class="comment"> *  \param tabs A string to be appended at the begining of each line being added to the</span>
<a name="l01506"></a>01506 <span class="comment"> *              buffer string.</span>
<a name="l01507"></a>01507 <span class="comment"> *  \param buffer Output buffer to put what is inside the optionlist tag.</span>
<a name="l01508"></a>01508 <span class="comment"> */</span>
<a name="l01509"></a><a class="code" href="xmldoc_8c.html#a1d29bebd360fb46e8dfb5de324ada128">01509</a> <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="xmldoc_8c.html#a1d29bebd360fb46e8dfb5de324ada128">xmldoc_parse_optionlist</a>(<span class="keyword">struct</span> ast_xml_node *fixnode, <span class="keyword">const</span> <span class="keywordtype">char</span> *tabs, <span class="keyword">struct</span> <a class="code" href="structast__str.html" title="The descriptor of a dynamic string XXX storage will be optimized later if needed...">ast_str</a> **buffer)
<a name="l01510"></a>01510 {
<a name="l01511"></a>01511    <span class="keyword">struct </span>ast_xml_node *node;
<a name="l01512"></a>01512    <span class="keyword">const</span> <span class="keywordtype">char</span> *optname, *hasparams;
<a name="l01513"></a>01513    <span class="keywordtype">char</span> *optionsyntax;
<a name="l01514"></a>01514    <span class="keywordtype">int</span> optparams;
<a name="l01515"></a>01515 
<a name="l01516"></a>01516    <span class="keywordflow">for</span> (node = <a class="code" href="xml_8h.html#a6064a4b3e299bb92aa8c8c7c1b363527" title="Get the node&amp;#39;s children.">ast_xml_node_get_children</a>(fixnode); node; node = <a class="code" href="xml_8h.html#aa7d34402682c9bc1dfb9aea971f9eba7" title="Get the next node in the same level.">ast_xml_node_get_next</a>(node)) {
<a name="l01517"></a>01517       <span class="comment">/* Start appending every option tag. */</span>
<a name="l01518"></a>01518       <span class="keywordflow">if</span> (strcasecmp(<a class="code" href="xml_8h.html#a02cd60b8b2d5d96e78c858429b1b1d11" title="Get the name of a node.">ast_xml_node_get_name</a>(node), <span class="stringliteral">&quot;option&quot;</span>)) {
<a name="l01519"></a>01519          <span class="keywordflow">continue</span>;
<a name="l01520"></a>01520       }
<a name="l01521"></a>01521 
<a name="l01522"></a>01522       <span class="comment">/* Get the option name. */</span>
<a name="l01523"></a>01523       optname = <a class="code" href="xml_8h.html#aa530ec72e11a97546295ede1736a1475" title="Get a node attribute by name.">ast_xml_get_attribute</a>(node, <span class="stringliteral">&quot;name&quot;</span>);
<a name="l01524"></a>01524       <span class="keywordflow">if</span> (!optname) {
<a name="l01525"></a>01525          <span class="keywordflow">continue</span>;
<a name="l01526"></a>01526       }
<a name="l01527"></a>01527 
<a name="l01528"></a>01528       optparams = 1;
<a name="l01529"></a>01529       hasparams = <a class="code" href="xml_8h.html#aa530ec72e11a97546295ede1736a1475" title="Get a node attribute by name.">ast_xml_get_attribute</a>(node, <span class="stringliteral">&quot;hasparams&quot;</span>);
<a name="l01530"></a>01530       <span class="keywordflow">if</span> (hasparams &amp;&amp; !strcasecmp(hasparams, <span class="stringliteral">&quot;optional&quot;</span>)) {
<a name="l01531"></a>01531          optparams = 2;
<a name="l01532"></a>01532       }
<a name="l01533"></a>01533 
<a name="l01534"></a>01534       optionsyntax = <a class="code" href="xmldoc_8c.html#a6cc1d90ffce561545d1d4d9e6d5a8df1">xmldoc_get_syntax_fun</a>(node, optname, <span class="stringliteral">&quot;argument&quot;</span>, 0, optparams);
<a name="l01535"></a>01535       <span class="keywordflow">if</span> (!optionsyntax) {
<a name="l01536"></a>01536          <a class="code" href="xml_8h.html#a8a555ceb9dcd4102c73aad5304ff2f34" title="Free an attribute returned by ast_xml_get_attribute().">ast_xml_free_attr</a>(optname);
<a name="l01537"></a>01537          <a class="code" href="xml_8h.html#a8a555ceb9dcd4102c73aad5304ff2f34" title="Free an attribute returned by ast_xml_get_attribute().">ast_xml_free_attr</a>(hasparams);
<a name="l01538"></a>01538          <span class="keywordflow">continue</span>;
<a name="l01539"></a>01539       }
<a name="l01540"></a>01540 
<a name="l01541"></a>01541       <a class="code" href="strings_8h.html#a85cd5a8ef499e39d22b4bfeb8b9a64f7" title="Append to a thread local dynamic string.">ast_str_append</a>(buffer, 0, <span class="stringliteral">&quot;%s%s: &quot;</span>, tabs, optionsyntax);
<a name="l01542"></a>01542 
<a name="l01543"></a>01543       <span class="keywordflow">if</span> (!<a class="code" href="xmldoc_8c.html#a2a3e24cac0951c65ba3c9e08eeb4c2df">xmldoc_parse_option</a>(node, tabs, buffer)) {
<a name="l01544"></a>01544          <a class="code" href="strings_8h.html#a85cd5a8ef499e39d22b4bfeb8b9a64f7" title="Append to a thread local dynamic string.">ast_str_append</a>(buffer, 0, <span class="stringliteral">&quot;\n&quot;</span>);
<a name="l01545"></a>01545       }
<a name="l01546"></a>01546       <a class="code" href="xml_8h.html#a8a555ceb9dcd4102c73aad5304ff2f34" title="Free an attribute returned by ast_xml_get_attribute().">ast_xml_free_attr</a>(optname);
<a name="l01547"></a>01547       <a class="code" href="xml_8h.html#a8a555ceb9dcd4102c73aad5304ff2f34" title="Free an attribute returned by ast_xml_get_attribute().">ast_xml_free_attr</a>(hasparams);
<a name="l01548"></a>01548    }
<a name="l01549"></a>01549 }
<a name="l01550"></a>01550 <span class="comment"></span>
<a name="l01551"></a>01551 <span class="comment">/*! \internal</span>
<a name="l01552"></a>01552 <span class="comment"> *  \brief Parse a &apos;parameter&apos; tag inside a syntax element.</span>
<a name="l01553"></a>01553 <span class="comment"> *  \param fixnode A pointer to the &apos;parameter&apos; xml node.</span>
<a name="l01554"></a>01554 <span class="comment"> *  \param tabs A string to be appended at the beginning of each line being printed inside</span>
<a name="l01555"></a>01555 <span class="comment"> *              &apos;buffer&apos;.</span>
<a name="l01556"></a>01556 <span class="comment"> *  \param buffer String buffer to put values found inside the parameter element.</span>
<a name="l01557"></a>01557 <span class="comment"> */</span>
<a name="l01558"></a><a class="code" href="xmldoc_8c.html#a837048ecc987ccedb98848189349f7c8">01558</a> <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="xmldoc_8c.html#a837048ecc987ccedb98848189349f7c8">xmldoc_parse_parameter</a>(<span class="keyword">struct</span> ast_xml_node *fixnode, <span class="keyword">const</span> <span class="keywordtype">char</span> *tabs, <span class="keyword">struct</span> <a class="code" href="structast__str.html" title="The descriptor of a dynamic string XXX storage will be optimized later if needed...">ast_str</a> **buffer)
<a name="l01559"></a>01559 {
<a name="l01560"></a>01560    <span class="keyword">const</span> <span class="keywordtype">char</span> *paramname;
<a name="l01561"></a>01561    <span class="keyword">struct </span>ast_xml_node *node = fixnode;
<a name="l01562"></a>01562    <span class="keywordtype">int</span> hasarguments, printed = 0;
<a name="l01563"></a>01563    <span class="keywordtype">char</span> *internaltabs;
<a name="l01564"></a>01564 
<a name="l01565"></a>01565    <span class="keywordflow">if</span> (strcasecmp(<a class="code" href="xml_8h.html#a02cd60b8b2d5d96e78c858429b1b1d11" title="Get the name of a node.">ast_xml_node_get_name</a>(node), <span class="stringliteral">&quot;parameter&quot;</span>)) {
<a name="l01566"></a>01566       <span class="keywordflow">return</span>;
<a name="l01567"></a>01567    }
<a name="l01568"></a>01568 
<a name="l01569"></a>01569    hasarguments = <a class="code" href="xmldoc_8c.html#ab9142298d52f52d3e9bf70ed451d6fdd">xmldoc_has_inside</a>(node, <span class="stringliteral">&quot;argument&quot;</span>);
<a name="l01570"></a>01570    <span class="keywordflow">if</span> (!(paramname = <a class="code" href="xml_8h.html#aa530ec72e11a97546295ede1736a1475" title="Get a node attribute by name.">ast_xml_get_attribute</a>(node, <span class="stringliteral">&quot;name&quot;</span>))) {
<a name="l01571"></a>01571       <span class="comment">/* parameter MUST have an attribute name. */</span>
<a name="l01572"></a>01572       <span class="keywordflow">return</span>;
<a name="l01573"></a>01573    }
<a name="l01574"></a>01574 
<a name="l01575"></a>01575    <a class="code" href="astmm_8h.html#aee6f1d27500ac19fa0b842022f987817">ast_asprintf</a>(&amp;internaltabs, <span class="stringliteral">&quot;%s    &quot;</span>, tabs);
<a name="l01576"></a>01576    <span class="keywordflow">if</span> (!internaltabs) {
<a name="l01577"></a>01577       <span class="keywordflow">return</span>;
<a name="l01578"></a>01578    }
<a name="l01579"></a>01579 
<a name="l01580"></a>01580    <span class="keywordflow">if</span> (!hasarguments &amp;&amp; <a class="code" href="xmldoc_8c.html#a052d764bc5bb5448d5da692e8ec9fdaa">xmldoc_has_nodes</a>(node)) {
<a name="l01581"></a>01581       <a class="code" href="strings_8h.html#a85cd5a8ef499e39d22b4bfeb8b9a64f7" title="Append to a thread local dynamic string.">ast_str_append</a>(buffer, 0, <span class="stringliteral">&quot;%s\n&quot;</span>, paramname);
<a name="l01582"></a>01582       <a class="code" href="xml_8h.html#a8a555ceb9dcd4102c73aad5304ff2f34" title="Free an attribute returned by ast_xml_get_attribute().">ast_xml_free_attr</a>(paramname);
<a name="l01583"></a>01583       printed = 1;
<a name="l01584"></a>01584    }
<a name="l01585"></a>01585 
<a name="l01586"></a>01586    <span class="keywordflow">for</span> (node = <a class="code" href="xml_8h.html#a6064a4b3e299bb92aa8c8c7c1b363527" title="Get the node&amp;#39;s children.">ast_xml_node_get_children</a>(node); node; node = <a class="code" href="xml_8h.html#aa7d34402682c9bc1dfb9aea971f9eba7" title="Get the next node in the same level.">ast_xml_node_get_next</a>(node)) {
<a name="l01587"></a>01587       <span class="keywordflow">if</span> (!strcasecmp(<a class="code" href="xml_8h.html#a02cd60b8b2d5d96e78c858429b1b1d11" title="Get the name of a node.">ast_xml_node_get_name</a>(node), <span class="stringliteral">&quot;optionlist&quot;</span>)) {
<a name="l01588"></a>01588          <a class="code" href="xmldoc_8c.html#a1d29bebd360fb46e8dfb5de324ada128">xmldoc_parse_optionlist</a>(node, internaltabs, buffer);
<a name="l01589"></a>01589       } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (!strcasecmp(<a class="code" href="xml_8h.html#a02cd60b8b2d5d96e78c858429b1b1d11" title="Get the name of a node.">ast_xml_node_get_name</a>(node), <span class="stringliteral">&quot;enumlist&quot;</span>)) {
<a name="l01590"></a>01590          <a class="code" href="xmldoc_8c.html#aedc9e210a0057f5e7dc9f0caf3ba86a7">xmldoc_parse_enumlist</a>(node, internaltabs, buffer);
<a name="l01591"></a>01591       } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (!strcasecmp(<a class="code" href="xml_8h.html#a02cd60b8b2d5d96e78c858429b1b1d11" title="Get the name of a node.">ast_xml_node_get_name</a>(node), <span class="stringliteral">&quot;argument&quot;</span>)) {
<a name="l01592"></a>01592          <a class="code" href="xmldoc_8c.html#a9611c47bd9a6bdb174fca9fdd4f7352a">xmldoc_parse_argument</a>(node, 1, internaltabs, (!hasarguments ? <span class="stringliteral">&quot;        &quot;</span> : <span class="stringliteral">&quot;&quot;</span>), buffer);
<a name="l01593"></a>01593       } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (!strcasecmp(<a class="code" href="xml_8h.html#a02cd60b8b2d5d96e78c858429b1b1d11" title="Get the name of a node.">ast_xml_node_get_name</a>(node), <span class="stringliteral">&quot;para&quot;</span>)) {
<a name="l01594"></a>01594          <span class="keywordflow">if</span> (!printed) {
<a name="l01595"></a>01595             <a class="code" href="strings_8h.html#a85cd5a8ef499e39d22b4bfeb8b9a64f7" title="Append to a thread local dynamic string.">ast_str_append</a>(buffer, 0, <span class="stringliteral">&quot;%s\n&quot;</span>, paramname);
<a name="l01596"></a>01596             <a class="code" href="xml_8h.html#a8a555ceb9dcd4102c73aad5304ff2f34" title="Free an attribute returned by ast_xml_get_attribute().">ast_xml_free_attr</a>(paramname);
<a name="l01597"></a>01597             printed = 1;
<a name="l01598"></a>01598          }
<a name="l01599"></a>01599          <a class="code" href="xmldoc_8c.html#ae919d164af8a8f3e6cfbff1238a647cd">xmldoc_parse_para</a>(node, internaltabs, <span class="stringliteral">&quot;\n&quot;</span>, buffer);
<a name="l01600"></a>01600          <span class="keywordflow">continue</span>;
<a name="l01601"></a>01601       } <span class="keywordflow">else</span> <span class="keywordflow">if</span> ((<a class="code" href="xmldoc_8c.html#a494124315bb990544dc492592446352c">xmldoc_parse_specialtags</a>(node, internaltabs, <span class="stringliteral">&quot;\n&quot;</span>, buffer))) {
<a name="l01602"></a>01602          <span class="keywordflow">continue</span>;
<a name="l01603"></a>01603       }
<a name="l01604"></a>01604    }
<a name="l01605"></a>01605    <span class="keywordflow">if</span> (!printed) {
<a name="l01606"></a>01606       <a class="code" href="xml_8h.html#a8a555ceb9dcd4102c73aad5304ff2f34" title="Free an attribute returned by ast_xml_get_attribute().">ast_xml_free_attr</a>(paramname);
<a name="l01607"></a>01607    }
<a name="l01608"></a>01608    <a class="code" href="astmm_8h.html#a402072d6789f6ed9e3a81da27504127e">ast_free</a>(internaltabs);
<a name="l01609"></a>01609 }
<a name="l01610"></a>01610 
<a name="l01611"></a><a class="code" href="xmldoc_8c.html#a54ea6bbcddbb8ef17051136a73227847">01611</a> <span class="keywordtype">char</span> *<a class="code" href="xmldoc_8h.html#a54ea6bbcddbb8ef17051136a73227847" title="Generate the [arguments] tag based on type of node (&amp;#39;application&amp;#39;, &amp;#39;function&amp;#39;...">ast_xmldoc_build_arguments</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> *<a class="code" href="evt_8c.html#a69e2889a94aeb9ac881abb82d3c22116">type</a>, <span class="keyword">const</span> <span class="keywordtype">char</span> *<a class="code" href="cdr__adaptive__odbc_8c.html#a5ac083a645d964373f022d03df4849c8">name</a>)
<a name="l01612"></a>01612 {
<a name="l01613"></a>01613    <span class="keyword">struct </span>ast_xml_node *node;
<a name="l01614"></a>01614    <span class="keyword">struct </span><a class="code" href="structast__str.html" title="The descriptor of a dynamic string XXX storage will be optimized later if needed...">ast_str</a> *ret = <a class="code" href="strings_8h.html#a8ec37e4acb6ecb20eb6f6edd1141cd76" title="Create a malloc&amp;#39;ed dynamic length string.">ast_str_create</a>(128);
<a name="l01615"></a>01615    <span class="keywordtype">char</span> *retstr = NULL;
<a name="l01616"></a>01616 
<a name="l01617"></a>01617    <span class="keywordflow">if</span> (<a class="code" href="strings_8h.html#a5c8aa5212ecb665fb072eac00c799da6">ast_strlen_zero</a>(type) || <a class="code" href="strings_8h.html#a5c8aa5212ecb665fb072eac00c799da6">ast_strlen_zero</a>(name)) {
<a name="l01618"></a>01618       <span class="keywordflow">return</span> NULL;
<a name="l01619"></a>01619    }
<a name="l01620"></a>01620 
<a name="l01621"></a>01621    node = <a class="code" href="xmldoc_8c.html#af1f439077def997dc752361c8dbdcb12">xmldoc_get_node</a>(type, name, documentation_language);
<a name="l01622"></a>01622 
<a name="l01623"></a>01623    <span class="keywordflow">if</span> (!node || !<a class="code" href="xml_8h.html#a6064a4b3e299bb92aa8c8c7c1b363527" title="Get the node&amp;#39;s children.">ast_xml_node_get_children</a>(node)) {
<a name="l01624"></a>01624       <span class="keywordflow">return</span> NULL;
<a name="l01625"></a>01625    }
<a name="l01626"></a>01626 
<a name="l01627"></a>01627    <span class="comment">/* Find the syntax field. */</span>
<a name="l01628"></a>01628    <span class="keywordflow">for</span> (node = <a class="code" href="xml_8h.html#a6064a4b3e299bb92aa8c8c7c1b363527" title="Get the node&amp;#39;s children.">ast_xml_node_get_children</a>(node); node; node = <a class="code" href="xml_8h.html#aa7d34402682c9bc1dfb9aea971f9eba7" title="Get the next node in the same level.">ast_xml_node_get_next</a>(node)) {
<a name="l01629"></a>01629       <span class="keywordflow">if</span> (!strcasecmp(<a class="code" href="xml_8h.html#a02cd60b8b2d5d96e78c858429b1b1d11" title="Get the name of a node.">ast_xml_node_get_name</a>(node), <span class="stringliteral">&quot;syntax&quot;</span>)) {
<a name="l01630"></a>01630          <span class="keywordflow">break</span>;
<a name="l01631"></a>01631       }
<a name="l01632"></a>01632    }
<a name="l01633"></a>01633 
<a name="l01634"></a>01634    <span class="keywordflow">if</span> (!node || !<a class="code" href="xml_8h.html#a6064a4b3e299bb92aa8c8c7c1b363527" title="Get the node&amp;#39;s children.">ast_xml_node_get_children</a>(node)) {
<a name="l01635"></a>01635       <span class="comment">/* We couldn&apos;t find the syntax node. */</span>
<a name="l01636"></a>01636       <span class="keywordflow">return</span> NULL;
<a name="l01637"></a>01637    }
<a name="l01638"></a>01638 
<a name="l01639"></a>01639    <span class="keywordflow">for</span> (node = <a class="code" href="xml_8h.html#a6064a4b3e299bb92aa8c8c7c1b363527" title="Get the node&amp;#39;s children.">ast_xml_node_get_children</a>(node); node; node = <a class="code" href="xml_8h.html#aa7d34402682c9bc1dfb9aea971f9eba7" title="Get the next node in the same level.">ast_xml_node_get_next</a>(node)) {
<a name="l01640"></a>01640       <a class="code" href="xmldoc_8c.html#a837048ecc987ccedb98848189349f7c8">xmldoc_parse_parameter</a>(node, <span class="stringliteral">&quot;&quot;</span>, &amp;ret);
<a name="l01641"></a>01641    }
<a name="l01642"></a>01642 
<a name="l01643"></a>01643    <span class="keywordflow">if</span> (<a class="code" href="strings_8h.html#a99409c17a1d20e1c3dc00039b7925a2d" title="Returns the current length of the string stored within buf.">ast_str_strlen</a>(ret) &gt; 0) {
<a name="l01644"></a>01644       <span class="comment">/* remove last &apos;\n&apos; */</span>
<a name="l01645"></a>01645       <span class="keywordtype">char</span> *<a class="code" href="adsistub_8c.html#aa95cbf1d00929438101e64ee5a216d0c">buf</a> = <a class="code" href="strings_8h.html#a053bdfc229997a75f112bdd7b995e00b" title="Returns the string buffer within the ast_str buf.">ast_str_buffer</a>(ret);
<a name="l01646"></a>01646       <span class="keywordflow">if</span> (buf[<a class="code" href="strings_8h.html#a99409c17a1d20e1c3dc00039b7925a2d" title="Returns the current length of the string stored within buf.">ast_str_strlen</a>(ret) - 1] == <span class="charliteral">&apos;\n&apos;</span>) {
<a name="l01647"></a>01647          <a class="code" href="strings_8h.html#a5744f4b4f751c19399c955971f36ecfa" title="Truncates the enclosed string to the given length.">ast_str_truncate</a>(ret, -1);
<a name="l01648"></a>01648       }
<a name="l01649"></a>01649       retstr = <a class="code" href="astmm_8h.html#a2ef2401ade6b4b773138a82c86c40903">ast_strdup</a>(<a class="code" href="strings_8h.html#a053bdfc229997a75f112bdd7b995e00b" title="Returns the string buffer within the ast_str buf.">ast_str_buffer</a>(ret));
<a name="l01650"></a>01650    }
<a name="l01651"></a>01651    <a class="code" href="astmm_8h.html#a402072d6789f6ed9e3a81da27504127e">ast_free</a>(ret);
<a name="l01652"></a>01652 
<a name="l01653"></a>01653    <span class="keywordflow">return</span> retstr;
<a name="l01654"></a>01654 }
<a name="l01655"></a>01655 <span class="comment"></span>
<a name="l01656"></a>01656 <span class="comment">/*! \internal</span>
<a name="l01657"></a>01657 <span class="comment"> *  \brief Return the string within a node formatted with &lt;para&gt; and &lt;variablelist&gt; elements.</span>
<a name="l01658"></a>01658 <span class="comment"> *  \param node Parent node where content resides.</span>
<a name="l01659"></a>01659 <span class="comment"> *  \param raw If set, return the node&apos;s content without further processing.</span>
<a name="l01660"></a>01660 <span class="comment"> *  \param raw_wrap Wrap raw text.</span>
<a name="l01661"></a>01661 <span class="comment"> *  \retval NULL on error</span>
<a name="l01662"></a>01662 <span class="comment"> *  \retval Node content on success.</span>
<a name="l01663"></a>01663 <span class="comment"> */</span>
<a name="l01664"></a><a class="code" href="xmldoc_8c.html#aaeae20bf7b28dd51518234b4d264f86d">01664</a> <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structast__str.html" title="The descriptor of a dynamic string XXX storage will be optimized later if needed...">ast_str</a> *<a class="code" href="xmldoc_8c.html#aaeae20bf7b28dd51518234b4d264f86d">xmldoc_get_formatted</a>(<span class="keyword">struct</span> ast_xml_node *node, <span class="keywordtype">int</span> raw_output, <span class="keywordtype">int</span> raw_wrap)
<a name="l01665"></a>01665 {
<a name="l01666"></a>01666    <span class="keyword">struct </span>ast_xml_node *tmp;
<a name="l01667"></a>01667    <span class="keyword">const</span> <span class="keywordtype">char</span> *notcleanret, *tmpstr;
<a name="l01668"></a>01668    <span class="keyword">struct </span><a class="code" href="structast__str.html" title="The descriptor of a dynamic string XXX storage will be optimized later if needed...">ast_str</a> *ret = <a class="code" href="strings_8h.html#a8ec37e4acb6ecb20eb6f6edd1141cd76" title="Create a malloc&amp;#39;ed dynamic length string.">ast_str_create</a>(128);
<a name="l01669"></a>01669 
<a name="l01670"></a>01670    <span class="keywordflow">if</span> (raw_output) {
<a name="l01671"></a>01671       notcleanret = <a class="code" href="xml_8h.html#ad113291cd96631f7b440d82fbc33dd13" title="Get an element content string.">ast_xml_get_text</a>(node);
<a name="l01672"></a>01672       tmpstr = notcleanret;
<a name="l01673"></a>01673       <a class="code" href="xmldoc_8c.html#a9b126a6b2606df7e517d382fb9565295">xmldoc_string_cleanup</a>(<a class="code" href="strings_8h.html#aba29020090d7b4238027c5746e7ad722" title="Gets a pointer to the first non-whitespace character in a string.">ast_skip_blanks</a>(notcleanret), &amp;ret, 0);
<a name="l01674"></a>01674       <a class="code" href="xml_8h.html#ae428c2b44d463e2fe692360f4d530cdb" title="Free a content element that was returned by ast_xml_get_text().">ast_xml_free_text</a>(tmpstr);
<a name="l01675"></a>01675    } <span class="keywordflow">else</span> {
<a name="l01676"></a>01676       <span class="keywordflow">for</span> (tmp = <a class="code" href="xml_8h.html#a6064a4b3e299bb92aa8c8c7c1b363527" title="Get the node&amp;#39;s children.">ast_xml_node_get_children</a>(node); tmp; tmp = <a class="code" href="xml_8h.html#aa7d34402682c9bc1dfb9aea971f9eba7" title="Get the next node in the same level.">ast_xml_node_get_next</a>(tmp)) {
<a name="l01677"></a>01677          <span class="comment">/* if found, parse a &lt;para&gt; element. */</span>
<a name="l01678"></a>01678          <span class="keywordflow">if</span> (<a class="code" href="xmldoc_8c.html#ae919d164af8a8f3e6cfbff1238a647cd">xmldoc_parse_para</a>(tmp, <span class="stringliteral">&quot;&quot;</span>, <span class="stringliteral">&quot;\n&quot;</span>, &amp;ret)) {
<a name="l01679"></a>01679             <span class="keywordflow">continue</span>;
<a name="l01680"></a>01680          } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="xmldoc_8c.html#a494124315bb990544dc492592446352c">xmldoc_parse_specialtags</a>(tmp, <span class="stringliteral">&quot;&quot;</span>, <span class="stringliteral">&quot;\n&quot;</span>, &amp;ret)) {
<a name="l01681"></a>01681             <span class="keywordflow">continue</span>;
<a name="l01682"></a>01682          }
<a name="l01683"></a>01683          <span class="comment">/* if found, parse a &lt;variablelist&gt; element. */</span>
<a name="l01684"></a>01684          <a class="code" href="xmldoc_8c.html#a93edbb9740c7ab09ead22d614cafdad1">xmldoc_parse_variablelist</a>(tmp, <span class="stringliteral">&quot;&quot;</span>, &amp;ret);
<a name="l01685"></a>01685          <a class="code" href="xmldoc_8c.html#aedc9e210a0057f5e7dc9f0caf3ba86a7">xmldoc_parse_enumlist</a>(tmp, <span class="stringliteral">&quot;    &quot;</span>, &amp;ret);
<a name="l01686"></a>01686       }
<a name="l01687"></a>01687       <span class="comment">/* remove last &apos;\n&apos; */</span>
<a name="l01688"></a>01688       <span class="comment">/* XXX Don&apos;t modify ast_str internals manually */</span>
<a name="l01689"></a>01689       tmpstr = <a class="code" href="strings_8h.html#a053bdfc229997a75f112bdd7b995e00b" title="Returns the string buffer within the ast_str buf.">ast_str_buffer</a>(ret);
<a name="l01690"></a>01690       <span class="keywordflow">if</span> (tmpstr[<a class="code" href="strings_8h.html#a99409c17a1d20e1c3dc00039b7925a2d" title="Returns the current length of the string stored within buf.">ast_str_strlen</a>(ret) - 1] == <span class="charliteral">&apos;\n&apos;</span>) {
<a name="l01691"></a>01691          <a class="code" href="strings_8h.html#a5744f4b4f751c19399c955971f36ecfa" title="Truncates the enclosed string to the given length.">ast_str_truncate</a>(ret, -1);
<a name="l01692"></a>01692       }
<a name="l01693"></a>01693    }
<a name="l01694"></a>01694    <span class="keywordflow">return</span> ret;
<a name="l01695"></a>01695 }
<a name="l01696"></a>01696 <span class="comment"></span>
<a name="l01697"></a>01697 <span class="comment">/*!</span>
<a name="l01698"></a>01698 <span class="comment"> *  \brief Get the content of a field (synopsis, description, etc) from an asterisk document tree</span>
<a name="l01699"></a>01699 <span class="comment"> *  \param type Type of element (application, function, ...).</span>
<a name="l01700"></a>01700 <span class="comment"> *  \param name Name of element (Dial, Echo, Playback, ...).</span>
<a name="l01701"></a>01701 <span class="comment"> *  \param var Name of field to return (synopsis, description, etc).</span>
<a name="l01702"></a>01702 <span class="comment"> *  \param raw Field only contains text, no other elements inside it.</span>
<a name="l01703"></a>01703 <span class="comment"> *  \retval NULL On error.</span>
<a name="l01704"></a>01704 <span class="comment"> *  \retval Field text content on success.</span>
<a name="l01705"></a>01705 <span class="comment"> */</span>
<a name="l01706"></a><a class="code" href="xmldoc_8c.html#aeb2341b29c15727e507610b6abc7e18e">01706</a> <span class="keyword">static</span> <span class="keywordtype">char</span> *<a class="code" href="xmldoc_8c.html#aeb2341b29c15727e507610b6abc7e18e" title="Get the content of a field (synopsis, description, etc) from an asterisk document...">xmldoc_build_field</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> *<a class="code" href="evt_8c.html#a69e2889a94aeb9ac881abb82d3c22116">type</a>, <span class="keyword">const</span> <span class="keywordtype">char</span> *<a class="code" href="cdr__adaptive__odbc_8c.html#a5ac083a645d964373f022d03df4849c8">name</a>, <span class="keyword">const</span> <span class="keywordtype">char</span> *<a class="code" href="ast__expr2f_8c.html#a1b0936415a643c88ce543099c10e0d7f">var</a>, <span class="keywordtype">int</span> raw)
<a name="l01707"></a>01707 {
<a name="l01708"></a>01708    <span class="keyword">struct </span>ast_xml_node *node;
<a name="l01709"></a>01709    <span class="keywordtype">char</span> *ret = NULL;
<a name="l01710"></a>01710    <span class="keyword">struct </span><a class="code" href="structast__str.html" title="The descriptor of a dynamic string XXX storage will be optimized later if needed...">ast_str</a> *formatted;
<a name="l01711"></a>01711 
<a name="l01712"></a>01712    <span class="keywordflow">if</span> (<a class="code" href="strings_8h.html#a5c8aa5212ecb665fb072eac00c799da6">ast_strlen_zero</a>(type) || <a class="code" href="strings_8h.html#a5c8aa5212ecb665fb072eac00c799da6">ast_strlen_zero</a>(name)) {
<a name="l01713"></a>01713       <a class="code" href="logger_8h.html#a93dd824dff97fe84941d6d71b7a3710e" title="Used for sending a log message This is the standard logger function. Probably the...">ast_log</a>(<a class="code" href="logger_8h.html#aced66975c154ea0e2a8ec3bc818b4e08">LOG_ERROR</a>, <span class="stringliteral">&quot;Tried to look in XML tree with faulty values.\n&quot;</span>);
<a name="l01714"></a>01714       <span class="keywordflow">return</span> ret;
<a name="l01715"></a>01715    }
<a name="l01716"></a>01716 
<a name="l01717"></a>01717    node = <a class="code" href="xmldoc_8c.html#af1f439077def997dc752361c8dbdcb12">xmldoc_get_node</a>(type, name, documentation_language);
<a name="l01718"></a>01718 
<a name="l01719"></a>01719    <span class="keywordflow">if</span> (!node) {
<a name="l01720"></a>01720       <a class="code" href="logger_8h.html#a93dd824dff97fe84941d6d71b7a3710e" title="Used for sending a log message This is the standard logger function. Probably the...">ast_log</a>(<a class="code" href="logger_8h.html#adf4476a6a4ea6c74231c826e899d7189">LOG_WARNING</a>, <span class="stringliteral">&quot;Counldn&apos;t find %s %s in XML documentation\n&quot;</span>, type, name);
<a name="l01721"></a>01721       <span class="keywordflow">return</span> ret;
<a name="l01722"></a>01722    }
<a name="l01723"></a>01723 
<a name="l01724"></a>01724    node = <a class="code" href="xml_8h.html#a8299a9da6d1e609761341b3ca45bc771" title="Find a node element by name.">ast_xml_find_element</a>(<a class="code" href="xml_8h.html#a6064a4b3e299bb92aa8c8c7c1b363527" title="Get the node&amp;#39;s children.">ast_xml_node_get_children</a>(node), var, NULL, NULL);
<a name="l01725"></a>01725 
<a name="l01726"></a>01726    <span class="keywordflow">if</span> (!node || !<a class="code" href="xml_8h.html#a6064a4b3e299bb92aa8c8c7c1b363527" title="Get the node&amp;#39;s children.">ast_xml_node_get_children</a>(node)) {
<a name="l01727"></a>01727       <a class="code" href="logger_8h.html#a93dd824dff97fe84941d6d71b7a3710e" title="Used for sending a log message This is the standard logger function. Probably the...">ast_log</a>(<a class="code" href="logger_8h.html#a6ff63e8955665c4a58b1598f2b07c51a">LOG_DEBUG</a>, <span class="stringliteral">&quot;Cannot find variable &apos;%s&apos; in tree &apos;%s&apos;\n&quot;</span>, name, var);
<a name="l01728"></a>01728       <span class="keywordflow">return</span> ret;
<a name="l01729"></a>01729    }
<a name="l01730"></a>01730 
<a name="l01731"></a>01731    formatted = <a class="code" href="xmldoc_8c.html#aaeae20bf7b28dd51518234b4d264f86d">xmldoc_get_formatted</a>(node, raw, raw);
<a name="l01732"></a>01732    <span class="keywordflow">if</span> (<a class="code" href="strings_8h.html#a99409c17a1d20e1c3dc00039b7925a2d" title="Returns the current length of the string stored within buf.">ast_str_strlen</a>(formatted) &gt; 0) {
<a name="l01733"></a>01733       ret = <a class="code" href="astmm_8h.html#a2ef2401ade6b4b773138a82c86c40903">ast_strdup</a>(<a class="code" href="strings_8h.html#a053bdfc229997a75f112bdd7b995e00b" title="Returns the string buffer within the ast_str buf.">ast_str_buffer</a>(formatted));
<a name="l01734"></a>01734    }
<a name="l01735"></a>01735    <a class="code" href="astmm_8h.html#a402072d6789f6ed9e3a81da27504127e">ast_free</a>(formatted);
<a name="l01736"></a>01736 
<a name="l01737"></a>01737    <span class="keywordflow">return</span> ret;
<a name="l01738"></a>01738 }
<a name="l01739"></a>01739 
<a name="l01740"></a><a class="code" href="xmldoc_8c.html#a92ab99fc2fa8a31c591531b36d391e3f">01740</a> <span class="keywordtype">char</span> *<a class="code" href="xmldoc_8h.html#a92ab99fc2fa8a31c591531b36d391e3f" title="Generate synopsis documentation from XML.">ast_xmldoc_build_synopsis</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> *<a class="code" href="evt_8c.html#a69e2889a94aeb9ac881abb82d3c22116">type</a>, <span class="keyword">const</span> <span class="keywordtype">char</span> *<a class="code" href="cdr__adaptive__odbc_8c.html#a5ac083a645d964373f022d03df4849c8">name</a>)
<a name="l01741"></a>01741 {
<a name="l01742"></a>01742    <span class="keywordflow">return</span> <a class="code" href="xmldoc_8c.html#aeb2341b29c15727e507610b6abc7e18e" title="Get the content of a field (synopsis, description, etc) from an asterisk document...">xmldoc_build_field</a>(type, name, <span class="stringliteral">&quot;synopsis&quot;</span>, 1);
<a name="l01743"></a>01743 }
<a name="l01744"></a>01744 
<a name="l01745"></a><a class="code" href="xmldoc_8c.html#a7e6109ee5ae553d1fb3b6e7a7c4617f9">01745</a> <span class="keywordtype">char</span> *<a class="code" href="xmldoc_8h.html#a7e6109ee5ae553d1fb3b6e7a7c4617f9" title="Generate description documentation from XML.">ast_xmldoc_build_description</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> *<a class="code" href="evt_8c.html#a69e2889a94aeb9ac881abb82d3c22116">type</a>, <span class="keyword">const</span> <span class="keywordtype">char</span> *<a class="code" href="cdr__adaptive__odbc_8c.html#a5ac083a645d964373f022d03df4849c8">name</a>)
<a name="l01746"></a>01746 {
<a name="l01747"></a>01747    <span class="keywordflow">return</span> <a class="code" href="xmldoc_8c.html#aeb2341b29c15727e507610b6abc7e18e" title="Get the content of a field (synopsis, description, etc) from an asterisk document...">xmldoc_build_field</a>(type, name, <span class="stringliteral">&quot;description&quot;</span>, 0);
<a name="l01748"></a>01748 }
<a name="l01749"></a>01749 <span class="comment"></span>
<a name="l01750"></a>01750 <span class="comment">/*! \brief Close and unload XML documentation. */</span>
<a name="l01751"></a><a class="code" href="xmldoc_8c.html#acd85ffaccedee3cb1300470803523372">01751</a> <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="xmldoc_8c.html#acd85ffaccedee3cb1300470803523372" title="Close and unload XML documentation.">xmldoc_unload_documentation</a>(<span class="keywordtype">void</span>)
<a name="l01752"></a>01752 {
<a name="l01753"></a>01753         <span class="keyword">struct </span><a class="code" href="structdocumentation__tree.html" title="XML documentation tree.">documentation_tree</a> *doctree;
<a name="l01754"></a>01754 
<a name="l01755"></a>01755    <a class="code" href="linkedlists_8h.html#a2d0cf4182bade9f773fb16ff12abe595" title="Write locks a list.">AST_RWLIST_WRLOCK</a>(&amp;<a class="code" href="structxmldoc__tree.html" title="Container of documentation trees.">xmldoc_tree</a>);
<a name="l01756"></a>01756    <span class="keywordflow">while</span> ((doctree = <a class="code" href="linkedlists_8h.html#a3d3aa4fb3b4ba38ad8d6d255d97e037c">AST_RWLIST_REMOVE_HEAD</a>(&amp;<a class="code" href="structxmldoc__tree.html" title="Container of documentation trees.">xmldoc_tree</a>, <a class="code" href="structdocumentation__tree.html#a9770eb03f735793008007de780d8b2f1">entry</a>))) {
<a name="l01757"></a>01757       <a class="code" href="astmm_8h.html#a402072d6789f6ed9e3a81da27504127e">ast_free</a>(doctree-&gt;<a class="code" href="structdocumentation__tree.html#aeac90097f29f7529968697163cea5c18">filename</a>);
<a name="l01758"></a>01758       <a class="code" href="xml_8h.html#a7bd620a640086cdcbb20610259af6bd1" title="Close an already open document and free the used structure.">ast_xml_close</a>(doctree-&gt;<a class="code" href="structdocumentation__tree.html#a8702ea03f4a7d2e0bcca01893d9dd5a6">doc</a>);
<a name="l01759"></a>01759    }
<a name="l01760"></a>01760    <a class="code" href="linkedlists_8h.html#a2e9a2518b5029b96671aff6701bd5138" title="Attempts to unlock a read/write based list.">AST_RWLIST_UNLOCK</a>(&amp;<a class="code" href="structxmldoc__tree.html" title="Container of documentation trees.">xmldoc_tree</a>);
<a name="l01761"></a>01761 
<a name="l01762"></a>01762    <a class="code" href="xml_8h.html#a864e1035333a61b96b79b1297faaabdc" title="Cleanup library allocated global data.">ast_xml_finish</a>();
<a name="l01763"></a>01763 }
<a name="l01764"></a>01764 
<a name="l01765"></a><a class="code" href="xmldoc_8c.html#a9069f9a0490be2b041ca552ef07757f0">01765</a> <span class="keywordtype">int</span> <a class="code" href="__private_8h.html#a9069f9a0490be2b041ca552ef07757f0" title="Load XML documentation. Provided by xmldoc.c.">ast_xmldoc_load_documentation</a>(<span class="keywordtype">void</span>)
<a name="l01766"></a>01766 {
<a name="l01767"></a>01767    <span class="keyword">struct </span>ast_xml_node *root_node;
<a name="l01768"></a>01768    <span class="keyword">struct </span>ast_xml_doc *tmpdoc;
<a name="l01769"></a>01769    <span class="keyword">struct </span><a class="code" href="structdocumentation__tree.html" title="XML documentation tree.">documentation_tree</a> *doc_tree;
<a name="l01770"></a>01770    <span class="keywordtype">char</span> *xmlpattern;
<a name="l01771"></a>01771    <span class="keyword">struct </span><a class="code" href="structast__config.html">ast_config</a> *cfg = NULL;
<a name="l01772"></a>01772    <span class="keyword">struct </span><a class="code" href="structast__variable.html" title="Structure for variables, used for configurations and for channel variables.">ast_variable</a> *<a class="code" href="ast__expr2f_8c.html#a1b0936415a643c88ce543099c10e0d7f">var</a> = NULL;
<a name="l01773"></a>01773    <span class="keyword">struct </span><a class="code" href="structast__flags.html" title="Structure used to handle boolean flags.">ast_flags</a> cnfflags = { 0 };
<a name="l01774"></a>01774    <span class="keywordtype">int</span> globret, i, dup, duplicate;
<a name="l01775"></a>01775    glob_t globbuf;
<a name="l01776"></a>01776 
<a name="l01777"></a>01777    <span class="comment">/* setup default XML documentation language */</span>
<a name="l01778"></a>01778    snprintf(documentation_language, <span class="keyword">sizeof</span>(documentation_language), default_documentation_language);
<a name="l01779"></a>01779 
<a name="l01780"></a>01780    <span class="keywordflow">if</span> ((cfg = <a class="code" href="config_8h.html#aab3eac8fa82a86a93c074deb7b77dbc9" title="Load a config file.">ast_config_load2</a>(<span class="stringliteral">&quot;asterisk.conf&quot;</span>, <span class="stringliteral">&quot;&quot;</span> <span class="comment">/* core can&apos;t reload */</span>, cnfflags)) &amp;&amp; cfg != <a class="code" href="config_8h.html#a8d1a63cdf2c7aff22a77b6e75d93b377">CONFIG_STATUS_FILEINVALID</a>) {
<a name="l01781"></a>01781       <span class="keywordflow">for</span> (var = <a class="code" href="config_8h.html#a935ccfa153100ddd320c8918bd6e941b" title="Goes through variables Somewhat similar in intent as the ast_category_browse. List...">ast_variable_browse</a>(cfg, <span class="stringliteral">&quot;options&quot;</span>); var; var = var-&gt;<a class="code" href="structast__variable.html#a46f18867e3894852bc489a4cd9cfa516">next</a>) {
<a name="l01782"></a>01782          <span class="keywordflow">if</span> (!strcasecmp(var-&gt;<a class="code" href="structast__variable.html#a8f8f80d37794cde9472343e4487ba3eb">name</a>, <span class="stringliteral">&quot;documentation_language&quot;</span>)) {
<a name="l01783"></a>01783             <span class="keywordflow">if</span> (!<a class="code" href="strings_8h.html#a5c8aa5212ecb665fb072eac00c799da6">ast_strlen_zero</a>(var-&gt;<a class="code" href="structast__variable.html#a8556878012feffc9e0beb86cd78f424d">value</a>)) {
<a name="l01784"></a>01784                snprintf(documentation_language, <span class="keyword">sizeof</span>(documentation_language), <span class="stringliteral">&quot;%s&quot;</span>, var-&gt;<a class="code" href="structast__variable.html#a8556878012feffc9e0beb86cd78f424d">value</a>);
<a name="l01785"></a>01785             }
<a name="l01786"></a>01786          }
<a name="l01787"></a>01787       }
<a name="l01788"></a>01788       <a class="code" href="config_8h.html#a710f0b2a897849572b77dd0854b8dc03" title="Destroys a config.">ast_config_destroy</a>(cfg);
<a name="l01789"></a>01789    }
<a name="l01790"></a>01790 
<a name="l01791"></a>01791    <span class="comment">/* initialize the XML library. */</span>
<a name="l01792"></a>01792    <a class="code" href="xml_8h.html#ae7775b891369b2025497d68c1ec2b8b6" title="Initialize the XML library implementation. This function is used to setup everything...">ast_xml_init</a>();
<a name="l01793"></a>01793 
<a name="l01794"></a>01794    <span class="comment">/* register function to be run when asterisk finish. */</span>
<a name="l01795"></a>01795    <a class="code" href="asterisk_8h.html#a9b09e95876dfecb9a8573819da0b255e" title="Register a function to be executed before Asterisk exits.">ast_register_atexit</a>(<a class="code" href="xmldoc_8c.html#acd85ffaccedee3cb1300470803523372" title="Close and unload XML documentation.">xmldoc_unload_documentation</a>);
<a name="l01796"></a>01796 
<a name="l01797"></a>01797    <span class="comment">/* Get every *-LANG.xml file inside $(ASTDATADIR)/documentation */</span>
<a name="l01798"></a>01798    <a class="code" href="astmm_8h.html#aee6f1d27500ac19fa0b842022f987817">ast_asprintf</a>(&amp;xmlpattern, <span class="stringliteral">&quot;%s/documentation{/thirdparty/,/}*-{%s,%.2s_??,%s}.xml&quot;</span>, <a class="code" href="paths_8h.html#a63af4213b5b83f717398d8d62008a50d">ast_config_AST_DATA_DIR</a>,
<a name="l01799"></a>01799          documentation_language, documentation_language, default_documentation_language);
<a name="l01800"></a>01800    globbuf.gl_offs = 0;    <span class="comment">/* initialize it to silence gcc */</span>
<a name="l01801"></a>01801    globret = glob(xmlpattern, <a class="code" href="compat_8h.html#aaac7e52043ca7fcf7113eaaf95f6e3b7">MY_GLOB_FLAGS</a>, NULL, &amp;globbuf);
<a name="l01802"></a>01802    <span class="keywordflow">if</span> (globret == GLOB_NOSPACE) {
<a name="l01803"></a>01803       <a class="code" href="logger_8h.html#a93dd824dff97fe84941d6d71b7a3710e" title="Used for sending a log message This is the standard logger function. Probably the...">ast_log</a>(<a class="code" href="logger_8h.html#adf4476a6a4ea6c74231c826e899d7189">LOG_WARNING</a>, <span class="stringliteral">&quot;Glob Expansion of pattern &apos;%s&apos; failed: Not enough memory\n&quot;</span>, xmlpattern);
<a name="l01804"></a>01804       <a class="code" href="astmm_8h.html#a402072d6789f6ed9e3a81da27504127e">ast_free</a>(xmlpattern);
<a name="l01805"></a>01805       <span class="keywordflow">return</span> 1;
<a name="l01806"></a>01806    } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (globret  == <a class="code" href="ael__lex_8c.html#ab5de50cedafa21283878657d05fb2ba8">GLOB_ABORTED</a>) {
<a name="l01807"></a>01807       <a class="code" href="logger_8h.html#a93dd824dff97fe84941d6d71b7a3710e" title="Used for sending a log message This is the standard logger function. Probably the...">ast_log</a>(<a class="code" href="logger_8h.html#adf4476a6a4ea6c74231c826e899d7189">LOG_WARNING</a>, <span class="stringliteral">&quot;Glob Expansion of pattern &apos;%s&apos; failed: Read error\n&quot;</span>, xmlpattern);
<a name="l01808"></a>01808       <a class="code" href="astmm_8h.html#a402072d6789f6ed9e3a81da27504127e">ast_free</a>(xmlpattern);
<a name="l01809"></a>01809       <span class="keywordflow">return</span> 1;
<a name="l01810"></a>01810    }
<a name="l01811"></a>01811    <a class="code" href="astmm_8h.html#a402072d6789f6ed9e3a81da27504127e">ast_free</a>(xmlpattern);
<a name="l01812"></a>01812 
<a name="l01813"></a>01813    <a class="code" href="linkedlists_8h.html#a2d0cf4182bade9f773fb16ff12abe595" title="Write locks a list.">AST_RWLIST_WRLOCK</a>(&amp;<a class="code" href="structxmldoc__tree.html" title="Container of documentation trees.">xmldoc_tree</a>);
<a name="l01814"></a>01814    <span class="comment">/* loop over expanded files */</span>
<a name="l01815"></a>01815    <span class="keywordflow">for</span> (i = 0; i &lt; globbuf.gl_pathc; i++) {
<a name="l01816"></a>01816       <span class="comment">/* check for duplicates (if we already [try to] open the same file. */</span>
<a name="l01817"></a>01817       duplicate = 0;
<a name="l01818"></a>01818       <span class="keywordflow">for</span> (dup = 0; dup &lt; i; dup++) {
<a name="l01819"></a>01819          <span class="keywordflow">if</span> (!strcmp(globbuf.gl_pathv[i], globbuf.gl_pathv[dup])) {
<a name="l01820"></a>01820             duplicate = 1;
<a name="l01821"></a>01821             <span class="keywordflow">break</span>;
<a name="l01822"></a>01822          }
<a name="l01823"></a>01823       }
<a name="l01824"></a>01824       <span class="keywordflow">if</span> (duplicate) {
<a name="l01825"></a>01825          <span class="keywordflow">continue</span>;
<a name="l01826"></a>01826       }
<a name="l01827"></a>01827       tmpdoc = NULL;
<a name="l01828"></a>01828       tmpdoc = <a class="code" href="xml_8h.html#a3e397160644166df4830521d1dc07272" title="Open an XML document.">ast_xml_open</a>(globbuf.gl_pathv[i]);
<a name="l01829"></a>01829       <span class="keywordflow">if</span> (!tmpdoc) {
<a name="l01830"></a>01830          <a class="code" href="logger_8h.html#a93dd824dff97fe84941d6d71b7a3710e" title="Used for sending a log message This is the standard logger function. Probably the...">ast_log</a>(<a class="code" href="logger_8h.html#aced66975c154ea0e2a8ec3bc818b4e08">LOG_ERROR</a>, <span class="stringliteral">&quot;Could not open XML documentation at &apos;%s&apos;\n&quot;</span>, globbuf.gl_pathv[i]);
<a name="l01831"></a>01831          <span class="keywordflow">continue</span>;
<a name="l01832"></a>01832       }
<a name="l01833"></a>01833       <span class="comment">/* Get doc root node and check if it starts with &apos;&lt;docs&gt;&apos; */</span>
<a name="l01834"></a>01834       root_node = <a class="code" href="xml_8h.html#af84bcc8281d822193294dcadd247ac75" title="Get the document root node.">ast_xml_get_root</a>(tmpdoc);
<a name="l01835"></a>01835       <span class="keywordflow">if</span> (!root_node) {
<a name="l01836"></a>01836          <a class="code" href="logger_8h.html#a93dd824dff97fe84941d6d71b7a3710e" title="Used for sending a log message This is the standard logger function. Probably the...">ast_log</a>(<a class="code" href="logger_8h.html#aced66975c154ea0e2a8ec3bc818b4e08">LOG_ERROR</a>, <span class="stringliteral">&quot;Error getting documentation root node&quot;</span>);
<a name="l01837"></a>01837          <a class="code" href="xml_8h.html#a7bd620a640086cdcbb20610259af6bd1" title="Close an already open document and free the used structure.">ast_xml_close</a>(tmpdoc);
<a name="l01838"></a>01838          <span class="keywordflow">continue</span>;
<a name="l01839"></a>01839       }
<a name="l01840"></a>01840       <span class="comment">/* Check root node name for malformed xmls. */</span>
<a name="l01841"></a>01841       <span class="keywordflow">if</span> (strcmp(<a class="code" href="xml_8h.html#a02cd60b8b2d5d96e78c858429b1b1d11" title="Get the name of a node.">ast_xml_node_get_name</a>(root_node), <span class="stringliteral">&quot;docs&quot;</span>)) {
<a name="l01842"></a>01842          <a class="code" href="logger_8h.html#a93dd824dff97fe84941d6d71b7a3710e" title="Used for sending a log message This is the standard logger function. Probably the...">ast_log</a>(<a class="code" href="logger_8h.html#aced66975c154ea0e2a8ec3bc818b4e08">LOG_ERROR</a>, <span class="stringliteral">&quot;Documentation file is not well formed!\n&quot;</span>);
<a name="l01843"></a>01843          <a class="code" href="xml_8h.html#a7bd620a640086cdcbb20610259af6bd1" title="Close an already open document and free the used structure.">ast_xml_close</a>(tmpdoc);
<a name="l01844"></a>01844          <span class="keywordflow">continue</span>;
<a name="l01845"></a>01845       }
<a name="l01846"></a>01846       doc_tree = <a class="code" href="astmm_8h.html#a1cb33b63d94fbbde94234b062249e015">ast_calloc</a>(1, <span class="keyword">sizeof</span>(*doc_tree));
<a name="l01847"></a>01847       <span class="keywordflow">if</span> (!doc_tree) {
<a name="l01848"></a>01848          <a class="code" href="logger_8h.html#a93dd824dff97fe84941d6d71b7a3710e" title="Used for sending a log message This is the standard logger function. Probably the...">ast_log</a>(<a class="code" href="logger_8h.html#aced66975c154ea0e2a8ec3bc818b4e08">LOG_ERROR</a>, <span class="stringliteral">&quot;Unable to allocate documentation_tree structure!\n&quot;</span>);
<a name="l01849"></a>01849          <a class="code" href="xml_8h.html#a7bd620a640086cdcbb20610259af6bd1" title="Close an already open document and free the used structure.">ast_xml_close</a>(tmpdoc);
<a name="l01850"></a>01850          <span class="keywordflow">continue</span>;
<a name="l01851"></a>01851       }
<a name="l01852"></a>01852       doc_tree-&gt;<a class="code" href="structdocumentation__tree.html#a8702ea03f4a7d2e0bcca01893d9dd5a6">doc</a> = tmpdoc;
<a name="l01853"></a>01853       doc_tree-&gt;<a class="code" href="structdocumentation__tree.html#aeac90097f29f7529968697163cea5c18">filename</a> = <a class="code" href="astmm_8h.html#a2ef2401ade6b4b773138a82c86c40903">ast_strdup</a>(globbuf.gl_pathv[i]);
<a name="l01854"></a>01854       <a class="code" href="linkedlists_8h.html#aadda916488b2d151af4426e2f06ad332">AST_RWLIST_INSERT_TAIL</a>(&amp;<a class="code" href="structxmldoc__tree.html" title="Container of documentation trees.">xmldoc_tree</a>, doc_tree, <a class="code" href="structdocumentation__tree.html#a9770eb03f735793008007de780d8b2f1">entry</a>);
<a name="l01855"></a>01855    }
<a name="l01856"></a>01856    <a class="code" href="linkedlists_8h.html#a2e9a2518b5029b96671aff6701bd5138" title="Attempts to unlock a read/write based list.">AST_RWLIST_UNLOCK</a>(&amp;<a class="code" href="structxmldoc__tree.html" title="Container of documentation trees.">xmldoc_tree</a>);
<a name="l01857"></a>01857 
<a name="l01858"></a>01858    globfree(&amp;globbuf);
<a name="l01859"></a>01859 
<a name="l01860"></a>01860    <span class="keywordflow">return</span> 0;
<a name="l01861"></a>01861 }
<a name="l01862"></a>01862 
<a name="l01863"></a>01863 <span class="preprocessor">#endif </span><span class="comment">/* AST_XML_DOCS */</span>
<a name="l01864"></a>01864 
<a name="l01865"></a>01865 
</pre></div></div>
<hr size="1"/><address style="text-align: right;"><small>Generated on Wed May 5 15:18:49 2010 for Asterisk - the Open Source PBX by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.1 </small></address>
</body>
</html>
