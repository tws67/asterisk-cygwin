<HTML>
    <HEAD>
      <TITLE>Asterisk.org: Developer Documentation (5 May 2010)</TITLE>
      <LINK HREF="doxygen.css" REL="stylesheet" TYPE="text/css">
    </HEAD>
    <BODY BGCOLOR="#FFFFFF">
<div><font size="2" align="right">Wed May 5 15:18:29 2010</font></div>

<h2>Asterisk developer's documentation</h2>
<hr/>
<!-- Generated by Doxygen 1.6.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
  <div class="navpath"><a class="el" href="dir_1ab815038f534adda65c8b4ae4993449.html">include</a>&nbsp;&raquo&nbsp;<a class="el" href="dir_16d825f1fa9ecca2e70b1a8d9256d0e6.html">asterisk</a>
  </div>
</div>
<div class="contents">
<h1>astobj2.h</h1><a href="astobj2_8h.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">/*</span>
<a name="l00002"></a>00002 <span class="comment"> * astobj2 - replacement containers for asterisk data structures.</span>
<a name="l00003"></a>00003 <span class="comment"> *</span>
<a name="l00004"></a>00004 <span class="comment"> * Copyright (C) 2006 Marta Carbone, Luigi Rizzo - Univ. di Pisa, Italy</span>
<a name="l00005"></a>00005 <span class="comment"> *</span>
<a name="l00006"></a>00006 <span class="comment"> * See http://www.asterisk.org for more information about</span>
<a name="l00007"></a>00007 <span class="comment"> * the Asterisk project. Please do not directly contact</span>
<a name="l00008"></a>00008 <span class="comment"> * any of the maintainers of this project for assistance;</span>
<a name="l00009"></a>00009 <span class="comment"> * the project provides a web site, mailing lists and IRC</span>
<a name="l00010"></a>00010 <span class="comment"> * channels for your use.</span>
<a name="l00011"></a>00011 <span class="comment"> *</span>
<a name="l00012"></a>00012 <span class="comment"> * This program is free software, distributed under the terms of</span>
<a name="l00013"></a>00013 <span class="comment"> * the GNU General Public License Version 2. See the LICENSE file</span>
<a name="l00014"></a>00014 <span class="comment"> * at the top of the source tree.</span>
<a name="l00015"></a>00015 <span class="comment"> */</span>
<a name="l00016"></a>00016 
<a name="l00017"></a>00017 <span class="preprocessor">#ifndef _ASTERISK_ASTOBJ2_H</span>
<a name="l00018"></a>00018 <span class="preprocessor"></span><span class="preprocessor">#define _ASTERISK_ASTOBJ2_H</span>
<a name="l00019"></a>00019 <span class="preprocessor"></span>
<a name="l00020"></a>00020 <span class="preprocessor">#include &quot;<a class="code" href="compat_8h.html" title="General Definitions for Asterisk top level program Included by asterisk.h to handle...">asterisk/compat.h</a>&quot;</span>
<a name="l00021"></a>00021 <span class="comment"></span>
<a name="l00022"></a>00022 <span class="comment">/*! \file</span>
<a name="l00023"></a>00023 <span class="comment"> * \ref AstObj2</span>
<a name="l00024"></a>00024 <span class="comment"> *</span>
<a name="l00025"></a>00025 <span class="comment"> * \page AstObj2 Object Model implementing objects and containers.</span>
<a name="l00026"></a>00026 <span class="comment"></span>
<a name="l00027"></a>00027 <span class="comment">This module implements an abstraction for objects (with locks and</span>
<a name="l00028"></a>00028 <span class="comment">reference counts), and containers for these user-defined objects,</span>
<a name="l00029"></a>00029 <span class="comment">also supporting locking, reference counting and callbacks.</span>
<a name="l00030"></a>00030 <span class="comment"></span>
<a name="l00031"></a>00031 <span class="comment">The internal implementation of objects and containers is opaque to the user,</span>
<a name="l00032"></a>00032 <span class="comment">so we can use different data structures as needs arise.</span>
<a name="l00033"></a>00033 <span class="comment"></span>
<a name="l00034"></a>00034 <span class="comment">\section AstObj2_UsageObjects USAGE - OBJECTS</span>
<a name="l00035"></a>00035 <span class="comment"></span>
<a name="l00036"></a>00036 <span class="comment">An ao2 object is a block of memory that the user code can access,</span>
<a name="l00037"></a>00037 <span class="comment">and for which the system keeps track (with a bit of help from the</span>
<a name="l00038"></a>00038 <span class="comment">programmer) of the number of references around.  When an object has</span>
<a name="l00039"></a>00039 <span class="comment">no more references (refcount == 0), it is destroyed, by first</span>
<a name="l00040"></a>00040 <span class="comment">invoking whatever &apos;destructor&apos; function the programmer specifies</span>
<a name="l00041"></a>00041 <span class="comment">(it can be NULL if none is necessary), and then freeing the memory.</span>
<a name="l00042"></a>00042 <span class="comment">This way objects can be shared without worrying who is in charge</span>
<a name="l00043"></a>00043 <span class="comment">of freeing them.</span>
<a name="l00044"></a>00044 <span class="comment">As an additional feature, ao2 objects are associated to individual</span>
<a name="l00045"></a>00045 <span class="comment">locks.</span>
<a name="l00046"></a>00046 <span class="comment"></span>
<a name="l00047"></a>00047 <span class="comment">Creating an object requires the size of the object and</span>
<a name="l00048"></a>00048 <span class="comment">and a pointer to the destructor function:</span>
<a name="l00049"></a>00049 <span class="comment"></span>
<a name="l00050"></a>00050 <span class="comment">    struct foo *o;</span>
<a name="l00051"></a>00051 <span class="comment"></span>
<a name="l00052"></a>00052 <span class="comment">    o = ao2_alloc(sizeof(struct foo), my_destructor_fn);</span>
<a name="l00053"></a>00053 <span class="comment"></span>
<a name="l00054"></a>00054 <span class="comment">The value returned points to the user-visible portion of the objects</span>
<a name="l00055"></a>00055 <span class="comment">(user-data), but is also used as an identifier for all object-related</span>
<a name="l00056"></a>00056 <span class="comment">operations such as refcount and lock manipulations.</span>
<a name="l00057"></a>00057 <span class="comment"></span>
<a name="l00058"></a>00058 <span class="comment">On return from ao2_alloc():</span>
<a name="l00059"></a>00059 <span class="comment"></span>
<a name="l00060"></a>00060 <span class="comment"> - the object has a refcount = 1;</span>
<a name="l00061"></a>00061 <span class="comment"> - the memory for the object is allocated dynamically and zeroed;</span>
<a name="l00062"></a>00062 <span class="comment"> - we cannot realloc() the object itself;</span>
<a name="l00063"></a>00063 <span class="comment"> - we cannot call free(o) to dispose of the object. Rather, we</span>
<a name="l00064"></a>00064 <span class="comment">   tell the system that we do not need the reference anymore:</span>
<a name="l00065"></a>00065 <span class="comment"></span>
<a name="l00066"></a>00066 <span class="comment">    ao2_ref(o, -1)</span>
<a name="l00067"></a>00067 <span class="comment"></span>
<a name="l00068"></a>00068 <span class="comment">  causing the destructor to be called (and then memory freed) when</span>
<a name="l00069"></a>00069 <span class="comment">  the refcount goes to 0.</span>
<a name="l00070"></a>00070 <span class="comment"></span>
<a name="l00071"></a>00071 <span class="comment">- ao2_ref(o, +1) can be used to modify the refcount on the</span>
<a name="l00072"></a>00072 <span class="comment">  object in case we want to pass it around.</span>
<a name="l00073"></a>00073 <span class="comment"></span>
<a name="l00074"></a>00074 <span class="comment">- ao2_lock(obj), ao2_unlock(obj), ao2_trylock(obj) can be used</span>
<a name="l00075"></a>00075 <span class="comment">  to manipulate the lock associated with the object.</span>
<a name="l00076"></a>00076 <span class="comment"></span>
<a name="l00077"></a>00077 <span class="comment"></span>
<a name="l00078"></a>00078 <span class="comment">\section AstObj2_UsageContainers USAGE - CONTAINERS</span>
<a name="l00079"></a>00079 <span class="comment"></span>
<a name="l00080"></a>00080 <span class="comment">An ao2 container is an abstract data structure where we can store</span>
<a name="l00081"></a>00081 <span class="comment">ao2 objects, search them (hopefully in an efficient way), and iterate</span>
<a name="l00082"></a>00082 <span class="comment">or apply a callback function to them. A container is just an ao2 object</span>
<a name="l00083"></a>00083 <span class="comment">itself.</span>
<a name="l00084"></a>00084 <span class="comment"></span>
<a name="l00085"></a>00085 <span class="comment">A container must first be allocated, specifying the initial</span>
<a name="l00086"></a>00086 <span class="comment">parameters. At the moment, this is done as follows:</span>
<a name="l00087"></a>00087 <span class="comment"></span>
<a name="l00088"></a>00088 <span class="comment">    &lt;b&gt;Sample Usage:&lt;/b&gt;</span>
<a name="l00089"></a>00089 <span class="comment">    \code</span>
<a name="l00090"></a>00090 <span class="comment"></span>
<a name="l00091"></a>00091 <span class="comment">    struct ao2_container *c;</span>
<a name="l00092"></a>00092 <span class="comment"></span>
<a name="l00093"></a>00093 <span class="comment">    c = ao2_container_alloc(MAX_BUCKETS, my_hash_fn, my_cmp_fn);</span>
<a name="l00094"></a>00094 <span class="comment">    \endcode</span>
<a name="l00095"></a>00095 <span class="comment"></span>
<a name="l00096"></a>00096 <span class="comment">where</span>
<a name="l00097"></a>00097 <span class="comment"></span>
<a name="l00098"></a>00098 <span class="comment">- MAX_BUCKETS is the number of buckets in the hash table,</span>
<a name="l00099"></a>00099 <span class="comment">- my_hash_fn() is the (user-supplied) function that returns a</span>
<a name="l00100"></a>00100 <span class="comment">  hash key for the object (further reduced modulo MAX_BUCKETS</span>
<a name="l00101"></a>00101 <span class="comment">  by the container&apos;s code);</span>
<a name="l00102"></a>00102 <span class="comment">- my_cmp_fn() is the default comparison function used when doing</span>
<a name="l00103"></a>00103 <span class="comment">  searches on the container,</span>
<a name="l00104"></a>00104 <span class="comment"></span>
<a name="l00105"></a>00105 <span class="comment">A container knows little or nothing about the objects it stores,</span>
<a name="l00106"></a>00106 <span class="comment">other than the fact that they have been created by ao2_alloc().</span>
<a name="l00107"></a>00107 <span class="comment">All knowledge of the (user-defined) internals of the objects</span>
<a name="l00108"></a>00108 <span class="comment">is left to the (user-supplied) functions passed as arguments</span>
<a name="l00109"></a>00109 <span class="comment">to ao2_container_alloc().</span>
<a name="l00110"></a>00110 <span class="comment"></span>
<a name="l00111"></a>00111 <span class="comment">If we want to insert an object in a container, we should</span>
<a name="l00112"></a>00112 <span class="comment">initialize its fields -- especially, those used by my_hash_fn() --</span>
<a name="l00113"></a>00113 <span class="comment">to compute the bucket to use.</span>
<a name="l00114"></a>00114 <span class="comment">Once done, we can link an object to a container with</span>
<a name="l00115"></a>00115 <span class="comment"></span>
<a name="l00116"></a>00116 <span class="comment">    ao2_link(c, o);</span>
<a name="l00117"></a>00117 <span class="comment"></span>
<a name="l00118"></a>00118 <span class="comment">The function returns NULL in case of errors (and the object</span>
<a name="l00119"></a>00119 <span class="comment">is not inserted in the container). Other values mean success</span>
<a name="l00120"></a>00120 <span class="comment">(we are not supposed to use the value as a pointer to anything).</span>
<a name="l00121"></a>00121 <span class="comment">Linking an object to a container increases its refcount by 1</span>
<a name="l00122"></a>00122 <span class="comment">automatically.</span>
<a name="l00123"></a>00123 <span class="comment"></span>
<a name="l00124"></a>00124 <span class="comment">\note While an object o is in a container, we expect that</span>
<a name="l00125"></a>00125 <span class="comment">my_hash_fn(o) will always return the same value. The function</span>
<a name="l00126"></a>00126 <span class="comment">does not lock the object to be computed, so modifications of</span>
<a name="l00127"></a>00127 <span class="comment">those fields that affect the computation of the hash should</span>
<a name="l00128"></a>00128 <span class="comment">be done by extracting the object from the container, and</span>
<a name="l00129"></a>00129 <span class="comment">reinserting it after the change (this is not terribly expensive).</span>
<a name="l00130"></a>00130 <span class="comment"></span>
<a name="l00131"></a>00131 <span class="comment">\note A container with a single buckets is effectively a linked</span>
<a name="l00132"></a>00132 <span class="comment">list. However there is no ordering among elements.</span>
<a name="l00133"></a>00133 <span class="comment"></span>
<a name="l00134"></a>00134 <span class="comment">- \ref AstObj2_Containers</span>
<a name="l00135"></a>00135 <span class="comment">- \ref astobj2.h All documentation for functions and data structures</span>
<a name="l00136"></a>00136 <span class="comment"></span>
<a name="l00137"></a>00137 <span class="comment"> */</span>
<a name="l00138"></a>00138 
<a name="l00139"></a>00139 <span class="comment">/*</span>
<a name="l00140"></a>00140 <span class="comment">\note DEBUGGING REF COUNTS BIBLE:</span>
<a name="l00141"></a>00141 <span class="comment">An interface to help debug refcounting is provided</span>
<a name="l00142"></a>00142 <span class="comment">in this package. It is dependent on the REF_DEBUG macro being</span>
<a name="l00143"></a>00143 <span class="comment">defined in a source file, before the #include of astobj2.h,</span>
<a name="l00144"></a>00144 <span class="comment">and in using variants of the normal ao2_xxxx functions</span>
<a name="l00145"></a>00145 <span class="comment">that are named ao2_t_xxxx instead, with an extra argument, a string,</span>
<a name="l00146"></a>00146 <span class="comment">that will be printed out into /tmp/refs when the refcount for an</span>
<a name="l00147"></a>00147 <span class="comment">object is changed.</span>
<a name="l00148"></a>00148 <span class="comment"></span>
<a name="l00149"></a>00149 <span class="comment">  these ao2_t_xxxx variants are provided:</span>
<a name="l00150"></a>00150 <span class="comment"></span>
<a name="l00151"></a>00151 <span class="comment">ao2_t_alloc(arg1, arg2, arg3)</span>
<a name="l00152"></a>00152 <span class="comment">ao2_t_ref(arg1,arg2,arg3)</span>
<a name="l00153"></a>00153 <span class="comment">ao2_t_container_alloc(arg1,arg2,arg3,arg4)</span>
<a name="l00154"></a>00154 <span class="comment">ao2_t_link(arg1, arg2, arg3)</span>
<a name="l00155"></a>00155 <span class="comment">ao2_t_unlink(arg1, arg2, arg3)</span>
<a name="l00156"></a>00156 <span class="comment">ao2_t_callback(arg1,arg2,arg3,arg4,arg5)</span>
<a name="l00157"></a>00157 <span class="comment">ao2_t_find(arg1,arg2,arg3,arg4)</span>
<a name="l00158"></a>00158 <span class="comment">ao2_t_iterator_next(arg1, arg2)</span>
<a name="l00159"></a>00159 <span class="comment"></span>
<a name="l00160"></a>00160 <span class="comment">If you study each argument list, you will see that these functions all have</span>
<a name="l00161"></a>00161 <span class="comment">one extra argument that their ao2_xxx counterpart. The last argument in</span>
<a name="l00162"></a>00162 <span class="comment">each case is supposed to be a string pointer, a &quot;tag&quot;, that should contain</span>
<a name="l00163"></a>00163 <span class="comment">enough of an explanation, that you can pair operations that increment the</span>
<a name="l00164"></a>00164 <span class="comment">ref count, with operations that are meant to decrement the refcount.</span>
<a name="l00165"></a>00165 <span class="comment"></span>
<a name="l00166"></a>00166 <span class="comment">Each of these calls will generate at least one line of output in /tmp/refs.</span>
<a name="l00167"></a>00167 <span class="comment">These lines look like this:</span>
<a name="l00168"></a>00168 <span class="comment">...</span>
<a name="l00169"></a>00169 <span class="comment">0x8756f00 =1   chan_sip.c:22240:load_module (allocate users)</span>
<a name="l00170"></a>00170 <span class="comment">0x86e3408 =1   chan_sip.c:22241:load_module (allocate peers)</span>
<a name="l00171"></a>00171 <span class="comment">0x86dd380 =1   chan_sip.c:22242:load_module (allocate peers_by_ip)</span>
<a name="l00172"></a>00172 <span class="comment">0x822d020 =1   chan_sip.c:22243:load_module (allocate dialogs)</span>
<a name="l00173"></a>00173 <span class="comment">0x8930fd8 =1   chan_sip.c:20025:build_peer (allocate a peer struct)</span>
<a name="l00174"></a>00174 <span class="comment">0x8930fd8 +1   chan_sip.c:21467:reload_config (link peer into peer table) [@1]</span>
<a name="l00175"></a>00175 <span class="comment">0x8930fd8 -1   chan_sip.c:2370:unref_peer (unref_peer: from reload_config) [@2]</span>
<a name="l00176"></a>00176 <span class="comment">0x89318b0 =1   chan_sip.c:20025:build_peer (allocate a peer struct)</span>
<a name="l00177"></a>00177 <span class="comment">0x89318b0 +1   chan_sip.c:21467:reload_config (link peer into peer table) [@1]</span>
<a name="l00178"></a>00178 <span class="comment">0x89318b0 -1   chan_sip.c:2370:unref_peer (unref_peer: from reload_config) [@2]</span>
<a name="l00179"></a>00179 <span class="comment">0x8930218 =1   chan_sip.c:20025:build_peer (allocate a peer struct)</span>
<a name="l00180"></a>00180 <span class="comment">0x8930218 +1   chan_sip.c:21539:reload_config (link peer into peers table) [@1]</span>
<a name="l00181"></a>00181 <span class="comment">0x868c040 -1   chan_sip.c:2424:dialog_unlink_all (unset the relatedpeer-&gt;call field in tandem with relatedpeer field itself) [@2]</span>
<a name="l00182"></a>00182 <span class="comment">0x868c040 -1   chan_sip.c:2443:dialog_unlink_all (Let&apos;s unbump the count in the unlink so the poor pvt can disappear if it is time) [@1]</span>
<a name="l00183"></a>00183 <span class="comment">0x868c040 **call destructor** chan_sip.c:2443:dialog_unlink_all (Let&apos;s unbump the count in the unlink so the poor pvt can disappear if it is time)</span>
<a name="l00184"></a>00184 <span class="comment">0x8cc07e8 -1   chan_sip.c:2370:unref_peer (unsetting a dialog relatedpeer field in sip_destroy) [@3]</span>
<a name="l00185"></a>00185 <span class="comment">0x8cc07e8 +1   chan_sip.c:3876:find_peer (ao2_find in peers table) [@2]</span>
<a name="l00186"></a>00186 <span class="comment">0x8cc07e8 -1   chan_sip.c:2370:unref_peer (unref_peer, from sip_devicestate, release ref from find_peer) [@3]</span>
<a name="l00187"></a>00187 <span class="comment">...</span>
<a name="l00188"></a>00188 <span class="comment"></span>
<a name="l00189"></a>00189 <span class="comment">The first column is the object address.</span>
<a name="l00190"></a>00190 <span class="comment">The second column reflects how the operation affected the ref count</span>
<a name="l00191"></a>00191 <span class="comment">    for that object. Creation sets the ref count to 1 (=1).</span>
<a name="l00192"></a>00192 <span class="comment">    increment or decrement and amount are specified (-1/+1).</span>
<a name="l00193"></a>00193 <span class="comment">The remainder of the line specifies where in the file the call was made,</span>
<a name="l00194"></a>00194 <span class="comment">    and the function name, and the tag supplied in the function call.</span>
<a name="l00195"></a>00195 <span class="comment"></span>
<a name="l00196"></a>00196 <span class="comment">The **call destructor** is specified when the the destroy routine is</span>
<a name="l00197"></a>00197 <span class="comment">run for an object. It does not affect the ref count, but is important</span>
<a name="l00198"></a>00198 <span class="comment">in debugging, because it is possible to have the astobj2 system run it</span>
<a name="l00199"></a>00199 <span class="comment">multiple times on the same object, commonly fatal to asterisk.</span>
<a name="l00200"></a>00200 <span class="comment"></span>
<a name="l00201"></a>00201 <span class="comment">Sometimes you have some helper functions to do object ref/unref</span>
<a name="l00202"></a>00202 <span class="comment">operations. Using these normally hides the place where these</span>
<a name="l00203"></a>00203 <span class="comment">functions were called. To get the location where these functions</span>
<a name="l00204"></a>00204 <span class="comment">were called to appear in /tmp/refs, you can do this sort of thing:</span>
<a name="l00205"></a>00205 <span class="comment"></span>
<a name="l00206"></a>00206 <span class="comment">#ifdef REF_DEBUG</span>
<a name="l00207"></a>00207 <span class="comment">#define dialog_ref(arg1,arg2) dialog_ref_debug((arg1),(arg2), __FILE__, __LINE__, __PRETTY_FUNCTION__)</span>
<a name="l00208"></a>00208 <span class="comment">#define dialog_unref(arg1,arg2) dialog_unref_debug((arg1),(arg2), __FILE__, __LINE__, __PRETTY_FUNCTION__)</span>
<a name="l00209"></a>00209 <span class="comment">static struct sip_pvt *dialog_ref_debug(struct sip_pvt *p, char *tag, char *file, int line, const char *func)</span>
<a name="l00210"></a>00210 <span class="comment">{</span>
<a name="l00211"></a>00211 <span class="comment">   if (p)</span>
<a name="l00212"></a>00212 <span class="comment">      ao2_ref_debug(p, 1, tag, file, line, func);</span>
<a name="l00213"></a>00213 <span class="comment">   else</span>
<a name="l00214"></a>00214 <span class="comment">      ast_log(LOG_ERROR, &quot;Attempt to Ref a null pointer\n&quot;);</span>
<a name="l00215"></a>00215 <span class="comment">   return p;</span>
<a name="l00216"></a>00216 <span class="comment">}</span>
<a name="l00217"></a>00217 <span class="comment"></span>
<a name="l00218"></a>00218 <span class="comment">static struct sip_pvt *dialog_unref_debug(struct sip_pvt *p, char *tag, char *file, int line, const char *func)</span>
<a name="l00219"></a>00219 <span class="comment">{</span>
<a name="l00220"></a>00220 <span class="comment">   if (p)</span>
<a name="l00221"></a>00221 <span class="comment">      ao2_ref_debug(p, -1, tag, file, line, func);</span>
<a name="l00222"></a>00222 <span class="comment">   return NULL;</span>
<a name="l00223"></a>00223 <span class="comment">}</span>
<a name="l00224"></a>00224 <span class="comment">#else</span>
<a name="l00225"></a>00225 <span class="comment">static struct sip_pvt *dialog_ref(struct sip_pvt *p, char *tag)</span>
<a name="l00226"></a>00226 <span class="comment">{</span>
<a name="l00227"></a>00227 <span class="comment">   if (p)</span>
<a name="l00228"></a>00228 <span class="comment">      ao2_ref(p, 1);</span>
<a name="l00229"></a>00229 <span class="comment">   else</span>
<a name="l00230"></a>00230 <span class="comment">      ast_log(LOG_ERROR, &quot;Attempt to Ref a null pointer\n&quot;);</span>
<a name="l00231"></a>00231 <span class="comment">   return p;</span>
<a name="l00232"></a>00232 <span class="comment">}</span>
<a name="l00233"></a>00233 <span class="comment"></span>
<a name="l00234"></a>00234 <span class="comment">static struct sip_pvt *dialog_unref(struct sip_pvt *p, char *tag)</span>
<a name="l00235"></a>00235 <span class="comment">{</span>
<a name="l00236"></a>00236 <span class="comment">   if (p)</span>
<a name="l00237"></a>00237 <span class="comment">      ao2_ref(p, -1);</span>
<a name="l00238"></a>00238 <span class="comment">   return NULL;</span>
<a name="l00239"></a>00239 <span class="comment">}</span>
<a name="l00240"></a>00240 <span class="comment">#endif</span>
<a name="l00241"></a>00241 <span class="comment"></span>
<a name="l00242"></a>00242 <span class="comment">In the above code, note that the &quot;normal&quot; helper funcs call ao2_ref() as</span>
<a name="l00243"></a>00243 <span class="comment">normal, and the &quot;helper&quot; functions call ao2_ref_debug directly with the</span>
<a name="l00244"></a>00244 <span class="comment">file, function, and line number info provided. You might find this</span>
<a name="l00245"></a>00245 <span class="comment">well worth the effort to help track these function calls in the code.</span>
<a name="l00246"></a>00246 <span class="comment"></span>
<a name="l00247"></a>00247 <span class="comment">To find out why objects are not destroyed (a common bug), you can</span>
<a name="l00248"></a>00248 <span class="comment">edit the source file to use the ao2_t_* variants, add the #define REF_DEBUG 1</span>
<a name="l00249"></a>00249 <span class="comment">before the #include &quot;asterisk/astobj2.h&quot; line, and add a descriptive</span>
<a name="l00250"></a>00250 <span class="comment">tag to each call. Recompile, and run Asterisk, exit asterisk with</span>
<a name="l00251"></a>00251 <span class="comment">&quot;stop gracefully&quot;, which should result in every object being destroyed.</span>
<a name="l00252"></a>00252 <span class="comment">Then, you can &quot;sort -k 1 /tmp/refs &gt; x1&quot; to get a sorted list of</span>
<a name="l00253"></a>00253 <span class="comment">all the objects, or you can use &quot;util/refcounter&quot; to scan the file</span>
<a name="l00254"></a>00254 <span class="comment">for you and output any problems it finds.</span>
<a name="l00255"></a>00255 <span class="comment"></span>
<a name="l00256"></a>00256 <span class="comment">The above may seem astronomically more work than it is worth to debug</span>
<a name="l00257"></a>00257 <span class="comment">reference counts, which may be true in &quot;simple&quot; situations, but for</span>
<a name="l00258"></a>00258 <span class="comment">more complex situations, it is easily worth 100 times this effort to</span>
<a name="l00259"></a>00259 <span class="comment">help find problems.</span>
<a name="l00260"></a>00260 <span class="comment"></span>
<a name="l00261"></a>00261 <span class="comment">To debug, pair all calls so that each call that increments the</span>
<a name="l00262"></a>00262 <span class="comment">refcount is paired with a corresponding call that decrements the</span>
<a name="l00263"></a>00263 <span class="comment">count for the same reason. Hopefully, you will be left with one</span>
<a name="l00264"></a>00264 <span class="comment">or more unpaired calls. This is where you start your search!</span>
<a name="l00265"></a>00265 <span class="comment"></span>
<a name="l00266"></a>00266 <span class="comment">For instance, here is an example of this for a dialog object in</span>
<a name="l00267"></a>00267 <span class="comment">chan_sip, that was not getting destroyed, after I moved the lines around</span>
<a name="l00268"></a>00268 <span class="comment">to pair operations:</span>
<a name="l00269"></a>00269 <span class="comment"></span>
<a name="l00270"></a>00270 <span class="comment">   0x83787a0 =1   chan_sip.c:5733:sip_alloc (allocate a dialog(pvt) struct)</span>
<a name="l00271"></a>00271 <span class="comment">   0x83787a0 -1   chan_sip.c:19173:sip_poke_peer (unref dialog at end of sip_poke_peer, obtained from sip_alloc, just before it goes out of scope) [@4]</span>
<a name="l00272"></a>00272 <span class="comment"></span>
<a name="l00273"></a>00273 <span class="comment">   0x83787a0 +1   chan_sip.c:5854:sip_alloc (link pvt into dialogs table) [@1]</span>
<a name="l00274"></a>00274 <span class="comment">   0x83787a0 -1   chan_sip.c:19150:sip_poke_peer (About to change the callid -- remove the old name) [@3]</span>
<a name="l00275"></a>00275 <span class="comment">   0x83787a0 +1   chan_sip.c:19152:sip_poke_peer (Linking in under new name) [@2]</span>
<a name="l00276"></a>00276 <span class="comment">   0x83787a0 -1   chan_sip.c:2399:dialog_unlink_all (unlinking dialog via ao2_unlink) [@5]</span>
<a name="l00277"></a>00277 <span class="comment"></span>
<a name="l00278"></a>00278 <span class="comment">   0x83787a0 +1   chan_sip.c:19130:sip_poke_peer (copy sip alloc from p to peer-&gt;call) [@2]</span>
<a name="l00279"></a>00279 <span class="comment"></span>
<a name="l00280"></a>00280 <span class="comment"></span>
<a name="l00281"></a>00281 <span class="comment">   0x83787a0 +1   chan_sip.c:2996:__sip_reliable_xmit (__sip_reliable_xmit: setting pkt-&gt;owner) [@3]</span>
<a name="l00282"></a>00282 <span class="comment">   0x83787a0 -1   chan_sip.c:2425:dialog_unlink_all (remove all current packets in this dialog, and the pointer to the dialog too as part of __sip_destroy) [@4]</span>
<a name="l00283"></a>00283 <span class="comment"></span>
<a name="l00284"></a>00284 <span class="comment">   0x83787a0 +1   chan_sip.c:22356:unload_module (iterate thru dialogs) [@4]</span>
<a name="l00285"></a>00285 <span class="comment">   0x83787a0 -1   chan_sip.c:22359:unload_module (toss dialog ptr from iterator_next) [@5]</span>
<a name="l00286"></a>00286 <span class="comment"></span>
<a name="l00287"></a>00287 <span class="comment"></span>
<a name="l00288"></a>00288 <span class="comment">   0x83787a0 +1   chan_sip.c:22373:unload_module (iterate thru dialogs) [@3]</span>
<a name="l00289"></a>00289 <span class="comment">   0x83787a0 -1   chan_sip.c:22375:unload_module (throw away iterator result) [@2]</span>
<a name="l00290"></a>00290 <span class="comment"></span>
<a name="l00291"></a>00291 <span class="comment">   0x83787a0 +1   chan_sip.c:2397:dialog_unlink_all (Let&apos;s bump the count in the unlink so it doesn&apos;t accidentally become dead before we are done) [@4]</span>
<a name="l00292"></a>00292 <span class="comment">   0x83787a0 -1   chan_sip.c:2436:dialog_unlink_all (Let&apos;s unbump the count in the unlink so the poor pvt can disappear if it is time) [@3]</span>
<a name="l00293"></a>00293 <span class="comment"></span>
<a name="l00294"></a>00294 <span class="comment">As you can see, only one unbalanced operation is in the list, a ref count increment when</span>
<a name="l00295"></a>00295 <span class="comment">the peer-&gt;call was set, but no corresponding decrement was made...</span>
<a name="l00296"></a>00296 <span class="comment"></span>
<a name="l00297"></a>00297 <span class="comment">Hopefully this helps you narrow your search and find those bugs.</span>
<a name="l00298"></a>00298 <span class="comment"></span>
<a name="l00299"></a>00299 <span class="comment">THE ART OF REFERENCE COUNTING</span>
<a name="l00300"></a>00300 <span class="comment">(by Steve Murphy)</span>
<a name="l00301"></a>00301 <span class="comment">SOME TIPS for complicated code, and ref counting:</span>
<a name="l00302"></a>00302 <span class="comment"></span>
<a name="l00303"></a>00303 <span class="comment">1. Theoretically, passing a refcounted object pointer into a function</span>
<a name="l00304"></a>00304 <span class="comment">call is an act of copying the reference, and could be refcounted.</span>
<a name="l00305"></a>00305 <span class="comment">But, upon examination, this sort of refcounting will explode the amount</span>
<a name="l00306"></a>00306 <span class="comment">of code you have to enter, and for no tangible benefit, beyond</span>
<a name="l00307"></a>00307 <span class="comment">creating more possible failure points/bugs. It will even</span>
<a name="l00308"></a>00308 <span class="comment">complicate your code and make debugging harder, slow down your program</span>
<a name="l00309"></a>00309 <span class="comment">doing useless increments and decrements of the ref counts.</span>
<a name="l00310"></a>00310 <span class="comment"></span>
<a name="l00311"></a>00311 <span class="comment">2. It is better to track places where a ref counted pointer</span>
<a name="l00312"></a>00312 <span class="comment">is copied into a structure or stored. Make sure to decrement the refcount</span>
<a name="l00313"></a>00313 <span class="comment">of any previous pointer that might have been there, if setting</span>
<a name="l00314"></a>00314 <span class="comment">this field might erase a previous pointer. ao2_find and iterate_next</span>
<a name="l00315"></a>00315 <span class="comment">internally increment the ref count when they return a pointer, so</span>
<a name="l00316"></a>00316 <span class="comment">you need to decrement the count before the pointer goes out of scope.</span>
<a name="l00317"></a>00317 <span class="comment"></span>
<a name="l00318"></a>00318 <span class="comment">3. Any time you decrement a ref count, it may be possible that the</span>
<a name="l00319"></a>00319 <span class="comment">object will be destroyed (freed) immediately by that call. If you</span>
<a name="l00320"></a>00320 <span class="comment">are destroying a series of fields in a refcounted object, and</span>
<a name="l00321"></a>00321 <span class="comment">any of the unref calls might possibly result in immediate destruction,</span>
<a name="l00322"></a>00322 <span class="comment">you can first increment the count to prevent such behavior, then</span>
<a name="l00323"></a>00323 <span class="comment">after the last test, decrement the pointer to allow the object</span>
<a name="l00324"></a>00324 <span class="comment">to be destroyed, if the refcount would be zero.</span>
<a name="l00325"></a>00325 <span class="comment"></span>
<a name="l00326"></a>00326 <span class="comment">Example:</span>
<a name="l00327"></a>00327 <span class="comment"></span>
<a name="l00328"></a>00328 <span class="comment">   dialog_ref(dialog, &quot;Let&apos;s bump the count in the unlink so it doesn&apos;t accidentally become dead before we are done&quot;);</span>
<a name="l00329"></a>00329 <span class="comment"></span>
<a name="l00330"></a>00330 <span class="comment">   ao2_t_unlink(dialogs, dialog, &quot;unlinking dialog via ao2_unlink&quot;);</span>
<a name="l00331"></a>00331 <span class="comment"></span>
<a name="l00332"></a>00332 <span class="comment">   */</span><span class="comment">/* Unlink us from the owner (channel) if we have one */</span><span class="comment">/*</span>
<a name="l00333"></a>00333 <span class="comment">   if (dialog-&gt;owner) {</span>
<a name="l00334"></a>00334 <span class="comment">      if (lockowner)</span>
<a name="l00335"></a>00335 <span class="comment">         ast_channel_lock(dialog-&gt;owner);</span>
<a name="l00336"></a>00336 <span class="comment">      ast_debug(1, &quot;Detaching from channel %s\n&quot;, dialog-&gt;owner-&gt;name);</span>
<a name="l00337"></a>00337 <span class="comment">      dialog-&gt;owner-&gt;tech_pvt = dialog_unref(dialog-&gt;owner-&gt;tech_pvt, &quot;resetting channel dialog ptr in unlink_all&quot;);</span>
<a name="l00338"></a>00338 <span class="comment">      if (lockowner)</span>
<a name="l00339"></a>00339 <span class="comment">         ast_channel_unlock(dialog-&gt;owner);</span>
<a name="l00340"></a>00340 <span class="comment">   }</span>
<a name="l00341"></a>00341 <span class="comment">   if (dialog-&gt;registry) {</span>
<a name="l00342"></a>00342 <span class="comment">      if (dialog-&gt;registry-&gt;call == dialog)</span>
<a name="l00343"></a>00343 <span class="comment">         dialog-&gt;registry-&gt;call = dialog_unref(dialog-&gt;registry-&gt;call, &quot;nulling out the registry&apos;s call dialog field in unlink_all&quot;);</span>
<a name="l00344"></a>00344 <span class="comment">      dialog-&gt;registry = registry_unref(dialog-&gt;registry, &quot;delete dialog-&gt;registry&quot;);</span>
<a name="l00345"></a>00345 <span class="comment">   }</span>
<a name="l00346"></a>00346 <span class="comment">    ...</span>
<a name="l00347"></a>00347 <span class="comment">   dialog_unref(dialog, &quot;Let&apos;s unbump the count in the unlink so the poor pvt can disappear if it is time&quot;);</span>
<a name="l00348"></a>00348 <span class="comment"></span>
<a name="l00349"></a>00349 <span class="comment">In the above code, the ao2_t_unlink could end up destroying the dialog</span>
<a name="l00350"></a>00350 <span class="comment">object; if this happens, then the subsequent usages of the dialog</span>
<a name="l00351"></a>00351 <span class="comment">pointer could result in a core dump. So, we &apos;bump&apos; the</span>
<a name="l00352"></a>00352 <span class="comment">count upwards before beginning, and then decrementing the count when</span>
<a name="l00353"></a>00353 <span class="comment">we are finished. This is analogous to &apos;locking&apos; or &apos;protecting&apos; operations</span>
<a name="l00354"></a>00354 <span class="comment">for a short while.</span>
<a name="l00355"></a>00355 <span class="comment"></span>
<a name="l00356"></a>00356 <span class="comment">4. One of the most insidious problems I&apos;ve run into when converting</span>
<a name="l00357"></a>00357 <span class="comment">code to do ref counted automatic destruction, is in the destruction</span>
<a name="l00358"></a>00358 <span class="comment">routines. Where a &quot;destroy&quot; routine had previously been called to</span>
<a name="l00359"></a>00359 <span class="comment">get rid of an object in non-refcounted code, the new regime demands</span>
<a name="l00360"></a>00360 <span class="comment">that you tear that &quot;destroy&quot; routine into two pieces, one that will</span>
<a name="l00361"></a>00361 <span class="comment">tear down the links and &apos;unref&apos; them, and the other to actually free</span>
<a name="l00362"></a>00362 <span class="comment">and reset fields. A destroy routine that does any reference deletion</span>
<a name="l00363"></a>00363 <span class="comment">for its own object, will never be called. Another insidious problem</span>
<a name="l00364"></a>00364 <span class="comment">occurs in mutually referenced structures. As an example, a dialog contains</span>
<a name="l00365"></a>00365 <span class="comment">a pointer to a peer, and a peer contains a pointer to a dialog. Watch</span>
<a name="l00366"></a>00366 <span class="comment">out that the destruction of one doesn&apos;t depend on the destruction of the</span>
<a name="l00367"></a>00367 <span class="comment">other, as in this case a dependency loop will result in neither being</span>
<a name="l00368"></a>00368 <span class="comment">destroyed!</span>
<a name="l00369"></a>00369 <span class="comment"></span>
<a name="l00370"></a>00370 <span class="comment">Given the above, you should be ready to do a good job!</span>
<a name="l00371"></a>00371 <span class="comment"></span>
<a name="l00372"></a>00372 <span class="comment">murf</span>
<a name="l00373"></a>00373 <span class="comment"></span>
<a name="l00374"></a>00374 <span class="comment">*/</span>
<a name="l00375"></a>00375 
<a name="l00376"></a>00376 
<a name="l00377"></a>00377 <span class="comment"></span>
<a name="l00378"></a>00378 <span class="comment">/*! \brief</span>
<a name="l00379"></a>00379 <span class="comment"> * Typedef for an object destructor. This is called just before freeing</span>
<a name="l00380"></a>00380 <span class="comment"> * the memory for the object. It is passed a pointer to the user-defined</span>
<a name="l00381"></a>00381 <span class="comment"> * data of the object.</span>
<a name="l00382"></a>00382 <span class="comment"> */</span>
<a name="l00383"></a><a class="code" href="astobj2_8h.html#a2ded496320c49a7b1420647373ec3e32">00383</a> <span class="keyword">typedef</span> void (*<a class="code" href="astobj2_8h.html#a2ded496320c49a7b1420647373ec3e32" title="Typedef for an object destructor. This is called just before freeing the memory for...">ao2_destructor_fn</a>)(<span class="keywordtype">void</span> *);
<a name="l00384"></a>00384 
<a name="l00385"></a>00385 <span class="comment"></span>
<a name="l00386"></a>00386 <span class="comment">/*! \brief</span>
<a name="l00387"></a>00387 <span class="comment"> * Allocate and initialize an object.</span>
<a name="l00388"></a>00388 <span class="comment"> *</span>
<a name="l00389"></a>00389 <span class="comment"> * \param data_size The sizeof() of the user-defined structure.</span>
<a name="l00390"></a>00390 <span class="comment"> * \param destructor_fn The destructor function (can be NULL)</span>
<a name="l00391"></a>00391 <span class="comment"> * \param debug_msg</span>
<a name="l00392"></a>00392 <span class="comment"> * \return A pointer to user-data.</span>
<a name="l00393"></a>00393 <span class="comment"> *</span>
<a name="l00394"></a>00394 <span class="comment"> * Allocates a struct astobj2 with sufficient space for the</span>
<a name="l00395"></a>00395 <span class="comment"> * user-defined structure.</span>
<a name="l00396"></a>00396 <span class="comment"> * \note</span>
<a name="l00397"></a>00397 <span class="comment"> * - storage is zeroed; XXX maybe we want a flag to enable/disable this.</span>
<a name="l00398"></a>00398 <span class="comment"> * - the refcount of the object just created is 1</span>
<a name="l00399"></a>00399 <span class="comment"> * - the returned pointer cannot be free()&apos;d or realloc()&apos;ed;</span>
<a name="l00400"></a>00400 <span class="comment"> *   rather, we just call ao2_ref(o, -1);</span>
<a name="l00401"></a>00401 <span class="comment"> *</span>
<a name="l00402"></a>00402 <span class="comment"> * @{</span>
<a name="l00403"></a>00403 <span class="comment"> */</span>
<a name="l00404"></a>00404 
<a name="l00405"></a>00405 <span class="preprocessor">#if defined(REF_DEBUG)</span>
<a name="l00406"></a>00406 <span class="preprocessor"></span>
<a name="l00407"></a>00407 <span class="preprocessor">#define ao2_t_alloc(data_size, destructor_fn, debug_msg) _ao2_alloc_debug((data_size), (destructor_fn), (debug_msg),  __FILE__, __LINE__, __PRETTY_FUNCTION__, 1)</span>
<a name="l00408"></a>00408 <span class="preprocessor"></span><span class="preprocessor">#define ao2_alloc(data_size, destructor_fn)              _ao2_alloc_debug((data_size), (destructor_fn), &quot;&quot;,  __FILE__, __LINE__, __PRETTY_FUNCTION__, 1)</span>
<a name="l00409"></a>00409 <span class="preprocessor"></span>
<a name="l00410"></a>00410 <span class="preprocessor">#elif defined(__AST_DEBUG_MALLOC)</span>
<a name="l00411"></a>00411 <span class="preprocessor"></span>
<a name="l00412"></a><a class="code" href="astobj2_8h.html#ad57326008c326db88dc36779741622b8">00412</a> <span class="preprocessor">#define ao2_t_alloc(data_size, destructor_fn, debug_msg) _ao2_alloc_debug((data_size), (destructor_fn), (debug_msg),  __FILE__, __LINE__, __PRETTY_FUNCTION__, 0)</span>
<a name="l00413"></a><a class="code" href="astobj2_8h.html#ae0422b60d8e25b6962b2d61ae4ddf724">00413</a> <span class="preprocessor"></span><span class="preprocessor">#define ao2_alloc(data_size, destructor_fn)              _ao2_alloc_debug((data_size), (destructor_fn), &quot;&quot;,  __FILE__, __LINE__, __PRETTY_FUNCTION__, 0)</span>
<a name="l00414"></a>00414 <span class="preprocessor"></span>
<a name="l00415"></a>00415 <span class="preprocessor">#else</span>
<a name="l00416"></a>00416 <span class="preprocessor"></span>
<a name="l00417"></a>00417 <span class="preprocessor">#define ao2_t_alloc(data_size, destructor_fn, debug_msg) _ao2_alloc((data_size), (destructor_fn))</span>
<a name="l00418"></a>00418 <span class="preprocessor"></span><span class="preprocessor">#define ao2_alloc(data_size, destructor_fn)              _ao2_alloc((data_size), (destructor_fn))</span>
<a name="l00419"></a>00419 <span class="preprocessor"></span>
<a name="l00420"></a>00420 <span class="preprocessor">#endif</span>
<a name="l00421"></a>00421 <span class="preprocessor"></span>
<a name="l00422"></a>00422 <span class="keywordtype">void</span> *<a class="code" href="astobj2_8h.html#acaa3595d4023693e24ae4b5bb5fe1372">_ao2_alloc_debug</a>(<span class="keyword">const</span> <span class="keywordtype">size_t</span> data_size, <a class="code" href="astobj2_8h.html#a2ded496320c49a7b1420647373ec3e32" title="Typedef for an object destructor. This is called just before freeing the memory for...">ao2_destructor_fn</a> destructor_fn, <span class="keywordtype">char</span> *tag,
<a name="l00423"></a>00423          <span class="keyword">const</span> <span class="keywordtype">char</span> *file, <span class="keywordtype">int</span> line, <span class="keyword">const</span> <span class="keywordtype">char</span> *funcname, <span class="keywordtype">int</span> ref_debug);
<a name="l00424"></a>00424 <span class="keywordtype">void</span> *<a class="code" href="astobj2_8h.html#abbdf3f8df491fe56536e0fdd4c35b17a">_ao2_alloc</a>(<span class="keyword">const</span> <span class="keywordtype">size_t</span> data_size, <a class="code" href="astobj2_8h.html#a2ded496320c49a7b1420647373ec3e32" title="Typedef for an object destructor. This is called just before freeing the memory for...">ao2_destructor_fn</a> destructor_fn);
<a name="l00425"></a>00425 <span class="comment"></span>
<a name="l00426"></a>00426 <span class="comment">/*! @} */</span>
<a name="l00427"></a>00427 <span class="comment"></span>
<a name="l00428"></a>00428 <span class="comment">/*! \brief</span>
<a name="l00429"></a>00429 <span class="comment"> * Reference/unreference an object and return the old refcount.</span>
<a name="l00430"></a>00430 <span class="comment"> *</span>
<a name="l00431"></a>00431 <span class="comment"> * \param o A pointer to the object</span>
<a name="l00432"></a>00432 <span class="comment"> * \param delta Value to add to the reference counter.</span>
<a name="l00433"></a>00433 <span class="comment"> * \return The value of the reference counter before the operation.</span>
<a name="l00434"></a>00434 <span class="comment"> *</span>
<a name="l00435"></a>00435 <span class="comment"> * Increase/decrease the reference counter according</span>
<a name="l00436"></a>00436 <span class="comment"> * the value of delta.</span>
<a name="l00437"></a>00437 <span class="comment"> *</span>
<a name="l00438"></a>00438 <span class="comment"> * If the refcount goes to zero, the object is destroyed.</span>
<a name="l00439"></a>00439 <span class="comment"> *</span>
<a name="l00440"></a>00440 <span class="comment"> * \note The object must not be locked by the caller of this function, as</span>
<a name="l00441"></a>00441 <span class="comment"> *       it is invalid to try to unlock it after releasing the reference.</span>
<a name="l00442"></a>00442 <span class="comment"> *</span>
<a name="l00443"></a>00443 <span class="comment"> * \note if we know the pointer to an object, it is because we</span>
<a name="l00444"></a>00444 <span class="comment"> * have a reference count to it, so the only case when the object</span>
<a name="l00445"></a>00445 <span class="comment"> * can go away is when we release our reference, and it is</span>
<a name="l00446"></a>00446 <span class="comment"> * the last one in existence.</span>
<a name="l00447"></a>00447 <span class="comment"> *</span>
<a name="l00448"></a>00448 <span class="comment"> * @{</span>
<a name="l00449"></a>00449 <span class="comment"> */</span>
<a name="l00450"></a>00450 
<a name="l00451"></a>00451 <span class="preprocessor">#ifdef REF_DEBUG</span>
<a name="l00452"></a>00452 <span class="preprocessor"></span>
<a name="l00453"></a>00453 <span class="preprocessor">#define ao2_t_ref(o,delta,tag) _ao2_ref_debug((o), (delta), (tag),  __FILE__, __LINE__, __PRETTY_FUNCTION__)</span>
<a name="l00454"></a>00454 <span class="preprocessor"></span><span class="preprocessor">#define ao2_ref(o,delta)       _ao2_ref_debug((o), (delta), &quot;&quot;,  __FILE__, __LINE__, __PRETTY_FUNCTION__)</span>
<a name="l00455"></a>00455 <span class="preprocessor"></span>
<a name="l00456"></a>00456 <span class="preprocessor">#else</span>
<a name="l00457"></a>00457 <span class="preprocessor"></span>
<a name="l00458"></a><a class="code" href="astobj2_8h.html#a14c61bcab109a520a96d30c56ba5fcde">00458</a> <span class="preprocessor">#define ao2_t_ref(o,delta,tag) _ao2_ref((o), (delta))</span>
<a name="l00459"></a><a class="code" href="astobj2_8h.html#aaca5e8eac39a22f9da1c36fc6c922270">00459</a> <span class="preprocessor"></span><span class="preprocessor">#define ao2_ref(o,delta)       _ao2_ref((o), (delta))</span>
<a name="l00460"></a>00460 <span class="preprocessor"></span>
<a name="l00461"></a>00461 <span class="preprocessor">#endif</span>
<a name="l00462"></a>00462 <span class="preprocessor"></span>
<a name="l00463"></a>00463 <span class="keywordtype">int</span> <a class="code" href="astobj2_8h.html#a8edbc54a8389a1d173305dd79af77873">_ao2_ref_debug</a>(<span class="keywordtype">void</span> *o, <span class="keywordtype">int</span> delta, <span class="keywordtype">char</span> *tag, <span class="keywordtype">char</span> *file, <span class="keywordtype">int</span> line, <span class="keyword">const</span> <span class="keywordtype">char</span> *funcname);
<a name="l00464"></a>00464 <span class="keywordtype">int</span> <a class="code" href="astobj2_8h.html#a601e8d270ad5a16144370908e0a64233">_ao2_ref</a>(<span class="keywordtype">void</span> *o, <span class="keywordtype">int</span> delta);<span class="comment"></span>
<a name="l00465"></a>00465 <span class="comment">/*! @} */</span>
<a name="l00466"></a>00466 <span class="comment"></span>
<a name="l00467"></a>00467 <span class="comment">/*! @} */</span>
<a name="l00468"></a>00468 <span class="comment"></span>
<a name="l00469"></a>00469 <span class="comment">/*! \brief</span>
<a name="l00470"></a>00470 <span class="comment"> * Lock an object.</span>
<a name="l00471"></a>00471 <span class="comment"> *</span>
<a name="l00472"></a>00472 <span class="comment"> * \param a A pointer to the object we want to lock.</span>
<a name="l00473"></a>00473 <span class="comment"> * \return 0 on success, other values on error.</span>
<a name="l00474"></a>00474 <span class="comment"> */</span>
<a name="l00475"></a>00475 <span class="preprocessor">#ifndef DEBUG_THREADS</span>
<a name="l00476"></a>00476 <span class="preprocessor"></span><span class="keywordtype">int</span> <a class="code" href="astobj2_8h.html#a3077056d07f6f9e348a54a743769bad5" title="Lock an object.">ao2_lock</a>(<span class="keywordtype">void</span> *a);
<a name="l00477"></a>00477 <span class="preprocessor">#else</span>
<a name="l00478"></a>00478 <span class="preprocessor"></span><span class="preprocessor">#define ao2_lock(a) _ao2_lock(a, __FILE__, __PRETTY_FUNCTION__, __LINE__, #a)</span>
<a name="l00479"></a>00479 <span class="preprocessor"></span><span class="keywordtype">int</span> _ao2_lock(<span class="keywordtype">void</span> *a, <span class="keyword">const</span> <span class="keywordtype">char</span> *file, <span class="keyword">const</span> <span class="keywordtype">char</span> *func, <span class="keywordtype">int</span> line, <span class="keyword">const</span> <span class="keywordtype">char</span> *<a class="code" href="ast__expr2f_8c.html#a1b0936415a643c88ce543099c10e0d7f">var</a>);
<a name="l00480"></a>00480 <span class="preprocessor">#endif</span>
<a name="l00481"></a>00481 <span class="preprocessor"></span><span class="comment"></span>
<a name="l00482"></a>00482 <span class="comment">/*! \brief</span>
<a name="l00483"></a>00483 <span class="comment"> * Unlock an object.</span>
<a name="l00484"></a>00484 <span class="comment"> *</span>
<a name="l00485"></a>00485 <span class="comment"> * \param a A pointer to the object we want unlock.</span>
<a name="l00486"></a>00486 <span class="comment"> * \return 0 on success, other values on error.</span>
<a name="l00487"></a>00487 <span class="comment"> */</span>
<a name="l00488"></a>00488 <span class="preprocessor">#ifndef DEBUG_THREADS</span>
<a name="l00489"></a>00489 <span class="preprocessor"></span><span class="keywordtype">int</span> <a class="code" href="astobj2_8h.html#a379cc936a320f2179f7beb422dc15230" title="Unlock an object.">ao2_unlock</a>(<span class="keywordtype">void</span> *a);
<a name="l00490"></a>00490 <span class="preprocessor">#else</span>
<a name="l00491"></a>00491 <span class="preprocessor"></span><span class="preprocessor">#define ao2_unlock(a) _ao2_unlock(a, __FILE__, __PRETTY_FUNCTION__, __LINE__, #a)</span>
<a name="l00492"></a>00492 <span class="preprocessor"></span><span class="keywordtype">int</span> _ao2_unlock(<span class="keywordtype">void</span> *a, <span class="keyword">const</span> <span class="keywordtype">char</span> *file, <span class="keyword">const</span> <span class="keywordtype">char</span> *func, <span class="keywordtype">int</span> line, <span class="keyword">const</span> <span class="keywordtype">char</span> *<a class="code" href="ast__expr2f_8c.html#a1b0936415a643c88ce543099c10e0d7f">var</a>);
<a name="l00493"></a>00493 <span class="preprocessor">#endif</span>
<a name="l00494"></a>00494 <span class="preprocessor"></span><span class="comment"></span>
<a name="l00495"></a>00495 <span class="comment">/*! \brief</span>
<a name="l00496"></a>00496 <span class="comment"> * Try locking-- (don&apos;t block if fail)</span>
<a name="l00497"></a>00497 <span class="comment"> *</span>
<a name="l00498"></a>00498 <span class="comment"> * \param a A pointer to the object we want to lock.</span>
<a name="l00499"></a>00499 <span class="comment"> * \return 0 on success, other values on error.</span>
<a name="l00500"></a>00500 <span class="comment"> */</span>
<a name="l00501"></a>00501 <span class="preprocessor">#ifndef DEBUG_THREADS</span>
<a name="l00502"></a>00502 <span class="preprocessor"></span><span class="keywordtype">int</span> <a class="code" href="astobj2_8h.html#a54c54e4aa6dd4a45f2445f67b3ed6e83" title="Try locking-- (don&amp;#39;t block if fail).">ao2_trylock</a>(<span class="keywordtype">void</span> *a);
<a name="l00503"></a>00503 <span class="preprocessor">#else</span>
<a name="l00504"></a>00504 <span class="preprocessor"></span><span class="preprocessor">#define ao2_trylock(a) _ao2_trylock(a, __FILE__, __PRETTY_FUNCTION__, __LINE__, #a)</span>
<a name="l00505"></a>00505 <span class="preprocessor"></span><span class="keywordtype">int</span> _ao2_trylock(<span class="keywordtype">void</span> *a, <span class="keyword">const</span> <span class="keywordtype">char</span> *file, <span class="keyword">const</span> <span class="keywordtype">char</span> *func, <span class="keywordtype">int</span> line, <span class="keyword">const</span> <span class="keywordtype">char</span> *<a class="code" href="ast__expr2f_8c.html#a1b0936415a643c88ce543099c10e0d7f">var</a>);
<a name="l00506"></a>00506 <span class="preprocessor">#endif</span>
<a name="l00507"></a>00507 <span class="preprocessor"></span><span class="comment"></span>
<a name="l00508"></a>00508 <span class="comment">/*!</span>
<a name="l00509"></a>00509 <span class="comment"> * \brief Return the lock address of an object</span>
<a name="l00510"></a>00510 <span class="comment"> *</span>
<a name="l00511"></a>00511 <span class="comment"> * \param[in] obj A pointer to the object we want.</span>
<a name="l00512"></a>00512 <span class="comment"> * \return the address of the lock, else NULL.</span>
<a name="l00513"></a>00513 <span class="comment"> *</span>
<a name="l00514"></a>00514 <span class="comment"> * This function comes in handy mainly for debugging locking</span>
<a name="l00515"></a>00515 <span class="comment"> * situations, where the locking trace code reports the</span>
<a name="l00516"></a>00516 <span class="comment"> * lock address, this allows you to correlate against</span>
<a name="l00517"></a>00517 <span class="comment"> * object address, to match objects to reported locks.</span>
<a name="l00518"></a>00518 <span class="comment"> *</span>
<a name="l00519"></a>00519 <span class="comment"> * \since 1.6.1</span>
<a name="l00520"></a>00520 <span class="comment"> */</span>
<a name="l00521"></a>00521 <span class="keywordtype">void</span> *<a class="code" href="astobj2_8h.html#a503b6c7ced96f9b56ec59c115cbeb29a" title="Return the lock address of an object.">ao2_object_get_lockaddr</a>(<span class="keywordtype">void</span> *obj);
<a name="l00522"></a>00522 <span class="comment"></span>
<a name="l00523"></a>00523 <span class="comment">/*!</span>
<a name="l00524"></a>00524 <span class="comment"> \page AstObj2_Containers AstObj2 Containers</span>
<a name="l00525"></a>00525 <span class="comment"></span>
<a name="l00526"></a>00526 <span class="comment">Containers are data structures meant to store several objects,</span>
<a name="l00527"></a>00527 <span class="comment">and perform various operations on them.</span>
<a name="l00528"></a>00528 <span class="comment">Internally, objects are stored in lists, hash tables or other</span>
<a name="l00529"></a>00529 <span class="comment">data structures depending on the needs.</span>
<a name="l00530"></a>00530 <span class="comment"></span>
<a name="l00531"></a>00531 <span class="comment">\note NOTA BENE: at the moment the only container we support is the</span>
<a name="l00532"></a>00532 <span class="comment">   hash table and its degenerate form, the list.</span>
<a name="l00533"></a>00533 <span class="comment"></span>
<a name="l00534"></a>00534 <span class="comment">Operations on container include:</span>
<a name="l00535"></a>00535 <span class="comment"></span>
<a name="l00536"></a>00536 <span class="comment">  -  c = \b ao2_container_alloc(size, hash_fn, cmp_fn)</span>
<a name="l00537"></a>00537 <span class="comment">   allocate a container with desired size and default compare</span>
<a name="l00538"></a>00538 <span class="comment">   and hash function</span>
<a name="l00539"></a>00539 <span class="comment">         -The compare function returns an int, which</span>
<a name="l00540"></a>00540 <span class="comment">         can be 0 for not found, CMP_STOP to stop end a traversal,</span>
<a name="l00541"></a>00541 <span class="comment">         or CMP_MATCH if they are equal</span>
<a name="l00542"></a>00542 <span class="comment">         -The hash function returns an int. The hash function</span>
<a name="l00543"></a>00543 <span class="comment">         takes two argument, the object pointer and a flags field,</span>
<a name="l00544"></a>00544 <span class="comment"></span>
<a name="l00545"></a>00545 <span class="comment">  -  \b ao2_find(c, arg, flags)</span>
<a name="l00546"></a>00546 <span class="comment">   returns zero or more element matching a given criteria</span>
<a name="l00547"></a>00547 <span class="comment">   (specified as arg). &apos;c&apos; is the container pointer. Flags</span>
<a name="l00548"></a>00548 <span class="comment">    can be:</span>
<a name="l00549"></a>00549 <span class="comment">   OBJ_UNLINK - to remove the object, once found, from the container.</span>
<a name="l00550"></a>00550 <span class="comment">   OBJ_NODATA - don&apos;t return the object if found (no ref count change)</span>
<a name="l00551"></a>00551 <span class="comment">   OBJ_MULTIPLE - don&apos;t stop at first match (not fully implemented)</span>
<a name="l00552"></a>00552 <span class="comment">   OBJ_POINTER - if set, &apos;arg&apos; is an object pointer, and a hashtable</span>
<a name="l00553"></a>00553 <span class="comment">                  search will be done. If not, a traversal is done.</span>
<a name="l00554"></a>00554 <span class="comment"></span>
<a name="l00555"></a>00555 <span class="comment">  -  \b ao2_callback(c, flags, fn, arg)</span>
<a name="l00556"></a>00556 <span class="comment">   apply fn(obj, arg) to all objects in the container.</span>
<a name="l00557"></a>00557 <span class="comment">   Similar to find. fn() can tell when to stop, and</span>
<a name="l00558"></a>00558 <span class="comment">   do anything with the object including unlinking it.</span>
<a name="l00559"></a>00559 <span class="comment">     - c is the container;</span>
<a name="l00560"></a>00560 <span class="comment">      - flags can be</span>
<a name="l00561"></a>00561 <span class="comment">        OBJ_UNLINK   - to remove the object, once found, from the container.</span>
<a name="l00562"></a>00562 <span class="comment">        OBJ_NODATA   - don&apos;t return the object if found (no ref count change)</span>
<a name="l00563"></a>00563 <span class="comment">        OBJ_MULTIPLE - don&apos;t stop at first match (not fully implemented)</span>
<a name="l00564"></a>00564 <span class="comment">        OBJ_POINTER  - if set, &apos;arg&apos; is an object pointer, and a hashtable</span>
<a name="l00565"></a>00565 <span class="comment">                        search will be done. If not, a traversal is done through</span>
<a name="l00566"></a>00566 <span class="comment">                        all the hashtable &apos;buckets&apos;..</span>
<a name="l00567"></a>00567 <span class="comment">      - fn is a func that returns int, and takes 3 args:</span>
<a name="l00568"></a>00568 <span class="comment">        (void *obj, void *arg, int flags);</span>
<a name="l00569"></a>00569 <span class="comment">          obj is an object</span>
<a name="l00570"></a>00570 <span class="comment">          arg is the same as arg passed into ao2_callback</span>
<a name="l00571"></a>00571 <span class="comment">          flags is the same as flags passed into ao2_callback</span>
<a name="l00572"></a>00572 <span class="comment">         fn returns:</span>
<a name="l00573"></a>00573 <span class="comment">           0: no match, keep going</span>
<a name="l00574"></a>00574 <span class="comment">           CMP_STOP: stop search, no match</span>
<a name="l00575"></a>00575 <span class="comment">           CMP_MATCH: This object is matched.</span>
<a name="l00576"></a>00576 <span class="comment"></span>
<a name="l00577"></a>00577 <span class="comment">   Note that the entire operation is run with the container</span>
<a name="l00578"></a>00578 <span class="comment">   locked, so noone else can change its content while we work on it.</span>
<a name="l00579"></a>00579 <span class="comment">   However, we pay this with the fact that doing</span>
<a name="l00580"></a>00580 <span class="comment">   anything blocking in the callback keeps the container</span>
<a name="l00581"></a>00581 <span class="comment">   blocked.</span>
<a name="l00582"></a>00582 <span class="comment">   The mechanism is very flexible because the callback function fn()</span>
<a name="l00583"></a>00583 <span class="comment">   can do basically anything e.g. counting, deleting records, etc.</span>
<a name="l00584"></a>00584 <span class="comment">   possibly using arg to store the results.</span>
<a name="l00585"></a>00585 <span class="comment"></span>
<a name="l00586"></a>00586 <span class="comment">  -  \b iterate on a container</span>
<a name="l00587"></a>00587 <span class="comment">   this is done with the following sequence</span>
<a name="l00588"></a>00588 <span class="comment"></span>
<a name="l00589"></a>00589 <span class="comment">\code</span>
<a name="l00590"></a>00590 <span class="comment"></span>
<a name="l00591"></a>00591 <span class="comment">       struct ao2_container *c = ... // our container</span>
<a name="l00592"></a>00592 <span class="comment">       struct ao2_iterator i;</span>
<a name="l00593"></a>00593 <span class="comment">       void *o;</span>
<a name="l00594"></a>00594 <span class="comment"></span>
<a name="l00595"></a>00595 <span class="comment">       i = ao2_iterator_init(c, flags);</span>
<a name="l00596"></a>00596 <span class="comment"></span>
<a name="l00597"></a>00597 <span class="comment">       while ( (o = ao2_iterator_next(&amp;i)) ) {</span>
<a name="l00598"></a>00598 <span class="comment">      ... do something on o ...</span>
<a name="l00599"></a>00599 <span class="comment">      ao2_ref(o, -1);</span>
<a name="l00600"></a>00600 <span class="comment">       }</span>
<a name="l00601"></a>00601 <span class="comment"></span>
<a name="l00602"></a>00602 <span class="comment">       ao2_iterator_destroy(&amp;i);</span>
<a name="l00603"></a>00603 <span class="comment">\endcode</span>
<a name="l00604"></a>00604 <span class="comment"></span>
<a name="l00605"></a>00605 <span class="comment">   The difference with the callback is that the control</span>
<a name="l00606"></a>00606 <span class="comment">   on how to iterate is left to us.</span>
<a name="l00607"></a>00607 <span class="comment"></span>
<a name="l00608"></a>00608 <span class="comment">    - \b ao2_ref(c, -1)</span>
<a name="l00609"></a>00609 <span class="comment">   dropping a reference to a container destroys it, very simple!</span>
<a name="l00610"></a>00610 <span class="comment"></span>
<a name="l00611"></a>00611 <span class="comment">Containers are ao2 objects themselves, and this is why their</span>
<a name="l00612"></a>00612 <span class="comment">implementation is simple too.</span>
<a name="l00613"></a>00613 <span class="comment"></span>
<a name="l00614"></a>00614 <span class="comment">Before declaring containers, we need to declare the types of the</span>
<a name="l00615"></a>00615 <span class="comment">arguments passed to the constructor - in turn, this requires</span>
<a name="l00616"></a>00616 <span class="comment">to define callback and hash functions and their arguments.</span>
<a name="l00617"></a>00617 <span class="comment"></span>
<a name="l00618"></a>00618 <span class="comment">- \ref AstObj2</span>
<a name="l00619"></a>00619 <span class="comment">- \ref astobj2.h</span>
<a name="l00620"></a>00620 <span class="comment"> */</span>
<a name="l00621"></a>00621 <span class="comment"></span>
<a name="l00622"></a>00622 <span class="comment">/*! \brief</span>
<a name="l00623"></a>00623 <span class="comment"> * Type of a generic callback function</span>
<a name="l00624"></a>00624 <span class="comment"> * \param obj  pointer to the (user-defined part) of an object.</span>
<a name="l00625"></a>00625 <span class="comment"> * \param arg callback argument from ao2_callback()</span>
<a name="l00626"></a>00626 <span class="comment"> * \param flags flags from ao2_callback()</span>
<a name="l00627"></a>00627 <span class="comment"> *</span>
<a name="l00628"></a>00628 <span class="comment"> * The return values are a combination of enum _cb_results.</span>
<a name="l00629"></a>00629 <span class="comment"> * Callback functions are used to search or manipulate objects in a container.</span>
<a name="l00630"></a>00630 <span class="comment"> */</span>
<a name="l00631"></a><a class="code" href="astobj2_8h.html#a4de0d949b2c7e11310c21ad64a83cf72">00631</a> <span class="keyword">typedef</span> int (<a class="code" href="astobj2_8h.html#a4de0d949b2c7e11310c21ad64a83cf72" title="Type of a generic callback function.">ao2_callback_fn</a>)(<span class="keywordtype">void</span> *obj, <span class="keywordtype">void</span> *arg, <span class="keywordtype">int</span> flags);
<a name="l00632"></a>00632 <span class="comment"></span>
<a name="l00633"></a>00633 <span class="comment">/*! \brief</span>
<a name="l00634"></a>00634 <span class="comment"> * Type of a generic callback function</span>
<a name="l00635"></a>00635 <span class="comment"> * \param obj pointer to the (user-defined part) of an object.</span>
<a name="l00636"></a>00636 <span class="comment"> * \param arg callback argument from ao2_callback()</span>
<a name="l00637"></a>00637 <span class="comment"> * \param data arbitrary data from ao2_callback()</span>
<a name="l00638"></a>00638 <span class="comment"> * \param flags flags from ao2_callback()</span>
<a name="l00639"></a>00639 <span class="comment"> *</span>
<a name="l00640"></a>00640 <span class="comment"> * The return values are a combination of enum _cb_results.</span>
<a name="l00641"></a>00641 <span class="comment"> * Callback functions are used to search or manipulate objects in a container.</span>
<a name="l00642"></a>00642 <span class="comment"> */</span>
<a name="l00643"></a><a class="code" href="astobj2_8h.html#ae472805461071323e68cba1f441081f3">00643</a> <span class="keyword">typedef</span> int (<a class="code" href="astobj2_8h.html#ae472805461071323e68cba1f441081f3" title="Type of a generic callback function.">ao2_callback_data_fn</a>)(<span class="keywordtype">void</span> *obj, <span class="keywordtype">void</span> *arg, <span class="keywordtype">void</span> *data, <span class="keywordtype">int</span> flags);
<a name="l00644"></a>00644 <span class="comment"></span>
<a name="l00645"></a>00645 <span class="comment">/*! \brief a very common callback is one that matches by address. */</span>
<a name="l00646"></a><a class="code" href="astobj2_8h.html#ad3cdef7b57f55d9f43407ab7c15c3422">00646</a> <a class="code" href="astobj2_8h.html#a4de0d949b2c7e11310c21ad64a83cf72" title="Type of a generic callback function.">ao2_callback_fn</a> <a class="code" href="astobj2_8h.html#ad3cdef7b57f55d9f43407ab7c15c3422" title="a very common callback is one that matches by address.">ao2_match_by_addr</a>;
<a name="l00647"></a>00647 <span class="comment"></span>
<a name="l00648"></a>00648 <span class="comment">/*! \brief</span>
<a name="l00649"></a>00649 <span class="comment"> * A callback function will return a combination of CMP_MATCH and CMP_STOP.</span>
<a name="l00650"></a>00650 <span class="comment"> * The latter will terminate the search in a container.</span>
<a name="l00651"></a>00651 <span class="comment"> */</span>
<a name="l00652"></a><a class="code" href="astobj2_8h.html#a1f8b41308be4c47de8ff89a3b9c7e7d1">00652</a> <span class="keyword">enum</span> <a class="code" href="astobj2_8h.html#a1f8b41308be4c47de8ff89a3b9c7e7d1" title="A callback function will return a combination of CMP_MATCH and CMP_STOP. The latter...">_cb_results</a> {
<a name="l00653"></a><a class="code" href="astobj2_8h.html#a1f8b41308be4c47de8ff89a3b9c7e7d1a1959468a3c5d6aecd2fa1272d8e30fbf">00653</a>    <a class="code" href="astobj2_8h.html#a1f8b41308be4c47de8ff89a3b9c7e7d1a1959468a3c5d6aecd2fa1272d8e30fbf">CMP_MATCH</a>   = 0x1,   <span class="comment">/*!&lt; the object matches the request */</span>
<a name="l00654"></a><a class="code" href="astobj2_8h.html#a1f8b41308be4c47de8ff89a3b9c7e7d1a75382dc9117cc118719edf6c3d2b71df">00654</a>    <a class="code" href="astobj2_8h.html#a1f8b41308be4c47de8ff89a3b9c7e7d1a75382dc9117cc118719edf6c3d2b71df">CMP_STOP</a> = 0x2,   <span class="comment">/*!&lt; stop the search now */</span>
<a name="l00655"></a>00655 };
<a name="l00656"></a>00656 <span class="comment"></span>
<a name="l00657"></a>00657 <span class="comment">/*! \brief</span>
<a name="l00658"></a>00658 <span class="comment"> * Flags passed to ao2_callback() and ao2_hash_fn() to modify its behaviour.</span>
<a name="l00659"></a>00659 <span class="comment"> */</span>
<a name="l00660"></a><a class="code" href="astobj2_8h.html#ad9d009e87e737af900825b36db55a35c">00660</a> <span class="keyword">enum</span> <a class="code" href="astobj2_8h.html#ad9d009e87e737af900825b36db55a35c" title="Flags passed to ao2_callback() and ao2_hash_fn() to modify its behaviour.">search_flags</a> {<span class="comment"></span>
<a name="l00661"></a>00661 <span class="comment">   /*! Unlink the object for which the callback function</span>
<a name="l00662"></a>00662 <span class="comment">    *  returned CMP_MATCH . This is the only way to extract</span>
<a name="l00663"></a>00663 <span class="comment">    *  objects from a container. */</span>
<a name="l00664"></a><a class="code" href="astobj2_8h.html#ad9d009e87e737af900825b36db55a35ca71f42ec6460e60eb6e10956c53329e45">00664</a>    <a class="code" href="astobj2_8h.html#ad9d009e87e737af900825b36db55a35ca71f42ec6460e60eb6e10956c53329e45">OBJ_UNLINK</a>   = (1 &lt;&lt; 0),<span class="comment"></span>
<a name="l00665"></a>00665 <span class="comment">   /*! On match, don&apos;t return the object hence do not increase</span>
<a name="l00666"></a>00666 <span class="comment">    *  its refcount. */</span>
<a name="l00667"></a><a class="code" href="astobj2_8h.html#ad9d009e87e737af900825b36db55a35ca5fc59b193d86a0a8ddfe866304be829d">00667</a>    <a class="code" href="astobj2_8h.html#ad9d009e87e737af900825b36db55a35ca5fc59b193d86a0a8ddfe866304be829d">OBJ_NODATA</a>   = (1 &lt;&lt; 1),<span class="comment"></span>
<a name="l00668"></a>00668 <span class="comment">   /*! Don&apos;t stop at the first match in ao2_callback()</span>
<a name="l00669"></a>00669 <span class="comment">    *  \note This is not fully implemented.   Using OBJ_MULTIME with OBJ_NODATA</span>
<a name="l00670"></a>00670 <span class="comment">    *  is perfectly fine.  The part that is not implemented is the case where</span>
<a name="l00671"></a>00671 <span class="comment">    *  multiple objects should be returned by ao2_callback().</span>
<a name="l00672"></a>00672 <span class="comment">    */</span>
<a name="l00673"></a><a class="code" href="astobj2_8h.html#ad9d009e87e737af900825b36db55a35ca614744a4d36b3189d4ab5b02c8645d47">00673</a>    <a class="code" href="astobj2_8h.html#ad9d009e87e737af900825b36db55a35ca614744a4d36b3189d4ab5b02c8645d47">OBJ_MULTIPLE</a> = (1 &lt;&lt; 2),<span class="comment"></span>
<a name="l00674"></a>00674 <span class="comment">   /*! obj is an object of the same type as the one being searched for,</span>
<a name="l00675"></a>00675 <span class="comment">    *  so use the object&apos;s hash function for optimized searching.</span>
<a name="l00676"></a>00676 <span class="comment">    *  The search function is unaffected (i.e. use the one passed as</span>
<a name="l00677"></a>00677 <span class="comment">    *  argument, or match_by_addr if none specified). */</span>
<a name="l00678"></a><a class="code" href="astobj2_8h.html#ad9d009e87e737af900825b36db55a35ca32d49976aaebc093266f0b080f9c9a73">00678</a>    <a class="code" href="astobj2_8h.html#ad9d009e87e737af900825b36db55a35ca32d49976aaebc093266f0b080f9c9a73">OBJ_POINTER</a>  = (1 &lt;&lt; 3),<span class="comment"></span>
<a name="l00679"></a>00679 <span class="comment">   /*! </span>
<a name="l00680"></a>00680 <span class="comment">    * \brief Continue if a match is not found in the hashed out bucket</span>
<a name="l00681"></a>00681 <span class="comment">    *</span>
<a name="l00682"></a>00682 <span class="comment">    * This flag is to be used in combination with OBJ_POINTER.  This tells</span>
<a name="l00683"></a>00683 <span class="comment">    * the ao2_callback() core to keep searching through the rest of the</span>
<a name="l00684"></a>00684 <span class="comment">    * buckets if a match is not found in the starting bucket defined by</span>
<a name="l00685"></a>00685 <span class="comment">    * the hash value on the argument.</span>
<a name="l00686"></a>00686 <span class="comment">    */</span>
<a name="l00687"></a><a class="code" href="astobj2_8h.html#ad9d009e87e737af900825b36db55a35ca94dc57035c55d676cdbf9762c582b8aa">00687</a>    <a class="code" href="astobj2_8h.html#ad9d009e87e737af900825b36db55a35ca94dc57035c55d676cdbf9762c582b8aa" title="Continue if a match is not found in the hashed out bucket.">OBJ_CONTINUE</a>     = (1 &lt;&lt; 4),
<a name="l00688"></a>00688 };
<a name="l00689"></a>00689 <span class="comment"></span>
<a name="l00690"></a>00690 <span class="comment">/*!</span>
<a name="l00691"></a>00691 <span class="comment"> * Type of a generic function to generate a hash value from an object.</span>
<a name="l00692"></a>00692 <span class="comment"> * flags is ignored at the moment. Eventually, it will include the</span>
<a name="l00693"></a>00693 <span class="comment"> * value of OBJ_POINTER passed to ao2_callback().</span>
<a name="l00694"></a>00694 <span class="comment"> */</span>
<a name="l00695"></a><a class="code" href="astobj2_8h.html#ab29eb962131d79590e1ee1f07ba41818">00695</a> <span class="keyword">typedef</span> int (<a class="code" href="astobj2_8h.html#ab29eb962131d79590e1ee1f07ba41818">ao2_hash_fn</a>)(<span class="keyword">const</span> <span class="keywordtype">void</span> *obj, <span class="keyword">const</span> <span class="keywordtype">int</span> flags);
<a name="l00696"></a>00696 <span class="comment"></span>
<a name="l00697"></a>00697 <span class="comment">/*! \name Object Containers</span>
<a name="l00698"></a>00698 <span class="comment"> * Here start declarations of containers.</span>
<a name="l00699"></a>00699 <span class="comment"> */</span><span class="comment"></span>
<a name="l00700"></a>00700 <span class="comment">/*@{ */</span>
<a name="l00701"></a>00701 <span class="keyword">struct </span><a class="code" href="structao2__container.html">ao2_container</a>;
<a name="l00702"></a>00702 <span class="comment"></span>
<a name="l00703"></a>00703 <span class="comment">/*! \brief</span>
<a name="l00704"></a>00704 <span class="comment"> * Allocate and initialize a container</span>
<a name="l00705"></a>00705 <span class="comment"> * with the desired number of buckets.</span>
<a name="l00706"></a>00706 <span class="comment"> *</span>
<a name="l00707"></a>00707 <span class="comment"> * We allocate space for a struct astobj_container, struct container</span>
<a name="l00708"></a>00708 <span class="comment"> * and the buckets[] array.</span>
<a name="l00709"></a>00709 <span class="comment"> *</span>
<a name="l00710"></a>00710 <span class="comment"> * \param n_buckets Number of buckets for hash</span>
<a name="l00711"></a>00711 <span class="comment"> * \param hash_fn Pointer to a function computing a hash value.</span>
<a name="l00712"></a>00712 <span class="comment"> * \param cmp_fn Pointer to a function comparating key-value</span>
<a name="l00713"></a>00713 <span class="comment"> *          with a string. (can be NULL)</span>
<a name="l00714"></a>00714 <span class="comment"> * \return A pointer to a struct container.</span>
<a name="l00715"></a>00715 <span class="comment"> *</span>
<a name="l00716"></a>00716 <span class="comment"> * destructor is set implicitly.</span>
<a name="l00717"></a>00717 <span class="comment"> */</span>
<a name="l00718"></a>00718 
<a name="l00719"></a>00719 <span class="preprocessor">#if defined(REF_DEBUG)</span>
<a name="l00720"></a>00720 <span class="preprocessor"></span>
<a name="l00721"></a>00721 <span class="preprocessor">#define ao2_t_container_alloc(arg1,arg2,arg3,arg4) _ao2_container_alloc_debug((arg1), (arg2), (arg3), (arg4),  __FILE__, __LINE__, __PRETTY_FUNCTION__, 1)</span>
<a name="l00722"></a>00722 <span class="preprocessor"></span><span class="preprocessor">#define ao2_container_alloc(arg1,arg2,arg3)        _ao2_container_alloc_debug((arg1), (arg2), (arg3), &quot;&quot;,  __FILE__, __LINE__, __PRETTY_FUNCTION__, 1)</span>
<a name="l00723"></a>00723 <span class="preprocessor"></span>
<a name="l00724"></a>00724 <span class="preprocessor">#elif defined(__AST_DEBUG_MALLOC)</span>
<a name="l00725"></a>00725 <span class="preprocessor"></span>
<a name="l00726"></a><a class="code" href="astobj2_8h.html#a0963146a7af29455f2540e5654daa5f7">00726</a> <span class="preprocessor">#define ao2_t_container_alloc(arg1,arg2,arg3,arg4) _ao2_container_alloc_debug((arg1), (arg2), (arg3), (arg4),  __FILE__, __LINE__, __PRETTY_FUNCTION__, 0)</span>
<a name="l00727"></a><a class="code" href="astobj2_8h.html#a82534c91be59ec9a3d3318ec85ac5695">00727</a> <span class="preprocessor"></span><span class="preprocessor">#define ao2_container_alloc(arg1,arg2,arg3)        _ao2_container_alloc_debug((arg1), (arg2), (arg3), &quot;&quot;,  __FILE__, __LINE__, __PRETTY_FUNCTION__, 0)</span>
<a name="l00728"></a>00728 <span class="preprocessor"></span>
<a name="l00729"></a>00729 <span class="preprocessor">#else</span>
<a name="l00730"></a>00730 <span class="preprocessor"></span>
<a name="l00731"></a>00731 <span class="preprocessor">#define ao2_t_container_alloc(arg1,arg2,arg3,arg4) _ao2_container_alloc((arg1), (arg2), (arg3))</span>
<a name="l00732"></a>00732 <span class="preprocessor"></span><span class="preprocessor">#define ao2_container_alloc(arg1,arg2,arg3)        _ao2_container_alloc((arg1), (arg2), (arg3))</span>
<a name="l00733"></a>00733 <span class="preprocessor"></span>
<a name="l00734"></a>00734 <span class="preprocessor">#endif</span>
<a name="l00735"></a>00735 <span class="preprocessor"></span>
<a name="l00736"></a>00736 <span class="keyword">struct </span><a class="code" href="structao2__container.html">ao2_container</a> *<a class="code" href="astobj2_8h.html#ac98471c354880632e2ef7869a53b4e5d">_ao2_container_alloc</a>(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="structao2__container.html#a8f8a111ea93855d31480f7a4408a5be2">n_buckets</a>,
<a name="l00737"></a>00737                   <a class="code" href="astobj2_8h.html#ab29eb962131d79590e1ee1f07ba41818">ao2_hash_fn</a> *<a class="code" href="event_8c.html#affe6d185cf034f97d9e746dbfc8fb11c" title="Event type specific hash function.">hash_fn</a>, <a class="code" href="astobj2_8h.html#a4de0d949b2c7e11310c21ad64a83cf72" title="Type of a generic callback function.">ao2_callback_fn</a> *<a class="code" href="structao2__container.html#ab243d099d50c44002e75e91b0f077deb">cmp_fn</a>);
<a name="l00738"></a>00738 <span class="keyword">struct </span><a class="code" href="structao2__container.html">ao2_container</a> *<a class="code" href="astobj2_8h.html#a96b9708f9b7fa0d87ce611d275380779">_ao2_container_alloc_debug</a>(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="structao2__container.html#a8f8a111ea93855d31480f7a4408a5be2">n_buckets</a>,
<a name="l00739"></a>00739                    <a class="code" href="astobj2_8h.html#ab29eb962131d79590e1ee1f07ba41818">ao2_hash_fn</a> *<a class="code" href="event_8c.html#affe6d185cf034f97d9e746dbfc8fb11c" title="Event type specific hash function.">hash_fn</a>, <a class="code" href="astobj2_8h.html#a4de0d949b2c7e11310c21ad64a83cf72" title="Type of a generic callback function.">ao2_callback_fn</a> *<a class="code" href="structao2__container.html#ab243d099d50c44002e75e91b0f077deb">cmp_fn</a>,
<a name="l00740"></a>00740                    <span class="keywordtype">char</span> *tag, <span class="keywordtype">char</span> *file, <span class="keywordtype">int</span> line, <span class="keyword">const</span> <span class="keywordtype">char</span> *funcname,
<a name="l00741"></a>00741                    <span class="keywordtype">int</span> ref_debug);
<a name="l00742"></a>00742 <span class="comment"></span>
<a name="l00743"></a>00743 <span class="comment">/*! \brief</span>
<a name="l00744"></a>00744 <span class="comment"> * Returns the number of elements in a container.</span>
<a name="l00745"></a>00745 <span class="comment"> */</span>
<a name="l00746"></a>00746 <span class="keywordtype">int</span> <a class="code" href="astobj2_8h.html#a512cc40ce96c63b3d5c78040baa4c9cd" title="Returns the number of elements in a container.">ao2_container_count</a>(<span class="keyword">struct</span> <a class="code" href="structao2__container.html">ao2_container</a> *c);
<a name="l00747"></a>00747 <span class="comment"></span>
<a name="l00748"></a>00748 <span class="comment">/*@} */</span>
<a name="l00749"></a>00749 <span class="comment"></span>
<a name="l00750"></a>00750 <span class="comment">/*! \name Object Management</span>
<a name="l00751"></a>00751 <span class="comment"> * Here we have functions to manage objects.</span>
<a name="l00752"></a>00752 <span class="comment"> *</span>
<a name="l00753"></a>00753 <span class="comment"> * We can use the functions below on any kind of</span>
<a name="l00754"></a>00754 <span class="comment"> * object defined by the user.</span>
<a name="l00755"></a>00755 <span class="comment"> */</span><span class="comment"></span>
<a name="l00756"></a>00756 <span class="comment">/*@{ */</span>
<a name="l00757"></a>00757 <span class="comment"></span>
<a name="l00758"></a>00758 <span class="comment">/*!</span>
<a name="l00759"></a>00759 <span class="comment"> * \brief Add an object to a container.</span>
<a name="l00760"></a>00760 <span class="comment"> *</span>
<a name="l00761"></a>00761 <span class="comment"> * \param c the container to operate on.</span>
<a name="l00762"></a>00762 <span class="comment"> * \param newobj the object to be added.</span>
<a name="l00763"></a>00763 <span class="comment"> *</span>
<a name="l00764"></a>00764 <span class="comment"> * \retval NULL on errors</span>
<a name="l00765"></a>00765 <span class="comment"> * \retval newobj on success.</span>
<a name="l00766"></a>00766 <span class="comment"> *</span>
<a name="l00767"></a>00767 <span class="comment"> * This function inserts an object in a container according its key.</span>
<a name="l00768"></a>00768 <span class="comment"> *</span>
<a name="l00769"></a>00769 <span class="comment"> * \note Remember to set the key before calling this function.</span>
<a name="l00770"></a>00770 <span class="comment"> *</span>
<a name="l00771"></a>00771 <span class="comment"> * \note This function automatically increases the reference count to account</span>
<a name="l00772"></a>00772 <span class="comment"> *       for the reference that the container now holds to the object.</span>
<a name="l00773"></a>00773 <span class="comment"> */</span>
<a name="l00774"></a>00774 <span class="preprocessor">#ifdef REF_DEBUG</span>
<a name="l00775"></a>00775 <span class="preprocessor"></span>
<a name="l00776"></a>00776 <span class="preprocessor">#define ao2_t_link(arg1, arg2, arg3) _ao2_link_debug((arg1), (arg2), (arg3),  __FILE__, __LINE__, __PRETTY_FUNCTION__)</span>
<a name="l00777"></a>00777 <span class="preprocessor"></span><span class="preprocessor">#define ao2_link(arg1, arg2)         _ao2_link_debug((arg1), (arg2), &quot;&quot;,  __FILE__, __LINE__, __PRETTY_FUNCTION__)</span>
<a name="l00778"></a>00778 <span class="preprocessor"></span>
<a name="l00779"></a>00779 <span class="preprocessor">#else</span>
<a name="l00780"></a>00780 <span class="preprocessor"></span>
<a name="l00781"></a><a class="code" href="astobj2_8h.html#adc3c0db3563654f7f71244961a4479dd">00781</a> <span class="preprocessor">#define ao2_t_link(arg1, arg2, arg3) _ao2_link((arg1), (arg2))</span>
<a name="l00782"></a><a class="code" href="astobj2_8h.html#a210544bdcc5afe0601d01d6e529c22d8">00782</a> <span class="preprocessor"></span><span class="preprocessor">#define ao2_link(arg1, arg2)         _ao2_link((arg1), (arg2))</span>
<a name="l00783"></a>00783 <span class="preprocessor"></span>
<a name="l00784"></a>00784 <span class="preprocessor">#endif</span>
<a name="l00785"></a>00785 <span class="preprocessor"></span>
<a name="l00786"></a>00786 <span class="keywordtype">void</span> *<a class="code" href="astobj2_8h.html#ac26df7b597bacc7320e1e6a46aeae9a3">_ao2_link_debug</a>(<span class="keyword">struct</span> <a class="code" href="structao2__container.html">ao2_container</a> *c, <span class="keywordtype">void</span> *new_obj, <span class="keywordtype">char</span> *tag, <span class="keywordtype">char</span> *file, <span class="keywordtype">int</span> line, <span class="keyword">const</span> <span class="keywordtype">char</span> *funcname);
<a name="l00787"></a>00787 <span class="keywordtype">void</span> *<a class="code" href="astobj2_8h.html#aa51c4e23ee87405f06a5f436216e9b5b">_ao2_link</a>(<span class="keyword">struct</span> <a class="code" href="structao2__container.html">ao2_container</a> *c, <span class="keywordtype">void</span> *newobj);
<a name="l00788"></a>00788 <span class="comment"></span>
<a name="l00789"></a>00789 <span class="comment">/*!</span>
<a name="l00790"></a>00790 <span class="comment"> * \brief Remove an object from a container</span>
<a name="l00791"></a>00791 <span class="comment"> *</span>
<a name="l00792"></a>00792 <span class="comment"> * \param c the container</span>
<a name="l00793"></a>00793 <span class="comment"> * \param obj the object to unlink</span>
<a name="l00794"></a>00794 <span class="comment"> *</span>
<a name="l00795"></a>00795 <span class="comment"> * \retval NULL, always</span>
<a name="l00796"></a>00796 <span class="comment"> *</span>
<a name="l00797"></a>00797 <span class="comment"> * \note The object requested to be unlinked must be valid.  However, if it turns</span>
<a name="l00798"></a>00798 <span class="comment"> *       out that it is not in the container, this function is still safe to</span>
<a name="l00799"></a>00799 <span class="comment"> *       be called.</span>
<a name="l00800"></a>00800 <span class="comment"> *</span>
<a name="l00801"></a>00801 <span class="comment"> * \note If the object gets unlinked from the container, the container&apos;s</span>
<a name="l00802"></a>00802 <span class="comment"> *       reference to the object will be automatically released. (The</span>
<a name="l00803"></a>00803 <span class="comment"> *       refcount will be decremented).</span>
<a name="l00804"></a>00804 <span class="comment"> */</span>
<a name="l00805"></a>00805 <span class="preprocessor">#ifdef REF_DEBUG</span>
<a name="l00806"></a>00806 <span class="preprocessor"></span>
<a name="l00807"></a>00807 <span class="preprocessor">#define ao2_t_unlink(arg1, arg2, arg3) _ao2_unlink_debug((arg1), (arg2), (arg3),  __FILE__, __LINE__, __PRETTY_FUNCTION__)</span>
<a name="l00808"></a>00808 <span class="preprocessor"></span><span class="preprocessor">#define ao2_unlink(arg1, arg2)         _ao2_unlink_debug((arg1), (arg2), &quot;&quot;,  __FILE__, __LINE__, __PRETTY_FUNCTION__)</span>
<a name="l00809"></a>00809 <span class="preprocessor"></span>
<a name="l00810"></a>00810 <span class="preprocessor">#else</span>
<a name="l00811"></a>00811 <span class="preprocessor"></span>
<a name="l00812"></a><a class="code" href="astobj2_8h.html#a483ff2b4557a1f0f9031ac85ce1d2004">00812</a> <span class="preprocessor">#define ao2_t_unlink(arg1, arg2, arg3) _ao2_unlink((arg1), (arg2))</span>
<a name="l00813"></a><a class="code" href="astobj2_8h.html#a1bd301bcff8b41c07adbecf93eb7dce7">00813</a> <span class="preprocessor"></span><span class="preprocessor">#define ao2_unlink(arg1, arg2)         _ao2_unlink((arg1), (arg2))</span>
<a name="l00814"></a>00814 <span class="preprocessor"></span>
<a name="l00815"></a>00815 <span class="preprocessor">#endif</span>
<a name="l00816"></a>00816 <span class="preprocessor"></span>
<a name="l00817"></a>00817 <span class="keywordtype">void</span> *<a class="code" href="astobj2_8h.html#a67726b01484280efb644a29114ca00b9">_ao2_unlink_debug</a>(<span class="keyword">struct</span> <a class="code" href="structao2__container.html">ao2_container</a> *c, <span class="keywordtype">void</span> *obj, <span class="keywordtype">char</span> *tag, <span class="keywordtype">char</span> *file, <span class="keywordtype">int</span> line, <span class="keyword">const</span> <span class="keywordtype">char</span> *funcname);
<a name="l00818"></a>00818 <span class="keywordtype">void</span> *<a class="code" href="astobj2_8h.html#a433e9ffdffae0842c144a75bc8fda81d">_ao2_unlink</a>(<span class="keyword">struct</span> <a class="code" href="structao2__container.html">ao2_container</a> *c, <span class="keywordtype">void</span> *obj);
<a name="l00819"></a>00819 
<a name="l00820"></a>00820 <span class="comment"></span>
<a name="l00821"></a>00821 <span class="comment">/*! \brief Used as return value if the flag OBJ_MULTIPLE is set */</span>
<a name="l00822"></a><a class="code" href="structao2__list.html">00822</a> <span class="keyword">struct </span><a class="code" href="structao2__list.html" title="Used as return value if the flag OBJ_MULTIPLE is set.">ao2_list</a> {
<a name="l00823"></a><a class="code" href="structao2__list.html#a71f5e0338e8f4914c6a1c861144dee7d">00823</a>    <span class="keyword">struct </span><a class="code" href="structao2__list.html" title="Used as return value if the flag OBJ_MULTIPLE is set.">ao2_list</a> *<a class="code" href="structao2__list.html#a71f5e0338e8f4914c6a1c861144dee7d">next</a>;
<a name="l00824"></a><a class="code" href="structao2__list.html#aa919482768c0eac179575481f77e0fa3">00824</a>    <span class="keywordtype">void</span> *obj;  <span class="comment">/* pointer to the user portion of the object */</span>
<a name="l00825"></a>00825 };
<a name="l00826"></a>00826 <span class="comment"></span>
<a name="l00827"></a>00827 <span class="comment">/*@} */</span>
<a name="l00828"></a>00828 <span class="comment"></span>
<a name="l00829"></a>00829 <span class="comment">/*! \brief</span>
<a name="l00830"></a>00830 <span class="comment"> * ao2_callback() is a generic function that applies cb_fn() to all objects</span>
<a name="l00831"></a>00831 <span class="comment"> * in a container, as described below.</span>
<a name="l00832"></a>00832 <span class="comment"> *</span>
<a name="l00833"></a>00833 <span class="comment"> * \param c A pointer to the container to operate on.</span>
<a name="l00834"></a>00834 <span class="comment"> * \param flags A set of flags specifying the operation to perform,</span>
<a name="l00835"></a>00835 <span class="comment">   partially used by the container code, but also passed to</span>
<a name="l00836"></a>00836 <span class="comment">   the callback.</span>
<a name="l00837"></a>00837 <span class="comment">     - If OBJ_NODATA is set, ao2_callback will return NULL. No refcounts</span>
<a name="l00838"></a>00838 <span class="comment">       of any of the traversed objects will be incremented.</span>
<a name="l00839"></a>00839 <span class="comment">       On the converse, if it is NOT set (the default), The ref count</span>
<a name="l00840"></a>00840 <span class="comment">       of each object for which CMP_MATCH was set will be incremented,</span>
<a name="l00841"></a>00841 <span class="comment">       and you will have no way of knowing which those are, until</span>
<a name="l00842"></a>00842 <span class="comment">       the multiple-object-return functionality is implemented.</span>
<a name="l00843"></a>00843 <span class="comment">     - If OBJ_POINTER is set, the traversed items will be restricted</span>
<a name="l00844"></a>00844 <span class="comment">       to the objects in the bucket that the object key hashes to.</span>
<a name="l00845"></a>00845 <span class="comment"> * \param cb_fn A function pointer, that will be called on all</span>
<a name="l00846"></a>00846 <span class="comment">    objects, to see if they match. This function returns CMP_MATCH</span>
<a name="l00847"></a>00847 <span class="comment">    if the object is matches the criteria; CMP_STOP if the traversal</span>
<a name="l00848"></a>00848 <span class="comment">    should immediately stop, or both (via bitwise ORing), if you find a</span>
<a name="l00849"></a>00849 <span class="comment">    match and want to end the traversal, and 0 if the object is not a match,</span>
<a name="l00850"></a>00850 <span class="comment">    but the traversal should continue. This is the function that is applied</span>
<a name="l00851"></a>00851 <span class="comment">    to each object traversed. It&apos;s arguments are:</span>
<a name="l00852"></a>00852 <span class="comment">        (void *obj, void *arg, int flags), where:</span>
<a name="l00853"></a>00853 <span class="comment">          obj is an object</span>
<a name="l00854"></a>00854 <span class="comment">          arg is the same as arg passed into ao2_callback</span>
<a name="l00855"></a>00855 <span class="comment">          flags is the same as flags passed into ao2_callback (flags are</span>
<a name="l00856"></a>00856 <span class="comment">           also used by ao2_callback).</span>
<a name="l00857"></a>00857 <span class="comment"> * \param arg passed to the callback.</span>
<a name="l00858"></a>00858 <span class="comment"> * \return  A pointer to the object found/marked,</span>
<a name="l00859"></a>00859 <span class="comment"> *       a pointer to a list of objects matching comparison function,</span>
<a name="l00860"></a>00860 <span class="comment"> *       NULL if not found.</span>
<a name="l00861"></a>00861 <span class="comment"> *</span>
<a name="l00862"></a>00862 <span class="comment"> * If the function returns any objects, their refcount is incremented,</span>
<a name="l00863"></a>00863 <span class="comment"> * and the caller is in charge of decrementing them once done.</span>
<a name="l00864"></a>00864 <span class="comment"> * Also, in case of multiple values returned, the list used</span>
<a name="l00865"></a>00865 <span class="comment"> * to store the objects must be freed by the caller.</span>
<a name="l00866"></a>00866 <span class="comment"> *</span>
<a name="l00867"></a>00867 <span class="comment"> * Typically, ao2_callback() is used for two purposes:</span>
<a name="l00868"></a>00868 <span class="comment"> * - to perform some action (including removal from the container) on one</span>
<a name="l00869"></a>00869 <span class="comment"> *   or more objects; in this case, cb_fn() can modify the object itself,</span>
<a name="l00870"></a>00870 <span class="comment"> *   and to perform deletion should set CMP_MATCH on the matching objects,</span>
<a name="l00871"></a>00871 <span class="comment"> *   and have OBJ_UNLINK set in flags.</span>
<a name="l00872"></a>00872 <span class="comment"> * - to look for a specific object in a container; in this case, cb_fn()</span>
<a name="l00873"></a>00873 <span class="comment"> *   should not modify the object, but just return a combination of</span>
<a name="l00874"></a>00874 <span class="comment"> *   CMP_MATCH and CMP_STOP on the desired object.</span>
<a name="l00875"></a>00875 <span class="comment"> * Other usages are also possible, of course.</span>
<a name="l00876"></a>00876 <span class="comment"></span>
<a name="l00877"></a>00877 <span class="comment"> * This function searches through a container and performs operations</span>
<a name="l00878"></a>00878 <span class="comment"> * on objects according on flags passed.</span>
<a name="l00879"></a>00879 <span class="comment"> * XXX describe better</span>
<a name="l00880"></a>00880 <span class="comment"> * The comparison is done calling the compare function set implicitly.</span>
<a name="l00881"></a>00881 <span class="comment"> * The p pointer can be a pointer to an object or to a key,</span>
<a name="l00882"></a>00882 <span class="comment"> * we can say this looking at flags value.</span>
<a name="l00883"></a>00883 <span class="comment"> * If p points to an object we will search for the object pointed</span>
<a name="l00884"></a>00884 <span class="comment"> * by this value, otherwise we serch for a key value.</span>
<a name="l00885"></a>00885 <span class="comment"> * If the key is not uniq we only find the first matching valued.</span>
<a name="l00886"></a>00886 <span class="comment"> * If we use the OBJ_MARK flags, we mark all the objects matching</span>
<a name="l00887"></a>00887 <span class="comment"> * the condition.</span>
<a name="l00888"></a>00888 <span class="comment"> *</span>
<a name="l00889"></a>00889 <span class="comment"> * The use of flags argument is the follow:</span>
<a name="l00890"></a>00890 <span class="comment"> *</span>
<a name="l00891"></a>00891 <span class="comment"> * OBJ_UNLINK     unlinks the object found</span>
<a name="l00892"></a>00892 <span class="comment"> * OBJ_NODATA     on match, do return an object</span>
<a name="l00893"></a>00893 <span class="comment"> *          Callbacks use OBJ_NODATA as a default</span>
<a name="l00894"></a>00894 <span class="comment"> *          functions such as find() do</span>
<a name="l00895"></a>00895 <span class="comment"> * OBJ_MULTIPLE      return multiple matches</span>
<a name="l00896"></a>00896 <span class="comment"> *          Default for _find() is no.</span>
<a name="l00897"></a>00897 <span class="comment"> *          to a key (not yet supported)</span>
<a name="l00898"></a>00898 <span class="comment"> * OBJ_POINTER       the pointer is an object pointer</span>
<a name="l00899"></a>00899 <span class="comment"> *</span>
<a name="l00900"></a>00900 <span class="comment"> * In case we return a list, the callee must take care to destroy</span>
<a name="l00901"></a>00901 <span class="comment"> * that list when no longer used.</span>
<a name="l00902"></a>00902 <span class="comment"> *</span>
<a name="l00903"></a>00903 <span class="comment"> * \note When the returned object is no longer in use, ao2_ref() should</span>
<a name="l00904"></a>00904 <span class="comment"> * be used to free the additional reference possibly created by this function.</span>
<a name="l00905"></a>00905 <span class="comment"> *</span>
<a name="l00906"></a>00906 <span class="comment"> * @{</span>
<a name="l00907"></a>00907 <span class="comment"> */</span>
<a name="l00908"></a>00908 <span class="preprocessor">#ifdef REF_DEBUG</span>
<a name="l00909"></a>00909 <span class="preprocessor"></span>
<a name="l00910"></a>00910 <span class="preprocessor">#define ao2_t_callback(c,flags,cb_fn,arg,tag) _ao2_callback_debug((c), (flags), (cb_fn), (arg), (tag), __FILE__, __LINE__, __PRETTY_FUNCTION__)</span>
<a name="l00911"></a>00911 <span class="preprocessor"></span><span class="preprocessor">#define ao2_callback(c,flags,cb_fn,arg)       _ao2_callback_debug((c), (flags), (cb_fn), (arg), &quot;&quot;, __FILE__, __LINE__, __PRETTY_FUNCTION__)</span>
<a name="l00912"></a>00912 <span class="preprocessor"></span>
<a name="l00913"></a>00913 <span class="preprocessor">#else</span>
<a name="l00914"></a>00914 <span class="preprocessor"></span>
<a name="l00915"></a><a class="code" href="astobj2_8h.html#aeca960ec22a1d0384f6e285b25df8501">00915</a> <span class="preprocessor">#define ao2_t_callback(c,flags,cb_fn,arg,tag) _ao2_callback((c), (flags), (cb_fn), (arg))</span>
<a name="l00916"></a><a class="code" href="astobj2_8h.html#a47857055118a703ae87ea5ebaf4842ed">00916</a> <span class="preprocessor"></span><span class="preprocessor">#define ao2_callback(c,flags,cb_fn,arg)       _ao2_callback((c), (flags), (cb_fn), (arg))</span>
<a name="l00917"></a>00917 <span class="preprocessor"></span>
<a name="l00918"></a>00918 <span class="preprocessor">#endif</span>
<a name="l00919"></a>00919 <span class="preprocessor"></span>
<a name="l00920"></a>00920 <span class="keywordtype">void</span> *<a class="code" href="astobj2_8h.html#af2131d6b7aa8aa592b86de680087b529">_ao2_callback_debug</a>(<span class="keyword">struct</span> <a class="code" href="structao2__container.html">ao2_container</a> *c, <span class="keyword">enum</span> <a class="code" href="astobj2_8h.html#ad9d009e87e737af900825b36db55a35c" title="Flags passed to ao2_callback() and ao2_hash_fn() to modify its behaviour.">search_flags</a> flags,
<a name="l00921"></a>00921                     <a class="code" href="astobj2_8h.html#a4de0d949b2c7e11310c21ad64a83cf72" title="Type of a generic callback function.">ao2_callback_fn</a> *cb_fn, <span class="keywordtype">void</span> *arg, <span class="keywordtype">char</span> *tag,
<a name="l00922"></a>00922                     <span class="keywordtype">char</span> *file, <span class="keywordtype">int</span> line, <span class="keyword">const</span> <span class="keywordtype">char</span> *funcname);
<a name="l00923"></a>00923 <span class="keywordtype">void</span> *<a class="code" href="astobj2_8h.html#a30b201eaf8b1b0ac4a3fa50077f9c7ce">_ao2_callback</a>(<span class="keyword">struct</span> <a class="code" href="structao2__container.html">ao2_container</a> *c,
<a name="l00924"></a>00924                <span class="keyword">enum</span> <a class="code" href="astobj2_8h.html#ad9d009e87e737af900825b36db55a35c" title="Flags passed to ao2_callback() and ao2_hash_fn() to modify its behaviour.">search_flags</a> flags,
<a name="l00925"></a>00925                <a class="code" href="astobj2_8h.html#a4de0d949b2c7e11310c21ad64a83cf72" title="Type of a generic callback function.">ao2_callback_fn</a> *cb_fn, <span class="keywordtype">void</span> *arg);<span class="comment"></span>
<a name="l00926"></a>00926 <span class="comment">/*! @} */</span>
<a name="l00927"></a>00927 <span class="comment"></span>
<a name="l00928"></a>00928 <span class="comment">/*! \brief</span>
<a name="l00929"></a>00929 <span class="comment"> * ao2_callback_data() is a generic function that applies cb_fn() to all objects</span>
<a name="l00930"></a>00930 <span class="comment"> * in a container.  It is functionally identical to ao2_callback() except that</span>
<a name="l00931"></a>00931 <span class="comment"> * instead of taking an ao2_callback_fn *, it takes an ao2_callback_data_fn *, and</span>
<a name="l00932"></a>00932 <span class="comment"> * allows the caller to pass in arbitrary data.</span>
<a name="l00933"></a>00933 <span class="comment"> *</span>
<a name="l00934"></a>00934 <span class="comment"> * This call would be used instead of ao2_callback() when the caller needs to pass</span>
<a name="l00935"></a>00935 <span class="comment"> * OBJ_POINTER as part of the flags argument (which in turn requires passing in a</span>
<a name="l00936"></a>00936 <span class="comment"> * prototype ao2 object for &apos;arg&apos;) and also needs access to other non-global data</span>
<a name="l00937"></a>00937 <span class="comment"> * to complete it&apos;s comparison or task.</span>
<a name="l00938"></a>00938 <span class="comment"> *</span>
<a name="l00939"></a>00939 <span class="comment"> * See the documentation for ao2_callback() for argument descriptions.</span>
<a name="l00940"></a>00940 <span class="comment"> *</span>
<a name="l00941"></a>00941 <span class="comment"> * \see ao2_callback()</span>
<a name="l00942"></a>00942 <span class="comment"> */</span>
<a name="l00943"></a>00943 <span class="preprocessor">#ifdef REF_DEBUG</span>
<a name="l00944"></a>00944 <span class="preprocessor"></span><span class="preprocessor">#define ao2_t_callback_data(arg1,arg2,arg3,arg4,arg5,arg6) _ao2_callback_data_debug((arg1), (arg2), (arg3), (arg4), (arg5), (arg6), __FILE__, __LINE__, __PRETTY_FUNCTION__)</span>
<a name="l00945"></a>00945 <span class="preprocessor"></span><span class="preprocessor">#define ao2_callback_data(arg1,arg2,arg3,arg4,arg5)        _ao2_callback_data_debug((arg1), (arg2), (arg3), (arg4), (arg5), &quot;&quot;, __FILE__, __LINE__, __PRETTY_FUNCTION__)</span>
<a name="l00946"></a>00946 <span class="preprocessor"></span><span class="preprocessor">#else</span>
<a name="l00947"></a><a class="code" href="astobj2_8h.html#a4e3309bf4c23b24972065ea81a26eee1">00947</a> <span class="preprocessor"></span><span class="preprocessor">#define ao2_t_callback_data(arg1,arg2,arg3,arg4,arg5,arg6) _ao2_callback_data((arg1), (arg2), (arg3), (arg4), (arg5))</span>
<a name="l00948"></a><a class="code" href="astobj2_8h.html#a8e503755d09d62167c82ca2ed28a18ff">00948</a> <span class="preprocessor"></span><span class="preprocessor">#define ao2_callback_data(arg1,arg2,arg3,arg4,arg5)        _ao2_callback_data((arg1), (arg2), (arg3), (arg4), (arg5))</span>
<a name="l00949"></a>00949 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00950"></a>00950 <span class="preprocessor"></span><span class="keywordtype">void</span> *<a class="code" href="astobj2_8h.html#a3dfc8ce69ff853de11f8f5cadc1e4ba5">_ao2_callback_data_debug</a>(<span class="keyword">struct</span> <a class="code" href="structao2__container.html">ao2_container</a> *c, <span class="keyword">enum</span> <a class="code" href="astobj2_8h.html#ad9d009e87e737af900825b36db55a35c" title="Flags passed to ao2_callback() and ao2_hash_fn() to modify its behaviour.">search_flags</a> flags,
<a name="l00951"></a>00951                     <a class="code" href="astobj2_8h.html#ae472805461071323e68cba1f441081f3" title="Type of a generic callback function.">ao2_callback_data_fn</a> *cb_fn, <span class="keywordtype">void</span> *arg, <span class="keywordtype">void</span> *data, <span class="keywordtype">char</span> *tag,
<a name="l00952"></a>00952                     <span class="keywordtype">char</span> *file, <span class="keywordtype">int</span> line, <span class="keyword">const</span> <span class="keywordtype">char</span> *funcname);
<a name="l00953"></a>00953 <span class="keywordtype">void</span> *<a class="code" href="astobj2_8h.html#ab950909059ac21e01244919265d1922a">_ao2_callback_data</a>(<span class="keyword">struct</span> <a class="code" href="structao2__container.html">ao2_container</a> *c,
<a name="l00954"></a>00954                <span class="keyword">enum</span> <a class="code" href="astobj2_8h.html#ad9d009e87e737af900825b36db55a35c" title="Flags passed to ao2_callback() and ao2_hash_fn() to modify its behaviour.">search_flags</a> flags,
<a name="l00955"></a>00955                <a class="code" href="astobj2_8h.html#ae472805461071323e68cba1f441081f3" title="Type of a generic callback function.">ao2_callback_data_fn</a> *cb_fn, <span class="keywordtype">void</span> *arg, <span class="keywordtype">void</span> *data);
<a name="l00956"></a>00956 <span class="comment"></span>
<a name="l00957"></a>00957 <span class="comment">/*! ao2_find() is a short hand for ao2_callback(c, flags, c-&gt;cmp_fn, arg)</span>
<a name="l00958"></a>00958 <span class="comment"> * XXX possibly change order of arguments ?</span>
<a name="l00959"></a>00959 <span class="comment"> */</span>
<a name="l00960"></a>00960 <span class="preprocessor">#ifdef REF_DEBUG</span>
<a name="l00961"></a>00961 <span class="preprocessor"></span>
<a name="l00962"></a>00962 <span class="preprocessor">#define ao2_t_find(arg1,arg2,arg3,arg4) _ao2_find_debug((arg1), (arg2), (arg3), (arg4), __FILE__, __LINE__, __PRETTY_FUNCTION__)</span>
<a name="l00963"></a>00963 <span class="preprocessor"></span><span class="preprocessor">#define ao2_find(arg1,arg2,arg3)        _ao2_find_debug((arg1), (arg2), (arg3), &quot;&quot;, __FILE__, __LINE__, __PRETTY_FUNCTION__)</span>
<a name="l00964"></a>00964 <span class="preprocessor"></span>
<a name="l00965"></a>00965 <span class="preprocessor">#else</span>
<a name="l00966"></a>00966 <span class="preprocessor"></span>
<a name="l00967"></a><a class="code" href="astobj2_8h.html#a804bb959fec31c062b3848316b8e80b1">00967</a> <span class="preprocessor">#define ao2_t_find(arg1,arg2,arg3,arg4) _ao2_find((arg1), (arg2), (arg3))</span>
<a name="l00968"></a><a class="code" href="astobj2_8h.html#a618587b42226725315b96db394b13673">00968</a> <span class="preprocessor"></span><span class="preprocessor">#define ao2_find(arg1,arg2,arg3)        _ao2_find((arg1), (arg2), (arg3))</span>
<a name="l00969"></a>00969 <span class="preprocessor"></span>
<a name="l00970"></a>00970 <span class="preprocessor">#endif</span>
<a name="l00971"></a>00971 <span class="preprocessor"></span>
<a name="l00972"></a>00972 <span class="keywordtype">void</span> *<a class="code" href="astobj2_8h.html#a5dbd3b81ca89a8474950a7e44ad8adc5">_ao2_find_debug</a>(<span class="keyword">struct</span> <a class="code" href="structao2__container.html">ao2_container</a> *c, <span class="keywordtype">void</span> *arg, <span class="keyword">enum</span> <a class="code" href="astobj2_8h.html#ad9d009e87e737af900825b36db55a35c" title="Flags passed to ao2_callback() and ao2_hash_fn() to modify its behaviour.">search_flags</a> flags, <span class="keywordtype">char</span> *tag, <span class="keywordtype">char</span> *file, <span class="keywordtype">int</span> line, <span class="keyword">const</span> <span class="keywordtype">char</span> *funcname);
<a name="l00973"></a>00973 <span class="keywordtype">void</span> *<a class="code" href="astobj2_8h.html#a1fbe06cf1b054fe94d7ff6b06343e7d0">_ao2_find</a>(<span class="keyword">struct</span> <a class="code" href="structao2__container.html">ao2_container</a> *c, <span class="keywordtype">void</span> *arg, <span class="keyword">enum</span> <a class="code" href="astobj2_8h.html#ad9d009e87e737af900825b36db55a35c" title="Flags passed to ao2_callback() and ao2_hash_fn() to modify its behaviour.">search_flags</a> flags);
<a name="l00974"></a>00974 <span class="comment"></span>
<a name="l00975"></a>00975 <span class="comment">/*! \brief</span>
<a name="l00976"></a>00976 <span class="comment"> *</span>
<a name="l00977"></a>00977 <span class="comment"> *</span>
<a name="l00978"></a>00978 <span class="comment"> * When we need to walk through a container, we use an</span>
<a name="l00979"></a>00979 <span class="comment"> * ao2_iterator to keep track of the current position.</span>
<a name="l00980"></a>00980 <span class="comment"> *</span>
<a name="l00981"></a>00981 <span class="comment"> * Because the navigation is typically done without holding the</span>
<a name="l00982"></a>00982 <span class="comment"> * lock on the container across the loop, objects can be inserted or deleted</span>
<a name="l00983"></a>00983 <span class="comment"> * or moved while we work. As a consequence, there is no guarantee that</span>
<a name="l00984"></a>00984 <span class="comment"> * we manage to touch all the elements in the container, and it is possible</span>
<a name="l00985"></a>00985 <span class="comment"> * that we touch the same object multiple times.</span>
<a name="l00986"></a>00986 <span class="comment"> *</span>
<a name="l00987"></a>00987 <span class="comment"> * However, within the current hash table container, the following is true:</span>
<a name="l00988"></a>00988 <span class="comment"> *  - It is not possible to miss an object in the container while iterating</span>
<a name="l00989"></a>00989 <span class="comment"> *    unless it gets added after the iteration begins and is added to a bucket</span>
<a name="l00990"></a>00990 <span class="comment"> *    that is before the one the current object is in.  In this case, even if</span>
<a name="l00991"></a>00991 <span class="comment"> *    you locked the container around the entire iteration loop, you still would</span>
<a name="l00992"></a>00992 <span class="comment"> *    not see this object, because it would still be waiting on the container</span>
<a name="l00993"></a>00993 <span class="comment"> *    lock so that it can be added.</span>
<a name="l00994"></a>00994 <span class="comment"> *  - It would be extremely rare to see an object twice.  The only way this can</span>
<a name="l00995"></a>00995 <span class="comment"> *    happen is if an object got unlinked from the container and added again</span>
<a name="l00996"></a>00996 <span class="comment"> *    during the same iteration.  Furthermore, when the object gets added back,</span>
<a name="l00997"></a>00997 <span class="comment"> *    it has to be in the current or later bucket for it to be seen again.</span>
<a name="l00998"></a>00998 <span class="comment"> *</span>
<a name="l00999"></a>00999 <span class="comment"> * An iterator must be first initialized with ao2_iterator_init(),</span>
<a name="l01000"></a>01000 <span class="comment"> * then we can use o = ao2_iterator_next() to move from one</span>
<a name="l01001"></a>01001 <span class="comment"> * element to the next. Remember that the object returned by</span>
<a name="l01002"></a>01002 <span class="comment"> * ao2_iterator_next() has its refcount incremented,</span>
<a name="l01003"></a>01003 <span class="comment"> * and the reference must be explicitly released when done with it.</span>
<a name="l01004"></a>01004 <span class="comment"> *</span>
<a name="l01005"></a>01005 <span class="comment"> * In addition, ao2_iterator_init() will hold a reference to the container</span>
<a name="l01006"></a>01006 <span class="comment"> * being iterated, which will be freed when ao2_iterator_destroy() is called</span>
<a name="l01007"></a>01007 <span class="comment"> * to free up the resources used by the iterator (if any).</span>
<a name="l01008"></a>01008 <span class="comment"> *</span>
<a name="l01009"></a>01009 <span class="comment"> * Example:</span>
<a name="l01010"></a>01010 <span class="comment"> *</span>
<a name="l01011"></a>01011 <span class="comment"> *  \code</span>
<a name="l01012"></a>01012 <span class="comment"> *</span>
<a name="l01013"></a>01013 <span class="comment"> *  struct ao2_container *c = ... // the container we want to iterate on</span>
<a name="l01014"></a>01014 <span class="comment"> *  struct ao2_iterator i;</span>
<a name="l01015"></a>01015 <span class="comment"> *  struct my_obj *o;</span>
<a name="l01016"></a>01016 <span class="comment"> *</span>
<a name="l01017"></a>01017 <span class="comment"> *  i = ao2_iterator_init(c, flags);</span>
<a name="l01018"></a>01018 <span class="comment"> *</span>
<a name="l01019"></a>01019 <span class="comment"> *  while ( (o = ao2_iterator_next(&amp;i)) ) {</span>
<a name="l01020"></a>01020 <span class="comment"> *     ... do something on o ...</span>
<a name="l01021"></a>01021 <span class="comment"> *     ao2_ref(o, -1);</span>
<a name="l01022"></a>01022 <span class="comment"> *  }</span>
<a name="l01023"></a>01023 <span class="comment"> *</span>
<a name="l01024"></a>01024 <span class="comment"> *  ao2_iterator_destroy(&amp;i);</span>
<a name="l01025"></a>01025 <span class="comment"> *</span>
<a name="l01026"></a>01026 <span class="comment"> *  \endcode</span>
<a name="l01027"></a>01027 <span class="comment"> *</span>
<a name="l01028"></a>01028 <span class="comment"> */</span>
<a name="l01029"></a>01029 <span class="comment"></span>
<a name="l01030"></a>01030 <span class="comment">/*! \brief</span>
<a name="l01031"></a>01031 <span class="comment"> * The astobj2 iterator</span>
<a name="l01032"></a>01032 <span class="comment"> *</span>
<a name="l01033"></a>01033 <span class="comment"> * \note You are not supposed to know the internals of an iterator!</span>
<a name="l01034"></a>01034 <span class="comment"> * We would like the iterator to be opaque, unfortunately</span>
<a name="l01035"></a>01035 <span class="comment"> * its size needs to be known if we want to store it around</span>
<a name="l01036"></a>01036 <span class="comment"> * without too much trouble.</span>
<a name="l01037"></a>01037 <span class="comment"> * Anyways...</span>
<a name="l01038"></a>01038 <span class="comment"> * The iterator has a pointer to the container, and a flags</span>
<a name="l01039"></a>01039 <span class="comment"> * field specifying various things e.g. whether the container</span>
<a name="l01040"></a>01040 <span class="comment"> * should be locked or not while navigating on it.</span>
<a name="l01041"></a>01041 <span class="comment"> * The iterator &quot;points&quot; to the current object, which is identified</span>
<a name="l01042"></a>01042 <span class="comment"> * by three values:</span>
<a name="l01043"></a>01043 <span class="comment"> *</span>
<a name="l01044"></a>01044 <span class="comment"> * - a bucket number;</span>
<a name="l01045"></a>01045 <span class="comment"> * - the object_id, which is also the container version number</span>
<a name="l01046"></a>01046 <span class="comment"> *   when the object was inserted. This identifies the object</span>
<a name="l01047"></a>01047 <span class="comment"> *   uniquely, however reaching the desired object requires</span>
<a name="l01048"></a>01048 <span class="comment"> *   scanning a list.</span>
<a name="l01049"></a>01049 <span class="comment"> * - a pointer, and a container version when we saved the pointer.</span>
<a name="l01050"></a>01050 <span class="comment"> *   If the container has not changed its version number, then we</span>
<a name="l01051"></a>01051 <span class="comment"> *   can safely follow the pointer to reach the object in constant time.</span>
<a name="l01052"></a>01052 <span class="comment"> *</span>
<a name="l01053"></a>01053 <span class="comment"> * Details are in the implementation of ao2_iterator_next()</span>
<a name="l01054"></a>01054 <span class="comment"> * A freshly-initialized iterator has bucket=0, version=0.</span>
<a name="l01055"></a>01055 <span class="comment"> */</span>
<a name="l01056"></a><a class="code" href="structao2__iterator.html">01056</a> <span class="keyword">struct </span><a class="code" href="structao2__iterator.html" title="When we need to walk through a container, we use an ao2_iterator to keep track of...">ao2_iterator</a> {<span class="comment"></span>
<a name="l01057"></a>01057 <span class="comment">   /*! the container */</span>
<a name="l01058"></a><a class="code" href="structao2__iterator.html#add66ef9875bb0ff1bd4747707d6f3333">01058</a>    <span class="keyword">struct </span><a class="code" href="structao2__container.html">ao2_container</a> *<a class="code" href="structao2__iterator.html#add66ef9875bb0ff1bd4747707d6f3333">c</a>;<span class="comment"></span>
<a name="l01059"></a>01059 <span class="comment">   /*! operation flags */</span>
<a name="l01060"></a><a class="code" href="structao2__iterator.html#ac8bf36fe0577cba66bccda3a6f7e80a4">01060</a>    <span class="keywordtype">int</span> <a class="code" href="structao2__iterator.html#ac8bf36fe0577cba66bccda3a6f7e80a4">flags</a>;<span class="comment"></span>
<a name="l01061"></a>01061 <span class="comment">   /*! current bucket */</span>
<a name="l01062"></a><a class="code" href="structao2__iterator.html#af3b6402e08f8dd9f3302dac6289d8088">01062</a>    <span class="keywordtype">int</span> <a class="code" href="structbucket.html">bucket</a>;<span class="comment"></span>
<a name="l01063"></a>01063 <span class="comment">   /*! container version */</span>
<a name="l01064"></a><a class="code" href="structao2__iterator.html#a31c8806ca907e988690301fd352fa1a3">01064</a>    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="structao2__iterator.html#a31c8806ca907e988690301fd352fa1a3">c_version</a>;<span class="comment"></span>
<a name="l01065"></a>01065 <span class="comment">   /*! pointer to the current object */</span>
<a name="l01066"></a><a class="code" href="structao2__iterator.html#aa919482768c0eac179575481f77e0fa3">01066</a>    <span class="keywordtype">void</span> *obj;<span class="comment"></span>
<a name="l01067"></a>01067 <span class="comment">   /*! container version when the object was created */</span>
<a name="l01068"></a><a class="code" href="structao2__iterator.html#a5408ac5df4c170828874e1b10b4c35a0">01068</a>    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="structao2__iterator.html#a5408ac5df4c170828874e1b10b4c35a0">version</a>;
<a name="l01069"></a>01069 };
<a name="l01070"></a>01070 <span class="comment"></span>
<a name="l01071"></a>01071 <span class="comment">/*! Flags that can be passed to ao2_iterator_init() to modify the behavior</span>
<a name="l01072"></a>01072 <span class="comment"> * of the iterator.</span>
<a name="l01073"></a>01073 <span class="comment"> */</span>
<a name="l01074"></a><a class="code" href="astobj2_8h.html#a7b5de2aa80f528d3dc554caadb8dc6ab">01074</a> <span class="keyword">enum</span> <a class="code" href="astobj2_8h.html#a7b5de2aa80f528d3dc554caadb8dc6ab">ao2_iterator_flags</a> {<span class="comment"></span>
<a name="l01075"></a>01075 <span class="comment">   /*! Prevents ao2_iterator_next() from locking the container</span>
<a name="l01076"></a>01076 <span class="comment">    * while retrieving the next object from it.</span>
<a name="l01077"></a>01077 <span class="comment">    */</span>
<a name="l01078"></a><a class="code" href="astobj2_8h.html#a7b5de2aa80f528d3dc554caadb8dc6aba42e2c6aadc44e4259a058a6675b7e7e4">01078</a>    <a class="code" href="astobj2_8h.html#a7b5de2aa80f528d3dc554caadb8dc6aba42e2c6aadc44e4259a058a6675b7e7e4">AO2_ITERATOR_DONTLOCK</a> = (1 &lt;&lt; 0),
<a name="l01079"></a>01079 };
<a name="l01080"></a>01080 <span class="comment"></span>
<a name="l01081"></a>01081 <span class="comment">/*!</span>
<a name="l01082"></a>01082 <span class="comment"> * \brief Create an iterator for a container</span>
<a name="l01083"></a>01083 <span class="comment"> *</span>
<a name="l01084"></a>01084 <span class="comment"> * \param c the container</span>
<a name="l01085"></a>01085 <span class="comment"> * \param flags one or more flags from ao2_iterator_flags</span>
<a name="l01086"></a>01086 <span class="comment"> *</span>
<a name="l01087"></a>01087 <span class="comment"> * \retval the constructed iterator</span>
<a name="l01088"></a>01088 <span class="comment"> *</span>
<a name="l01089"></a>01089 <span class="comment"> * \note This function does \b not take a pointer to an iterator;</span>
<a name="l01090"></a>01090 <span class="comment"> *       rather, it returns an iterator structure that should be</span>
<a name="l01091"></a>01091 <span class="comment"> *       assigned to (overwriting) an existing iterator structure</span>
<a name="l01092"></a>01092 <span class="comment"> *       allocated on the stack or on the heap.</span>
<a name="l01093"></a>01093 <span class="comment"> *</span>
<a name="l01094"></a>01094 <span class="comment"> * This function will take a reference on the container being iterated.</span>
<a name="l01095"></a>01095 <span class="comment"> *</span>
<a name="l01096"></a>01096 <span class="comment"> */</span>
<a name="l01097"></a>01097 <span class="keyword">struct </span><a class="code" href="structao2__iterator.html" title="When we need to walk through a container, we use an ao2_iterator to keep track of...">ao2_iterator</a> <a class="code" href="astobj2_8h.html#a288075de687152d297308ea1ea963edb" title="Create an iterator for a container.">ao2_iterator_init</a>(struct <a class="code" href="structao2__container.html">ao2_container</a> *<a class="code" href="structao2__iterator.html#add66ef9875bb0ff1bd4747707d6f3333">c</a>, <span class="keywordtype">int</span> <a class="code" href="structao2__iterator.html#ac8bf36fe0577cba66bccda3a6f7e80a4">flags</a>);
<a name="l01098"></a>01098 <span class="comment"></span>
<a name="l01099"></a>01099 <span class="comment">/*!</span>
<a name="l01100"></a>01100 <span class="comment"> * \brief Destroy a container iterator</span>
<a name="l01101"></a>01101 <span class="comment"> *</span>
<a name="l01102"></a>01102 <span class="comment"> * \param i the iterator to destroy</span>
<a name="l01103"></a>01103 <span class="comment"> *</span>
<a name="l01104"></a>01104 <span class="comment"> * \retval none</span>
<a name="l01105"></a>01105 <span class="comment"> *</span>
<a name="l01106"></a>01106 <span class="comment"> * This function will release the container reference held by the iterator</span>
<a name="l01107"></a>01107 <span class="comment"> * and any other resources it may be holding.</span>
<a name="l01108"></a>01108 <span class="comment"> *</span>
<a name="l01109"></a>01109 <span class="comment"> */</span>
<a name="l01110"></a>01110 <span class="keywordtype">void</span> <a class="code" href="astobj2_8h.html#a62d5d9e9d0fa281168e6a08ef4a52450" title="Destroy a container iterator.">ao2_iterator_destroy</a>(<span class="keyword">struct</span> <a class="code" href="structao2__iterator.html" title="When we need to walk through a container, we use an ao2_iterator to keep track of...">ao2_iterator</a> *i);
<a name="l01111"></a>01111 
<a name="l01112"></a>01112 <span class="preprocessor">#ifdef REF_DEBUG</span>
<a name="l01113"></a>01113 <span class="preprocessor"></span>
<a name="l01114"></a>01114 <span class="preprocessor">#define ao2_t_iterator_next(arg1, arg2) _ao2_iterator_next_debug((arg1), (arg2),  __FILE__, __LINE__, __PRETTY_FUNCTION__)</span>
<a name="l01115"></a>01115 <span class="preprocessor"></span><span class="preprocessor">#define ao2_iterator_next(arg1)         _ao2_iterator_next_debug((arg1), &quot;&quot;,  __FILE__, __LINE__, __PRETTY_FUNCTION__)</span>
<a name="l01116"></a>01116 <span class="preprocessor"></span>
<a name="l01117"></a>01117 <span class="preprocessor">#else</span>
<a name="l01118"></a>01118 <span class="preprocessor"></span>
<a name="l01119"></a><a class="code" href="astobj2_8h.html#aace7c75c12ac954ed78d72eb84ea0477">01119</a> <span class="preprocessor">#define ao2_t_iterator_next(arg1, arg2) _ao2_iterator_next((arg1))</span>
<a name="l01120"></a><a class="code" href="astobj2_8h.html#a1cf2fe1aafd3cb9e613eb48535a37ad5">01120</a> <span class="preprocessor"></span><span class="preprocessor">#define ao2_iterator_next(arg1)         _ao2_iterator_next((arg1))</span>
<a name="l01121"></a>01121 <span class="preprocessor"></span>
<a name="l01122"></a>01122 <span class="preprocessor">#endif</span>
<a name="l01123"></a>01123 <span class="preprocessor"></span>
<a name="l01124"></a>01124 <span class="keywordtype">void</span> *<a class="code" href="astobj2_8h.html#ac092231df7591e0517dbc9e05b38abde">_ao2_iterator_next_debug</a>(<span class="keyword">struct</span> <a class="code" href="structao2__iterator.html" title="When we need to walk through a container, we use an ao2_iterator to keep track of...">ao2_iterator</a> *a, <span class="keywordtype">char</span> *tag, <span class="keywordtype">char</span> *file, <span class="keywordtype">int</span> line, <span class="keyword">const</span> <span class="keywordtype">char</span> *funcname);
<a name="l01125"></a>01125 <span class="keywordtype">void</span> *<a class="code" href="astobj2_8h.html#a5ac650a7e344398ffff27fbbf2025a9d">_ao2_iterator_next</a>(<span class="keyword">struct</span> <a class="code" href="structao2__iterator.html" title="When we need to walk through a container, we use an ao2_iterator to keep track of...">ao2_iterator</a> *a);
<a name="l01126"></a>01126 
<a name="l01127"></a>01127 <span class="comment">/* extra functions */</span>
<a name="l01128"></a>01128 <span class="keywordtype">void</span> <a class="code" href="astobj2_8h.html#a96dd2bfd0e6c27a4deaa8356e7821ec5">ao2_bt</a>(<span class="keywordtype">void</span>);   <span class="comment">/* backtrace */</span>
<a name="l01129"></a>01129 
<a name="l01130"></a>01130 <span class="preprocessor">#endif </span><span class="comment">/* _ASTERISK_ASTOBJ2_H */</span>
</pre></div></div>
<hr size="1"/><address style="text-align: right;"><small>Generated on Wed May 5 15:18:29 2010 for Asterisk - the Open Source PBX by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.1 </small></address>
</body>
</html>
