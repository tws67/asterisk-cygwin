<HTML>
    <HEAD>
      <TITLE>Asterisk.org: Developer Documentation (5 May 2010)</TITLE>
      <LINK HREF="doxygen.css" REL="stylesheet" TYPE="text/css">
    </HEAD>
    <BODY BGCOLOR="#FFFFFF">
<div><font size="2" align="right">Wed May 5 15:22:10 2010</font></div>

<h2>Asterisk developer's documentation</h2>
<hr/>
<!-- Generated by Doxygen 1.6.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
  <div class="navpath"><a class="el" href="dir_afe38fc0ccf2e9eefca5d5c6b03503d9.html">main</a>
  </div>
</div>
<div class="contents">
<h1>hashtab.c File Reference</h1>
<p>code to implement generic hash <a class="el" href="structtables.html">tables</a>  
<a href="#_details">More...</a></p>
<code>#include &quot;<a class="el" href="asterisk_8h_source.html">asterisk.h</a>&quot;</code><br/>
<code>#include &lt;ctype.h&gt;</code><br/>
<code>#include &quot;<a class="el" href="lock_8h_source.html">asterisk/lock.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="frame_8h_source.html">asterisk/frame.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="channel_8h_source.html">asterisk/channel.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="cli_8h_source.html">asterisk/cli.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="term_8h_source.html">asterisk/term.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="utils_8h_source.html">asterisk/utils.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="threadstorage_8h_source.html">asterisk/threadstorage.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="linkedlists_8h_source.html">asterisk/linkedlists.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="hashtab_8h_source.html">asterisk/hashtab.h</a>&quot;</code><br/>

<p><a href="hashtab_8c_source.html">Go to the source code of this file.</a></p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="hashtab_8c.html#af2042c599c685acc02d267e9a4c906af">ast_hashtab_capacity</a> (struct <a class="el" href="structast__hashtab.html">ast_hashtab</a> *tab)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the size of the <a class="el" href="structbucket.html">bucket</a> array in the hashtab.  <a href="#af2042c599c685acc02d267e9a4c906af"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="hashtab_8c.html#a5d02fdad6e9d1d15946a028a52851f2b">ast_hashtab_compare_ints</a> (const void *a, const void *b)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compares two integers for equality.  <a href="#a5d02fdad6e9d1d15946a028a52851f2b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="hashtab_8c.html#ae179496ae1f9bbfd5608faa4a8d53310">ast_hashtab_compare_shorts</a> (const void *a, const void *b)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compares two shorts for equality.  <a href="#ae179496ae1f9bbfd5608faa4a8d53310"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="hashtab_8c.html#a86ab6cf47bb9ae77f1c2db2b515c1628">ast_hashtab_compare_strings</a> (const void *a, const void *b)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compares two strings for equality.  <a href="#a86ab6cf47bb9ae77f1c2db2b515c1628"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="hashtab_8c.html#a944f4df390d07aead023abdcf4b7fc2e">ast_hashtab_compare_strings_nocase</a> (const void *a, const void *b)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compares two strings for equality, ignoring case.  <a href="#a944f4df390d07aead023abdcf4b7fc2e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structast__hashtab.html">ast_hashtab</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="hashtab_8c.html#a85701d44df4ea1e746bde709a91a4192">ast_hashtab_create</a> (int initial_buckets, int(*compare)(const void *a, const void *b), int(*resize)(struct <a class="el" href="structast__hashtab.html">ast_hashtab</a> *), int(*newsize)(struct <a class="el" href="structast__hashtab.html">ast_hashtab</a> *tab), unsigned int(*hash)(const void *obj), int do_locking)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create the hashtable list.  <a href="#a85701d44df4ea1e746bde709a91a4192"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="hashtab_8c.html#a6103589badf8d9440a0cece2802c4c3a">ast_hashtab_destroy</a> (struct <a class="el" href="structast__hashtab.html">ast_hashtab</a> *tab, void(*objdestroyfunc)(void *obj))</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This func will free the hash table and all its memory.  <a href="#a6103589badf8d9440a0cece2802c4c3a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="hashtab_8c.html#a2d63b8b43b3d64700f5e4224c9a707d3">ast_hashtab_destroylock</a> (struct <a class="el" href="structast__hashtab.html">ast_hashtab</a> *tab)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Call this before you destroy the table.  <a href="#a2d63b8b43b3d64700f5e4224c9a707d3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structast__hashtab.html">ast_hashtab</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="hashtab_8c.html#a6cfc835043e3be16682295960edddb49">ast_hashtab_dup</a> (struct <a class="el" href="structast__hashtab.html">ast_hashtab</a> *tab, void *(*obj_dup_func)(const void *obj))</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return a copy of the hash table.  <a href="#a6cfc835043e3be16682295960edddb49"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="hashtab_8c.html#a9c804e9bfc8355c25197187f0c6d0265">ast_hashtab_end_traversal</a> (struct <a class="el" href="structast__hashtab__iter.html">ast_hashtab_iter</a> *it)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">end the traversal, free the iterator, unlock if necc.  <a href="#a9c804e9bfc8355c25197187f0c6d0265"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="hashtab_8c.html#ae52333d2a29053dce852f8a2d35ca421">ast_hashtab_get_stats</a> (struct <a class="el" href="structast__hashtab.html">ast_hashtab</a> *tab, int *biggest_bucket_size, int *resize_count, int *num_objects, int *num_buckets)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns key stats for the table.  <a href="#ae52333d2a29053dce852f8a2d35ca421"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">unsigned int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="hashtab_8c.html#afde347625b8fa97770889dbfca223f05">ast_hashtab_hash_int</a> (const int x)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">unsigned int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="hashtab_8c.html#a929b126fcbea935302155c72313bf645">ast_hashtab_hash_short</a> (const short x)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">unsigned int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="hashtab_8c.html#af8904cce564fd39de28b566bb8c261eb">ast_hashtab_hash_string</a> (const void *obj)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Hashes a string to a <a class="el" href="structnumber.html" title="Number structure.">number</a>.  <a href="#af8904cce564fd39de28b566bb8c261eb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">unsigned int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="hashtab_8c.html#a09610a365395d3d7b1a8ce18fc6e5b2c">ast_hashtab_hash_string_nocase</a> (const void *obj)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Hashes a string to a <a class="el" href="structnumber.html" title="Number structure.">number</a> ignoring case.  <a href="#a09610a365395d3d7b1a8ce18fc6e5b2c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">unsigned int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="hashtab_8c.html#ab39dc11651e79b5ac59e15a1be73e81f">ast_hashtab_hash_string_sax</a> (const void *obj)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Hashes a string to a <a class="el" href="structnumber.html" title="Number structure.">number</a> using a modified Shift-And-XOR algorithm.  <a href="#ab39dc11651e79b5ac59e15a1be73e81f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="hashtab_8c.html#af8f5e362aad984cbed2a1ece67717869">ast_hashtab_initlock</a> (struct <a class="el" href="structast__hashtab.html">ast_hashtab</a> *tab)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Call this after you create the table to init the lock.  <a href="#af8f5e362aad984cbed2a1ece67717869"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="hashtab_8c.html#af3e13ed429193a2bf4f0b9d93ac5d7c1">ast_hashtab_insert_immediate</a> (struct <a class="el" href="structast__hashtab.html">ast_hashtab</a> *tab, const void *obj)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Insert without checking.  <a href="#af3e13ed429193a2bf4f0b9d93ac5d7c1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="hashtab_8c.html#a1faf757f0e58decf2bbb2a924f7e5510">ast_hashtab_insert_immediate_bucket</a> (struct <a class="el" href="structast__hashtab.html">ast_hashtab</a> *tab, const void *obj, unsigned int h)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Insert without checking, hashing or locking.  <a href="#a1faf757f0e58decf2bbb2a924f7e5510"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="hashtab_8c.html#afc129daca552e4483e6990a1e37d7e51">ast_hashtab_insert_safe</a> (struct <a class="el" href="structast__hashtab.html">ast_hashtab</a> *tab, const void *obj)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Check and insert new object only if it is not there.  <a href="#afc129daca552e4483e6990a1e37d7e51"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="hashtab_8c.html#a78b1f7bc201afd020f6270378173bb79">ast_hashtab_lookup</a> (struct <a class="el" href="structast__hashtab.html">ast_hashtab</a> *tab, const void *obj)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Lookup this object in the hash table.  <a href="#a78b1f7bc201afd020f6270378173bb79"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="hashtab_8c.html#af629a9b97b7c185c9f0d691088e24fe9">ast_hashtab_lookup_bucket</a> (struct <a class="el" href="structast__hashtab.html">ast_hashtab</a> *tab, const void *obj, unsigned int *<a class="el" href="structbucket.html">bucket</a>)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Similar to ast_hashtab_lookup but sets h to the key hash value if the lookup fails.  <a href="#af629a9b97b7c185c9f0d691088e24fe9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="hashtab_8c.html#aa8bea126883ca6d3df972eb50110933a">ast_hashtab_lookup_internal</a> (struct <a class="el" href="structast__hashtab.html">ast_hashtab</a> *tab, const void *obj, unsigned int h)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="hashtab_8c.html#ad55e8dcfd056731bcdf275dee3dbad20">ast_hashtab_lookup_with_hash</a> (struct <a class="el" href="structast__hashtab.html">ast_hashtab</a> *tab, const void *obj, unsigned int hashval)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Use this if have the hash <a class="el" href="structval.html">val</a> for the object.  <a href="#ad55e8dcfd056731bcdf275dee3dbad20"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="hashtab_8c.html#a743bfd52a8c9eb5d939ff5944758d846">ast_hashtab_newsize_java</a> (struct <a class="el" href="structast__hashtab.html">ast_hashtab</a> *tab)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a prime <a class="el" href="structnumber.html" title="Number structure.">number</a> roughly 2x the current table size.  <a href="#a743bfd52a8c9eb5d939ff5944758d846"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="hashtab_8c.html#a9c96afbac0ae8e85362cf5d64f05d350">ast_hashtab_newsize_none</a> (struct <a class="el" href="structast__hashtab.html">ast_hashtab</a> *tab)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">always return current size -- no resizing  <a href="#a9c96afbac0ae8e85362cf5d64f05d350"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="hashtab_8c.html#ac7c44d4b109e42af1ad35c72979af131">ast_hashtab_newsize_tight</a> (struct <a class="el" href="structast__hashtab.html">ast_hashtab</a> *tab)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="hashtab_8c.html#a43983b6169e9a0f9af48cca5cf9d3197">ast_hashtab_next</a> (struct <a class="el" href="structast__hashtab__iter.html">ast_hashtab_iter</a> *it)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets the next object in the list, advances iter one step returns null on end of traversal.  <a href="#a43983b6169e9a0f9af48cca5cf9d3197"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="hashtab_8c.html#a56846aff6af7e13e3cffc9d21594fb40">ast_hashtab_rdlock</a> (struct <a class="el" href="structast__hashtab.html">ast_hashtab</a> *tab)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Request a read-lock on the table -- don't change anything!  <a href="#a56846aff6af7e13e3cffc9d21594fb40"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="hashtab_8c.html#a86729040ecad330864abfa0e2b2c0af1">ast_hashtab_remove_object_internal</a> (struct <a class="el" href="structast__hashtab.html">ast_hashtab</a> *tab, struct <a class="el" href="structast__hashtab__bucket.html">ast_hashtab_bucket</a> *b, int h)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="hashtab_8c.html#a313b62d20344c2c85461dd4ed893017c">ast_hashtab_remove_object_via_lookup</a> (struct <a class="el" href="structast__hashtab.html">ast_hashtab</a> *tab, void *obj)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Looks up the object, removes the corresponding <a class="el" href="structbucket.html">bucket</a>.  <a href="#a313b62d20344c2c85461dd4ed893017c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="hashtab_8c.html#ad7ee24c838111389b9781324364f8c00">ast_hashtab_remove_object_via_lookup_nolock</a> (struct <a class="el" href="structast__hashtab.html">ast_hashtab</a> *tab, void *obj)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Looks up the object, removes the corresponding <a class="el" href="structbucket.html">bucket</a>.  <a href="#ad7ee24c838111389b9781324364f8c00"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="hashtab_8c.html#a71bd19ff2f6fad1cf5e01f9b8cad6f66">ast_hashtab_remove_this_object</a> (struct <a class="el" href="structast__hashtab.html">ast_hashtab</a> *tab, void *obj)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Hash the object and then compare ptrs in <a class="el" href="structbucket.html">bucket</a> list instead of calling the compare routine, will remove the <a class="el" href="structbucket.html">bucket</a>.  <a href="#a71bd19ff2f6fad1cf5e01f9b8cad6f66"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="hashtab_8c.html#ae9ca6365402722ebda78f20c9245b1fe">ast_hashtab_remove_this_object_nolock</a> (struct <a class="el" href="structast__hashtab.html">ast_hashtab</a> *tab, void *obj)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Hash the object and then compare ptrs in <a class="el" href="structbucket.html">bucket</a> list instead of calling the compare routine, will remove the <a class="el" href="structbucket.html">bucket</a>.  <a href="#ae9ca6365402722ebda78f20c9245b1fe"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="hashtab_8c.html#a148f269e2a72507129357e2ef2fcd72e">ast_hashtab_resize</a> (struct <a class="el" href="structast__hashtab.html">ast_hashtab</a> *tab)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="hashtab_8c.html#aef63906caa0b965e9c8d8561600038e9">ast_hashtab_resize_java</a> (struct <a class="el" href="structast__hashtab.html">ast_hashtab</a> *tab)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Determines if a table resize should occur using the Java algorithm (if the table load factor is 75% or higher).  <a href="#aef63906caa0b965e9c8d8561600038e9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="hashtab_8c.html#af9b890f1277ab38f3b14b4fab1e311d3">ast_hashtab_resize_none</a> (struct <a class="el" href="structast__hashtab.html">ast_hashtab</a> *tab)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Effectively disables resizing by always returning 0, regardless of of load factor.  <a href="#af9b890f1277ab38f3b14b4fab1e311d3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="hashtab_8c.html#ad1c8c01df7f3a22daaf5b220dbd6eb5c">ast_hashtab_resize_tight</a> (struct <a class="el" href="structast__hashtab.html">ast_hashtab</a> *tab)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Causes a resize whenever the <a class="el" href="structnumber.html" title="Number structure.">number</a> of elements stored in the table exceeds the <a class="el" href="structnumber.html" title="Number structure.">number</a> of buckets in the table.  <a href="#ad1c8c01df7f3a22daaf5b220dbd6eb5c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="hashtab_8c.html#ac3452d3a8bca5b4f2611bb96b7a44f31">ast_hashtab_size</a> (struct <a class="el" href="structast__hashtab.html">ast_hashtab</a> *tab)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the <a class="el" href="structnumber.html" title="Number structure.">number</a> of elements stored in the hashtab.  <a href="#ac3452d3a8bca5b4f2611bb96b7a44f31"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structast__hashtab__iter.html">ast_hashtab_iter</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="hashtab_8c.html#ac5a19bffadbbd4eb31f190e576f88512">ast_hashtab_start_traversal</a> (struct <a class="el" href="structast__hashtab.html">ast_hashtab</a> *tab)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gives an iterator to hastable.  <a href="#ac5a19bffadbbd4eb31f190e576f88512"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structast__hashtab__iter.html">ast_hashtab_iter</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="hashtab_8c.html#a82f79ee2e22d2a5bba10f7730bc14a5c">ast_hashtab_start_write_traversal</a> (struct <a class="el" href="structast__hashtab.html">ast_hashtab</a> *tab)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gives an iterator to hastable.  <a href="#a82f79ee2e22d2a5bba10f7730bc14a5c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="hashtab_8c.html#a0075220de774384c45e3cf3906d51110">ast_hashtab_unlock</a> (struct <a class="el" href="structast__hashtab.html">ast_hashtab</a> *tab)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">release a read- or write- lock.  <a href="#a0075220de774384c45e3cf3906d51110"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="hashtab_8c.html#a2afda46f84d0aec79d91155b6981800a">ast_hashtab_wrlock</a> (struct <a class="el" href="structast__hashtab.html">ast_hashtab</a> *tab)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Request a write-lock on the table.  <a href="#a2afda46f84d0aec79d91155b6981800a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="hashtab_8c.html#a76a1018cc569eb65a6b29fab0a8481c1">ast_is_prime</a> (int <a class="el" href="adsistub_8c.html#af6fc584548091f45267cfaf7066119bd">num</a>)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Determines if the specified <a class="el" href="structnumber.html" title="Number structure.">number</a> is prime.  <a href="#a76a1018cc569eb65a6b29fab0a8481c1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="hashtab_8c.html#a0a70cc0111c648216070a8415fe6d133">tlist_add_head</a> (struct <a class="el" href="structast__hashtab__bucket.html">ast_hashtab_bucket</a> **head, struct <a class="el" href="structast__hashtab__bucket.html">ast_hashtab_bucket</a> *item)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="hashtab_8c.html#acea5c0d1395a2a9a8e5287a37b0b8c7c">tlist_del_item</a> (struct <a class="el" href="structast__hashtab__bucket.html">ast_hashtab_bucket</a> **head, struct <a class="el" href="structast__hashtab__bucket.html">ast_hashtab_bucket</a> *item)</td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>code to implement generic hash <a class="el" href="structtables.html">tables</a> </p>
<dl class="author"><dt><b>Author:</b></dt><dd>Steve Murphy &lt;<a href="mailto:murf@digium.com">murf@digium.com</a>&gt; </dd></dl>

<p>Definition in file <a class="el" href="hashtab_8c_source.html">hashtab.c</a>.</p>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="af2042c599c685acc02d267e9a4c906af"></a><!-- doxytag: member="hashtab.c::ast_hashtab_capacity" ref="af2042c599c685acc02d267e9a4c906af" args="(struct ast_hashtab *tab)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ast_hashtab_capacity </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structast__hashtab.html">ast_hashtab</a> *&nbsp;</td>
          <td class="paramname"> <em>tab</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the size of the <a class="el" href="structbucket.html">bucket</a> array in the hashtab. </p>

<p>Definition at line <a class="el" href="hashtab_8c_source.html#l00627">627</a> of file <a class="el" href="hashtab_8c_source.html">hashtab.c</a>.</p>

<p>References <a class="el" href="hashtab_8h_source.html#l00091">ast_hashtab::hash_tab_size</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00628"></a>00628 {
<a name="l00629"></a>00629    <span class="keywordflow">return</span> tab-&gt;<a class="code" href="structast__hashtab.html#a65e874326c71bc3cc8009f6899ca4eb6">hash_tab_size</a>;
<a name="l00630"></a>00630 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a5d02fdad6e9d1d15946a028a52851f2b"></a><!-- doxytag: member="hashtab.c::ast_hashtab_compare_ints" ref="a5d02fdad6e9d1d15946a028a52851f2b" args="(const void *a, const void *b)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ast_hashtab_compare_ints </td>
          <td>(</td>
          <td class="paramtype">const void *&nbsp;</td>
          <td class="paramname"> <em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&nbsp;</td>
          <td class="paramname"> <em>b</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compares two integers for equality. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>a</em>&nbsp;</td><td>an integer pointer (int *) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>b</em>&nbsp;</td><td>an integer pointer (int *) </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>0</em>&nbsp;</td><td>if the integers pointed to are equal </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>1</em>&nbsp;</td><td>if a is greater than b </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>-1</em>&nbsp;</td><td>if a is less than b </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="hashtab_8c_source.html#l00062">62</a> of file <a class="el" href="hashtab_8c_source.html">hashtab.c</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00063"></a>00063 {
<a name="l00064"></a>00064    <span class="keywordtype">int</span> ai = *((<span class="keywordtype">int</span> *) a);
<a name="l00065"></a>00065    <span class="keywordtype">int</span> bi = *((<span class="keywordtype">int</span> *) b);
<a name="l00066"></a>00066 
<a name="l00067"></a>00067    <span class="keywordflow">if</span> (ai &lt; bi)
<a name="l00068"></a>00068       <span class="keywordflow">return</span> -1;
<a name="l00069"></a>00069 
<a name="l00070"></a>00070    <span class="keywordflow">return</span> !(ai == bi);
<a name="l00071"></a>00071 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="ae179496ae1f9bbfd5608faa4a8d53310"></a><!-- doxytag: member="hashtab.c::ast_hashtab_compare_shorts" ref="ae179496ae1f9bbfd5608faa4a8d53310" args="(const void *a, const void *b)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ast_hashtab_compare_shorts </td>
          <td>(</td>
          <td class="paramtype">const void *&nbsp;</td>
          <td class="paramname"> <em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&nbsp;</td>
          <td class="paramname"> <em>b</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compares two shorts for equality. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>a</em>&nbsp;</td><td>a short pointer (short *) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>b</em>&nbsp;</td><td>a short pointer (short *) </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>0</em>&nbsp;</td><td>if the shorts pointed to are equal </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>1</em>&nbsp;</td><td>if a is greater than b </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>-1</em>&nbsp;</td><td>if a is less than b </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="hashtab_8c_source.html#l00073">73</a> of file <a class="el" href="hashtab_8c_source.html">hashtab.c</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00074"></a>00074 {
<a name="l00075"></a>00075    <span class="keywordtype">short</span> as = *((<span class="keywordtype">short</span> *) a);
<a name="l00076"></a>00076    <span class="keywordtype">short</span> bs = *((<span class="keywordtype">short</span> *) b);
<a name="l00077"></a>00077 
<a name="l00078"></a>00078    <span class="keywordflow">if</span> (as &lt; bs)
<a name="l00079"></a>00079       <span class="keywordflow">return</span> -1;
<a name="l00080"></a>00080 
<a name="l00081"></a>00081    <span class="keywordflow">return</span> !(as == bs);
<a name="l00082"></a>00082 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a86ab6cf47bb9ae77f1c2db2b515c1628"></a><!-- doxytag: member="hashtab.c::ast_hashtab_compare_strings" ref="a86ab6cf47bb9ae77f1c2db2b515c1628" args="(const void *a, const void *b)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ast_hashtab_compare_strings </td>
          <td>(</td>
          <td class="paramtype">const void *&nbsp;</td>
          <td class="paramname"> <em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&nbsp;</td>
          <td class="paramname"> <em>b</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compares two strings for equality. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>a</em>&nbsp;</td><td>a character string </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>b</em>&nbsp;</td><td>a character string </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>0</em>&nbsp;</td><td>if the strings match </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>&lt;0</em>&nbsp;</td><td>if string a is less than string b </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>&gt;0</em>&nbsp;</td><td>if string a is greather than string b </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="hashtab_8c_source.html#l00052">52</a> of file <a class="el" href="hashtab_8c_source.html">hashtab.c</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00053"></a>00053 {
<a name="l00054"></a>00054    <span class="keywordflow">return</span> strcmp(a, b);
<a name="l00055"></a>00055 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a944f4df390d07aead023abdcf4b7fc2e"></a><!-- doxytag: member="hashtab.c::ast_hashtab_compare_strings_nocase" ref="a944f4df390d07aead023abdcf4b7fc2e" args="(const void *a, const void *b)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ast_hashtab_compare_strings_nocase </td>
          <td>(</td>
          <td class="paramtype">const void *&nbsp;</td>
          <td class="paramname"> <em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&nbsp;</td>
          <td class="paramname"> <em>b</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compares two strings for equality, ignoring case. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>a</em>&nbsp;</td><td>a character string </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>b</em>&nbsp;</td><td>a character string </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>0</em>&nbsp;</td><td>if the strings match </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>&lt;0</em>&nbsp;</td><td>if string a is less than string b </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>&gt;0</em>&nbsp;</td><td>if string a is greather than string b </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="hashtab_8c_source.html#l00057">57</a> of file <a class="el" href="hashtab_8c_source.html">hashtab.c</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00058"></a>00058 {
<a name="l00059"></a>00059    <span class="keywordflow">return</span> strcasecmp(a, b);
<a name="l00060"></a>00060 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a85701d44df4ea1e746bde709a91a4192"></a><!-- doxytag: member="hashtab.c::ast_hashtab_create" ref="a85701d44df4ea1e746bde709a91a4192" args="(int initial_buckets, int(*compare)(const void *a, const void *b), int(*resize)(struct ast_hashtab *), int(*newsize)(struct ast_hashtab *tab), unsigned int(*hash)(const void *obj), int do_locking)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structast__hashtab.html">ast_hashtab</a>* ast_hashtab_create </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>initial_buckets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int(*)(const void *a, const void *b)&nbsp;</td>
          <td class="paramname"> <em>compare</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int(*)(struct <a class="el" href="structast__hashtab.html">ast_hashtab</a> *)&nbsp;</td>
          <td class="paramname"> <em>resize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int(*)(struct <a class="el" href="structast__hashtab.html">ast_hashtab</a> *tab)&nbsp;</td>
          <td class="paramname"> <em>newsize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int(*)(const void *obj)&nbsp;</td>
          <td class="paramname"> <em>hash</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>do_locking</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [read]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create the hashtable list. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>initial_buckets</em>&nbsp;</td><td>starting <a class="el" href="structnumber.html" title="Number structure.">number</a> of buckets </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>compare</em>&nbsp;</td><td>a func ptr to compare two elements in the hash -- cannot be null </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>resize</em>&nbsp;</td><td>a func ptr to decide if the table needs to be resized, a NULL ptr here will cause a default to be used </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>newsize</em>&nbsp;</td><td>a func ptr that returns a new size of the array. A NULL will cause a default to be used </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>hash</em>&nbsp;</td><td>a func ptr to do the hashing </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>do_locking</em>&nbsp;</td><td>use locks to guarantee safety of iterators/insertion/deletion -- real simpleminded right now </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="hashtab_8c_source.html#l00222">222</a> of file <a class="el" href="hashtab_8c_source.html">hashtab.c</a>.</p>

<p>References <a class="el" href="astmm_8c_source.html#l00199">__ast_calloc()</a>, <a class="el" href="hashtab_8h_source.html#l00082">ast_hashtab::array</a>, <a class="el" href="astmm_8h_source.html#l00072">ast_calloc</a>, <a class="el" href="hashtab_8c_source.html#l00127">ast_hashtab_newsize_java()</a>, <a class="el" href="hashtab_8c_source.html#l00084">ast_hashtab_resize_java()</a>, <a class="el" href="hashtab_8c_source.html#l00101">ast_is_prime()</a>, <a class="el" href="lock_8h_source.html#l01770">ast_rwlock_init()</a>, <a class="el" href="app__directory_8c_source.html#l00162">compare()</a>, <a class="el" href="structast__hashtab.html#a0f84e89988b57ec4039f039eb818be65">ast_hashtab::compare</a>, <a class="el" href="hashtab_8h_source.html#l00096">ast_hashtab::do_locking</a>, <a class="el" href="astmm_8h_source.html#l00084">free</a>, <a class="el" href="structast__hashtab.html#a391f7b59a3476dc3bf1ffa1b28852670">ast_hashtab::hash</a>, <a class="el" href="hashtab_8h_source.html#l00091">ast_hashtab::hash_tab_size</a>, <a class="el" href="hashtab_8h_source.html#l00098">ast_hashtab::lock</a>, <a class="el" href="structast__hashtab.html#aa50f8d4f1283e0b777dd85f17423fae1">ast_hashtab::newsize</a>, and <a class="el" href="structast__hashtab.html#a54c408904d1a28302f6cf7051b1dc9e2">ast_hashtab::resize</a>.</p>

<p>Referenced by <a class="el" href="pbx_8c_source.html#l07637">ast_add_extension2_lockopt()</a>, <a class="el" href="pbx_8c_source.html#l06424">ast_context_find_or_create()</a>, <a class="el" href="pbx__lua_8c_source.html#l00845">lua_register_switches()</a>, <a class="el" href="pbx__ael_8c_source.html#l00113">pbx_load_module()</a>, and <a class="el" href="sched_8c_source.html#l00239">sched_context_create()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00232"></a>00232 {
<a name="l00233"></a>00233    <span class="keyword">struct </span><a class="code" href="structast__hashtab.html">ast_hashtab</a> *ht;
<a name="l00234"></a>00234 
<a name="l00235"></a>00235 <span class="preprocessor">#if (defined(MALLOC_DEBUG) &amp;&amp; !defined(STANDALONE))</span>
<a name="l00236"></a>00236 <span class="preprocessor"></span>   <span class="keywordflow">if</span> (!(ht = <a class="code" href="astmm_8h.html#ad800d5c993a0c605f6e061bdef1b524c">__ast_calloc</a>(1, <span class="keyword">sizeof</span>(*ht), file, lineno, function)))
<a name="l00237"></a>00237 <span class="preprocessor">#else</span>
<a name="l00238"></a>00238 <span class="preprocessor"></span>   <span class="keywordflow">if</span> (!(ht = <a class="code" href="astmm_8h.html#a1cb33b63d94fbbde94234b062249e015">ast_calloc</a>(1, <span class="keyword">sizeof</span>(*ht))))
<a name="l00239"></a>00239 <span class="preprocessor">#endif</span>
<a name="l00240"></a>00240 <span class="preprocessor"></span>      <span class="keywordflow">return</span> NULL;
<a name="l00241"></a>00241 
<a name="l00242"></a>00242    <span class="keywordflow">while</span> (!<a class="code" href="hashtab_8h.html#a76a1018cc569eb65a6b29fab0a8481c1" title="Determines if the specified number is prime.">ast_is_prime</a>(initial_buckets)) <span class="comment">/* make sure this is prime */</span>
<a name="l00243"></a>00243       initial_buckets++;
<a name="l00244"></a>00244 
<a name="l00245"></a>00245 <span class="preprocessor">#if (defined(MALLOC_DEBUG) &amp;&amp; !defined(STANDALONE))</span>
<a name="l00246"></a>00246 <span class="preprocessor"></span>   <span class="keywordflow">if</span> (!(ht-&gt;<a class="code" href="structast__hashtab.html#ad4a34c85bbad8598fd1e6cf37608d370">array</a> = <a class="code" href="astmm_8h.html#ad800d5c993a0c605f6e061bdef1b524c">__ast_calloc</a>(initial_buckets, <span class="keyword">sizeof</span>(*(ht-&gt;<a class="code" href="structast__hashtab.html#ad4a34c85bbad8598fd1e6cf37608d370">array</a>)), file, lineno, function))) {
<a name="l00247"></a>00247 <span class="preprocessor">#else</span>
<a name="l00248"></a>00248 <span class="preprocessor"></span>   <span class="keywordflow">if</span> (!(ht-&gt;<a class="code" href="structast__hashtab.html#ad4a34c85bbad8598fd1e6cf37608d370">array</a> = <a class="code" href="astmm_8h.html#a1cb33b63d94fbbde94234b062249e015">ast_calloc</a>(initial_buckets, <span class="keyword">sizeof</span>(*(ht-&gt;<a class="code" href="structast__hashtab.html#ad4a34c85bbad8598fd1e6cf37608d370">array</a>))))) {
<a name="l00249"></a>00249 <span class="preprocessor">#endif</span>
<a name="l00250"></a>00250 <span class="preprocessor"></span>      <a class="code" href="astmm_8h.html#aa7157aa9480bb73f090dca36776419bf">free</a>(ht);
<a name="l00251"></a>00251       <span class="keywordflow">return</span> NULL;
<a name="l00252"></a>00252    }
<a name="l00253"></a>00253 
<a name="l00254"></a>00254    ht-&gt;<a class="code" href="structast__hashtab.html#a65e874326c71bc3cc8009f6899ca4eb6">hash_tab_size</a> = initial_buckets;
<a name="l00255"></a>00255    ht-&gt;<a class="code" href="structast__hashtab.html#a0f84e89988b57ec4039f039eb818be65">compare</a> = <a class="code" href="app__directory_8c.html#adf773af7f5d8ca288a3a68fc3659d95c">compare</a>;
<a name="l00256"></a>00256    ht-&gt;<a class="code" href="structast__hashtab.html#a54c408904d1a28302f6cf7051b1dc9e2">resize</a> = <a class="code" href="structast__hashtab.html#a54c408904d1a28302f6cf7051b1dc9e2">resize</a>;
<a name="l00257"></a>00257    ht-&gt;<a class="code" href="structast__hashtab.html#aa50f8d4f1283e0b777dd85f17423fae1">newsize</a> = <a class="code" href="structast__hashtab.html#aa50f8d4f1283e0b777dd85f17423fae1">newsize</a>;
<a name="l00258"></a>00258    ht-&gt;<a class="code" href="structast__hashtab.html#a391f7b59a3476dc3bf1ffa1b28852670">hash</a> = <a class="code" href="structast__hashtab.html#a391f7b59a3476dc3bf1ffa1b28852670">hash</a>;
<a name="l00259"></a>00259    ht-&gt;<a class="code" href="structast__hashtab.html#ac53417dd5a9c9583bdacc986bb861c60">do_locking</a> = <a class="code" href="structast__hashtab.html#ac53417dd5a9c9583bdacc986bb861c60">do_locking</a>;
<a name="l00260"></a>00260 
<a name="l00261"></a>00261    <span class="keywordflow">if</span> (<a class="code" href="structast__hashtab.html#ac53417dd5a9c9583bdacc986bb861c60">do_locking</a>)
<a name="l00262"></a>00262       <a class="code" href="lock_8h.html#aeae3552501126e03a4fa95f4acd0ee67">ast_rwlock_init</a>(&amp;ht-&gt;<a class="code" href="structast__hashtab.html#ace4e0066a5b24f84b90536e9906619f6">lock</a>);
<a name="l00263"></a>00263 
<a name="l00264"></a>00264    <span class="keywordflow">if</span> (!ht-&gt;<a class="code" href="structast__hashtab.html#a54c408904d1a28302f6cf7051b1dc9e2">resize</a>)
<a name="l00265"></a>00265       ht-&gt;<a class="code" href="structast__hashtab.html#a54c408904d1a28302f6cf7051b1dc9e2">resize</a> = <a class="code" href="hashtab_8h.html#aef63906caa0b965e9c8d8561600038e9" title="Determines if a table resize should occur using the Java algorithm (if the table...">ast_hashtab_resize_java</a>;
<a name="l00266"></a>00266 
<a name="l00267"></a>00267    <span class="keywordflow">if</span> (!ht-&gt;<a class="code" href="structast__hashtab.html#aa50f8d4f1283e0b777dd85f17423fae1">newsize</a>)
<a name="l00268"></a>00268       ht-&gt;<a class="code" href="structast__hashtab.html#aa50f8d4f1283e0b777dd85f17423fae1">newsize</a> = <a class="code" href="hashtab_8h.html#a743bfd52a8c9eb5d939ff5944758d846" title="Create a prime number roughly 2x the current table size.">ast_hashtab_newsize_java</a>;
<a name="l00269"></a>00269 
<a name="l00270"></a>00270    <span class="keywordflow">return</span> ht;
<a name="l00271"></a>00271 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a6103589badf8d9440a0cece2802c4c3a"></a><!-- doxytag: member="hashtab.c::ast_hashtab_destroy" ref="a6103589badf8d9440a0cece2802c4c3a" args="(struct ast_hashtab *tab, void(*objdestroyfunc)(void *obj))" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ast_hashtab_destroy </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structast__hashtab.html">ast_hashtab</a> *&nbsp;</td>
          <td class="paramname"> <em>tab</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(void *obj)&nbsp;</td>
          <td class="paramname"> <em>objdestroyfunc</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This func will free the hash table and all its memory. </p>
<dl class="note"><dt><b>Note:</b></dt><dd>It doesn't touch the objects stored in it, unless you specify a destroy func; it will call that func for each object in the hashtab, remove all the objects, and then free the hashtab itself. If no destroyfunc is specified then the routine will assume you will free it yourself. </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>tab</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>objdestroyfunc</em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="hashtab_8c_source.html#l00384">384</a> of file <a class="el" href="hashtab_8c_source.html">hashtab.c</a>.</p>

<p>References <a class="el" href="hashtab_8h_source.html#l00082">ast_hashtab::array</a>, <a class="el" href="lock_8h_source.html#l01786">ast_rwlock_destroy()</a>, <a class="el" href="lock_8h_source.html#l01791">ast_rwlock_unlock()</a>, <a class="el" href="lock_8h_source.html#l01827">ast_rwlock_wrlock()</a>, <a class="el" href="hashtab_8h_source.html#l00096">ast_hashtab::do_locking</a>, <a class="el" href="astmm_8h_source.html#l00084">free</a>, <a class="el" href="hashtab_8h_source.html#l00091">ast_hashtab::hash_tab_size</a>, <a class="el" href="hashtab_8h_source.html#l00098">ast_hashtab::lock</a>, <a class="el" href="hashtab_8h_source.html#l00073">ast_hashtab_bucket::object</a>, <a class="el" href="hashtab_8h_source.html#l00083">ast_hashtab::tlist</a>, and <a class="el" href="hashtab_8c_source.html#l00326">tlist_del_item()</a>.</p>

<p>Referenced by <a class="el" href="pbx_8c_source.html#l08229">__ast_internal_context_destroy()</a>, <a class="el" href="pbx_8c_source.html#l06623">ast_merge_contexts_and_delete()</a>, <a class="el" href="pbx_8c_source.html#l04525">destroy_exten()</a>, and <a class="el" href="sched_8c_source.html#l00260">sched_context_destroy()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00385"></a>00385 {
<a name="l00386"></a>00386    <span class="comment">/* this func will free the hash table and all its memory. It</span>
<a name="l00387"></a>00387 <span class="comment">      doesn&apos;t touch the objects stored in it */</span>
<a name="l00388"></a>00388    <span class="keywordflow">if</span> (tab) {
<a name="l00389"></a>00389 
<a name="l00390"></a>00390       <span class="keywordflow">if</span> (tab-&gt;<a class="code" href="structast__hashtab.html#ac53417dd5a9c9583bdacc986bb861c60">do_locking</a>)
<a name="l00391"></a>00391          <a class="code" href="lock_8h.html#a952527792bba2a323118ae911f9aa1f7">ast_rwlock_wrlock</a>(&amp;tab-&gt;<a class="code" href="structast__hashtab.html#ace4e0066a5b24f84b90536e9906619f6">lock</a>);
<a name="l00392"></a>00392 
<a name="l00393"></a>00393       <span class="keywordflow">if</span> (tab-&gt;<a class="code" href="structast__hashtab.html#ad4a34c85bbad8598fd1e6cf37608d370">array</a>) {
<a name="l00394"></a>00394          <span class="comment">/* go thru and destroy the buckets */</span>
<a name="l00395"></a>00395          <span class="keyword">struct </span><a class="code" href="structast__hashtab__bucket.html">ast_hashtab_bucket</a> *t;
<a name="l00396"></a>00396          <span class="keywordtype">int</span> i;
<a name="l00397"></a>00397 
<a name="l00398"></a>00398          <span class="keywordflow">while</span> (tab-&gt;<a class="code" href="structast__hashtab.html#abc3c4c519a852f85284868cb68c8a44e">tlist</a>) {
<a name="l00399"></a>00399             t = tab-&gt;<a class="code" href="structast__hashtab.html#abc3c4c519a852f85284868cb68c8a44e">tlist</a>;
<a name="l00400"></a>00400             <span class="keywordflow">if</span> (t-&gt;<a class="code" href="structast__hashtab__bucket.html#ac4fffd2513f3061cbd51acf5381177c8">object</a> &amp;&amp; objdestroyfunc) {
<a name="l00401"></a>00401                <span class="comment">/* I cast this because I&apos;m not going to MOD it, I&apos;m going to DESTROY</span>
<a name="l00402"></a>00402 <span class="comment">                * it.</span>
<a name="l00403"></a>00403 <span class="comment">                */</span>
<a name="l00404"></a>00404                (*objdestroyfunc)((<span class="keywordtype">void</span> *) t-&gt;<a class="code" href="structast__hashtab__bucket.html#ac4fffd2513f3061cbd51acf5381177c8">object</a>);
<a name="l00405"></a>00405             }
<a name="l00406"></a>00406 
<a name="l00407"></a>00407             <a class="code" href="hashtab_8c.html#acea5c0d1395a2a9a8e5287a37b0b8c7c">tlist_del_item</a>(&amp;(tab-&gt;<a class="code" href="structast__hashtab.html#abc3c4c519a852f85284868cb68c8a44e">tlist</a>), tab-&gt;<a class="code" href="structast__hashtab.html#abc3c4c519a852f85284868cb68c8a44e">tlist</a>);
<a name="l00408"></a>00408             <a class="code" href="astmm_8h.html#aa7157aa9480bb73f090dca36776419bf">free</a>(t);
<a name="l00409"></a>00409          }
<a name="l00410"></a>00410 
<a name="l00411"></a>00411          <span class="keywordflow">for</span> (i = 0; i &lt; tab-&gt;<a class="code" href="structast__hashtab.html#a65e874326c71bc3cc8009f6899ca4eb6">hash_tab_size</a>; i++) {
<a name="l00412"></a>00412             <span class="comment">/* Not totally necessary, but best to destroy old pointers */</span>
<a name="l00413"></a>00413             tab-&gt;<a class="code" href="structast__hashtab.html#ad4a34c85bbad8598fd1e6cf37608d370">array</a>[i] = NULL;
<a name="l00414"></a>00414          }
<a name="l00415"></a>00415          <a class="code" href="astmm_8h.html#aa7157aa9480bb73f090dca36776419bf">free</a>(tab-&gt;<a class="code" href="structast__hashtab.html#ad4a34c85bbad8598fd1e6cf37608d370">array</a>);
<a name="l00416"></a>00416       }
<a name="l00417"></a>00417       <span class="keywordflow">if</span> (tab-&gt;<a class="code" href="structast__hashtab.html#ac53417dd5a9c9583bdacc986bb861c60">do_locking</a>) {
<a name="l00418"></a>00418          <a class="code" href="lock_8h.html#a21ce13cd6c771d5855f47ae7a1dd50b6">ast_rwlock_unlock</a>(&amp;tab-&gt;<a class="code" href="structast__hashtab.html#ace4e0066a5b24f84b90536e9906619f6">lock</a>);
<a name="l00419"></a>00419          <a class="code" href="lock_8h.html#aa1e308479619b6e2a20c7b27479cafa9">ast_rwlock_destroy</a>(&amp;tab-&gt;<a class="code" href="structast__hashtab.html#ace4e0066a5b24f84b90536e9906619f6">lock</a>);
<a name="l00420"></a>00420       }
<a name="l00421"></a>00421       <a class="code" href="astmm_8h.html#aa7157aa9480bb73f090dca36776419bf">free</a>(tab);
<a name="l00422"></a>00422    }
<a name="l00423"></a>00423 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a2d63b8b43b3d64700f5e4224c9a707d3"></a><!-- doxytag: member="hashtab.c::ast_hashtab_destroylock" ref="a2d63b8b43b3d64700f5e4224c9a707d3" args="(struct ast_hashtab *tab)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ast_hashtab_destroylock </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structast__hashtab.html">ast_hashtab</a> *&nbsp;</td>
          <td class="paramname"> <em>tab</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Call this before you destroy the table. </p>

<p>Definition at line <a class="el" href="hashtab_8c_source.html#l00374">374</a> of file <a class="el" href="hashtab_8c_source.html">hashtab.c</a>.</p>

<p>References <a class="el" href="lock_8h_source.html#l01786">ast_rwlock_destroy()</a>, and <a class="el" href="hashtab_8h_source.html#l00098">ast_hashtab::lock</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00375"></a>00375 {
<a name="l00376"></a>00376    <a class="code" href="lock_8h.html#aa1e308479619b6e2a20c7b27479cafa9">ast_rwlock_destroy</a>(&amp;tab-&gt;<a class="code" href="structast__hashtab.html#ace4e0066a5b24f84b90536e9906619f6">lock</a>);
<a name="l00377"></a>00377 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a6cfc835043e3be16682295960edddb49"></a><!-- doxytag: member="hashtab.c::ast_hashtab_dup" ref="a6cfc835043e3be16682295960edddb49" args="(struct ast_hashtab *tab, void *(*obj_dup_func)(const void *obj))" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structast__hashtab.html">ast_hashtab</a>* ast_hashtab_dup </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structast__hashtab.html">ast_hashtab</a> *&nbsp;</td>
          <td class="paramname"> <em>tab</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *(*)(const void *obj)&nbsp;</td>
          <td class="paramname"> <em>obj_dup_func</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [read]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return a copy of the hash table. </p>

<p>Definition at line <a class="el" href="hashtab_8c_source.html#l00276">276</a> of file <a class="el" href="hashtab_8c_source.html">hashtab.c</a>.</p>

<p>References <a class="el" href="astmm_8c_source.html#l00199">__ast_calloc()</a>, <a class="el" href="hashtab_8h_source.html#l00082">ast_hashtab::array</a>, <a class="el" href="astmm_8h_source.html#l00072">ast_calloc</a>, <a class="el" href="hashtab_8c_source.html#l00457">ast_hashtab_insert_immediate_bucket()</a>, <a class="el" href="lock_8h_source.html#l01770">ast_rwlock_init()</a>, <a class="el" href="structast__hashtab.html#a0f84e89988b57ec4039f039eb818be65">ast_hashtab::compare</a>, <a class="el" href="hashtab_8h_source.html#l00096">ast_hashtab::do_locking</a>, <a class="el" href="astmm_8h_source.html#l00084">free</a>, <a class="el" href="structast__hashtab.html#a391f7b59a3476dc3bf1ffa1b28852670">ast_hashtab::hash</a>, <a class="el" href="hashtab_8h_source.html#l00091">ast_hashtab::hash_tab_size</a>, <a class="el" href="hashtab_8h_source.html#l00098">ast_hashtab::lock</a>, <a class="el" href="structast__hashtab.html#aa50f8d4f1283e0b777dd85f17423fae1">ast_hashtab::newsize</a>, <a class="el" href="hashtab_8h_source.html#l00074">ast_hashtab_bucket::next</a>, <a class="el" href="hashtab_8h_source.html#l00073">ast_hashtab_bucket::object</a>, and <a class="el" href="structast__hashtab.html#a54c408904d1a28302f6cf7051b1dc9e2">ast_hashtab::resize</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00278"></a>00278 {
<a name="l00279"></a>00279    <span class="keyword">struct </span><a class="code" href="structast__hashtab.html">ast_hashtab</a> *ht;
<a name="l00280"></a>00280    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i;
<a name="l00281"></a>00281 
<a name="l00282"></a>00282    <span class="keywordflow">if</span> (!(ht = <a class="code" href="astmm_8h.html#a1cb33b63d94fbbde94234b062249e015">ast_calloc</a>(1, <span class="keyword">sizeof</span>(*ht))))
<a name="l00283"></a>00283       <span class="keywordflow">return</span> NULL;
<a name="l00284"></a>00284 
<a name="l00285"></a>00285    <span class="keywordflow">if</span> (!(ht-&gt;<a class="code" href="structast__hashtab.html#ad4a34c85bbad8598fd1e6cf37608d370">array</a> =
<a name="l00286"></a>00286 #if (defined(MALLOC_DEBUG) &amp;&amp; !defined(STANDALONE))
<a name="l00287"></a>00287       <a class="code" href="astmm_8h.html#ad800d5c993a0c605f6e061bdef1b524c">__ast_calloc</a>(tab-&gt;<a class="code" href="structast__hashtab.html#a65e874326c71bc3cc8009f6899ca4eb6">hash_tab_size</a>, <span class="keyword">sizeof</span>(*(ht-&gt;<a class="code" href="structast__hashtab.html#ad4a34c85bbad8598fd1e6cf37608d370">array</a>)), file, lineno, func)
<a name="l00288"></a>00288 #<span class="keywordflow">else</span>
<a name="l00289"></a>00289       <a class="code" href="astmm_8h.html#a1cb33b63d94fbbde94234b062249e015">ast_calloc</a>(tab-&gt;<a class="code" href="structast__hashtab.html#a65e874326c71bc3cc8009f6899ca4eb6">hash_tab_size</a>, <span class="keyword">sizeof</span>(*(ht-&gt;<a class="code" href="structast__hashtab.html#ad4a34c85bbad8598fd1e6cf37608d370">array</a>)))
<a name="l00290"></a>00290 #endif
<a name="l00291"></a>00291       )) {
<a name="l00292"></a>00292       <a class="code" href="astmm_8h.html#aa7157aa9480bb73f090dca36776419bf">free</a>(ht);
<a name="l00293"></a>00293       <span class="keywordflow">return</span> NULL;
<a name="l00294"></a>00294    }
<a name="l00295"></a>00295 
<a name="l00296"></a>00296    ht-&gt;<a class="code" href="structast__hashtab.html#a65e874326c71bc3cc8009f6899ca4eb6">hash_tab_size</a> = tab-&gt;<a class="code" href="structast__hashtab.html#a65e874326c71bc3cc8009f6899ca4eb6">hash_tab_size</a>;
<a name="l00297"></a>00297    ht-&gt;<a class="code" href="structast__hashtab.html#a0f84e89988b57ec4039f039eb818be65">compare</a> = tab-&gt;<a class="code" href="structast__hashtab.html#a0f84e89988b57ec4039f039eb818be65">compare</a>;
<a name="l00298"></a>00298    ht-&gt;<a class="code" href="structast__hashtab.html#a54c408904d1a28302f6cf7051b1dc9e2">resize</a> = tab-&gt;<a class="code" href="structast__hashtab.html#a54c408904d1a28302f6cf7051b1dc9e2">resize</a>;
<a name="l00299"></a>00299    ht-&gt;<a class="code" href="structast__hashtab.html#aa50f8d4f1283e0b777dd85f17423fae1">newsize</a> = tab-&gt;<a class="code" href="structast__hashtab.html#aa50f8d4f1283e0b777dd85f17423fae1">newsize</a>;
<a name="l00300"></a>00300    ht-&gt;<a class="code" href="structast__hashtab.html#a391f7b59a3476dc3bf1ffa1b28852670">hash</a> = tab-&gt;<a class="code" href="structast__hashtab.html#a391f7b59a3476dc3bf1ffa1b28852670">hash</a>;
<a name="l00301"></a>00301    ht-&gt;<a class="code" href="structast__hashtab.html#ac53417dd5a9c9583bdacc986bb861c60">do_locking</a> = tab-&gt;<a class="code" href="structast__hashtab.html#ac53417dd5a9c9583bdacc986bb861c60">do_locking</a>;
<a name="l00302"></a>00302 
<a name="l00303"></a>00303    <span class="keywordflow">if</span> (ht-&gt;<a class="code" href="structast__hashtab.html#ac53417dd5a9c9583bdacc986bb861c60">do_locking</a>)
<a name="l00304"></a>00304       <a class="code" href="lock_8h.html#aeae3552501126e03a4fa95f4acd0ee67">ast_rwlock_init</a>(&amp;ht-&gt;<a class="code" href="structast__hashtab.html#ace4e0066a5b24f84b90536e9906619f6">lock</a>);
<a name="l00305"></a>00305 
<a name="l00306"></a>00306    <span class="comment">/* now, dup the objects in the buckets and get them into the table */</span>
<a name="l00307"></a>00307    <span class="comment">/* the fast way is to use the existing array index, and not have to hash</span>
<a name="l00308"></a>00308 <span class="comment">      the objects again */</span>
<a name="l00309"></a>00309    <span class="keywordflow">for</span> (i = 0; i &lt; ht-&gt;<a class="code" href="structast__hashtab.html#a65e874326c71bc3cc8009f6899ca4eb6">hash_tab_size</a>; i++) {
<a name="l00310"></a>00310       <span class="keyword">struct </span><a class="code" href="structast__hashtab__bucket.html">ast_hashtab_bucket</a> *b = tab-&gt;<a class="code" href="structast__hashtab.html#ad4a34c85bbad8598fd1e6cf37608d370">array</a>[i];
<a name="l00311"></a>00311       <span class="keywordflow">while</span> (b) {
<a name="l00312"></a>00312          <span class="keywordtype">void</span> *newobj = (*obj_dup_func)(b-&gt;<a class="code" href="structast__hashtab__bucket.html#ac4fffd2513f3061cbd51acf5381177c8">object</a>);
<a name="l00313"></a>00313          <span class="keywordflow">if</span> (newobj)
<a name="l00314"></a>00314 <span class="preprocessor">#if (defined(MALLOC_DEBUG) &amp;&amp; !defined(STANDALONE))</span>
<a name="l00315"></a>00315 <span class="preprocessor"></span>            _ast_hashtab_insert_immediate_bucket(ht, newobj, i, file, lineno, func);
<a name="l00316"></a>00316 <span class="preprocessor">#else</span>
<a name="l00317"></a>00317 <span class="preprocessor"></span>            <a class="code" href="hashtab_8h.html#a1faf757f0e58decf2bbb2a924f7e5510" title="Insert without checking, hashing or locking.">ast_hashtab_insert_immediate_bucket</a>(ht, newobj, i);
<a name="l00318"></a>00318 <span class="preprocessor">#endif</span>
<a name="l00319"></a>00319 <span class="preprocessor"></span>         b = b-&gt;<a class="code" href="structast__hashtab__bucket.html#a277291f5bb0f819abb0f739591ccd961">next</a>;
<a name="l00320"></a>00320       }
<a name="l00321"></a>00321    }
<a name="l00322"></a>00322 
<a name="l00323"></a>00323    <span class="keywordflow">return</span> ht;
<a name="l00324"></a>00324 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a9c804e9bfc8355c25197187f0c6d0265"></a><!-- doxytag: member="hashtab.c::ast_hashtab_end_traversal" ref="a9c804e9bfc8355c25197187f0c6d0265" args="(struct ast_hashtab_iter *it)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ast_hashtab_end_traversal </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structast__hashtab__iter.html">ast_hashtab_iter</a> *&nbsp;</td>
          <td class="paramname"> <em>it</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>end the traversal, free the iterator, unlock if necc. </p>

<p>Definition at line <a class="el" href="hashtab_8c_source.html#l00742">742</a> of file <a class="el" href="hashtab_8c_source.html">hashtab.c</a>.</p>

<p>References <a class="el" href="lock_8h_source.html#l01791">ast_rwlock_unlock()</a>, <a class="el" href="hashtab_8h_source.html#l00096">ast_hashtab::do_locking</a>, <a class="el" href="astmm_8h_source.html#l00084">free</a>, <a class="el" href="hashtab_8h_source.html#l00098">ast_hashtab::lock</a>, and <a class="el" href="hashtab_8h_source.html#l00104">ast_hashtab_iter::tab</a>.</p>

<p>Referenced by <a class="el" href="pbx_8c_source.html#l08276">__ast_context_destroy()</a>, <a class="el" href="pbx_8c_source.html#l06623">ast_merge_contexts_and_delete()</a>, <a class="el" href="pbx_8c_source.html#l06539">context_merge()</a>, and <a class="el" href="pbx_8c_source.html#l02000">create_match_char_tree()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00743"></a>00743 {
<a name="l00744"></a>00744    <span class="keywordflow">if</span> (it-&gt;<a class="code" href="structast__hashtab__iter.html#a544ff1295545c4490180d179a5482f20">tab</a>-&gt;<a class="code" href="structast__hashtab.html#ac53417dd5a9c9583bdacc986bb861c60">do_locking</a>)
<a name="l00745"></a>00745       <a class="code" href="lock_8h.html#a21ce13cd6c771d5855f47ae7a1dd50b6">ast_rwlock_unlock</a>(&amp;it-&gt;<a class="code" href="structast__hashtab__iter.html#a544ff1295545c4490180d179a5482f20">tab</a>-&gt;<a class="code" href="structast__hashtab.html#ace4e0066a5b24f84b90536e9906619f6">lock</a>);
<a name="l00746"></a>00746    <a class="code" href="astmm_8h.html#aa7157aa9480bb73f090dca36776419bf">free</a>(it);
<a name="l00747"></a>00747 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="ae52333d2a29053dce852f8a2d35ca421"></a><!-- doxytag: member="hashtab.c::ast_hashtab_get_stats" ref="ae52333d2a29053dce852f8a2d35ca421" args="(struct ast_hashtab *tab, int *biggest_bucket_size, int *resize_count, int *num_objects, int *num_buckets)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ast_hashtab_get_stats </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structast__hashtab.html">ast_hashtab</a> *&nbsp;</td>
          <td class="paramname"> <em>tab</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>biggest_bucket_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>resize_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>num_objects</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>num_buckets</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns key stats for the table. </p>

<p>Definition at line <a class="el" href="hashtab_8c_source.html#l00607">607</a> of file <a class="el" href="hashtab_8c_source.html">hashtab.c</a>.</p>

<p>References <a class="el" href="lock_8h_source.html#l01796">ast_rwlock_rdlock()</a>, <a class="el" href="lock_8h_source.html#l01791">ast_rwlock_unlock()</a>, <a class="el" href="hashtab_8h_source.html#l00096">ast_hashtab::do_locking</a>, <a class="el" href="hashtab_8h_source.html#l00092">ast_hashtab::hash_tab_elements</a>, <a class="el" href="hashtab_8h_source.html#l00091">ast_hashtab::hash_tab_size</a>, <a class="el" href="hashtab_8h_source.html#l00093">ast_hashtab::largest_bucket_size</a>, <a class="el" href="hashtab_8h_source.html#l00098">ast_hashtab::lock</a>, and <a class="el" href="hashtab_8h_source.html#l00094">ast_hashtab::resize_count</a>.</p>

<p>Referenced by <a class="el" href="pbx_8c_source.html#l02000">create_match_char_tree()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00608"></a>00608 {
<a name="l00609"></a>00609    <span class="comment">/* returns key stats for the table */</span>
<a name="l00610"></a>00610    <span class="keywordflow">if</span> (tab-&gt;<a class="code" href="structast__hashtab.html#ac53417dd5a9c9583bdacc986bb861c60">do_locking</a>)
<a name="l00611"></a>00611       <a class="code" href="lock_8h.html#ae6703edce409c34119e27bdca1186d10">ast_rwlock_rdlock</a>(&amp;tab-&gt;<a class="code" href="structast__hashtab.html#ace4e0066a5b24f84b90536e9906619f6">lock</a>);
<a name="l00612"></a>00612    *biggest_bucket_size = tab-&gt;<a class="code" href="structast__hashtab.html#ad7e3544b53e89218feb557a33730eef2">largest_bucket_size</a>;
<a name="l00613"></a>00613    *resize_count = tab-&gt;<a class="code" href="structast__hashtab.html#aca6c133e85271118b482d523974fca7e">resize_count</a>;
<a name="l00614"></a>00614    *num_objects = tab-&gt;<a class="code" href="structast__hashtab.html#a46bc973b99fd63faabcf465499d58167">hash_tab_elements</a>;
<a name="l00615"></a>00615    *num_buckets = tab-&gt;<a class="code" href="structast__hashtab.html#a65e874326c71bc3cc8009f6899ca4eb6">hash_tab_size</a>;
<a name="l00616"></a>00616    <span class="keywordflow">if</span> (tab-&gt;<a class="code" href="structast__hashtab.html#ac53417dd5a9c9583bdacc986bb861c60">do_locking</a>)
<a name="l00617"></a>00617       <a class="code" href="lock_8h.html#a21ce13cd6c771d5855f47ae7a1dd50b6">ast_rwlock_unlock</a>(&amp;tab-&gt;<a class="code" href="structast__hashtab.html#ace4e0066a5b24f84b90536e9906619f6">lock</a>);
<a name="l00618"></a>00618 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="afde347625b8fa97770889dbfca223f05"></a><!-- doxytag: member="hashtab.c::ast_hashtab_hash_int" ref="afde347625b8fa97770889dbfca223f05" args="(const int x)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int ast_hashtab_hash_int </td>
          <td>(</td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>x</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="hashtab_8c_source.html#l00205">205</a> of file <a class="el" href="hashtab_8c_source.html">hashtab.c</a>.</p>

<p>Referenced by <a class="el" href="pbx_8c_source.html#l01053">hashtab_hash_priority()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00206"></a>00206 {
<a name="l00207"></a>00207    <span class="keywordflow">return</span> x;
<a name="l00208"></a>00208 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a929b126fcbea935302155c72313bf645"></a><!-- doxytag: member="hashtab.c::ast_hashtab_hash_short" ref="a929b126fcbea935302155c72313bf645" args="(const short x)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int ast_hashtab_hash_short </td>
          <td>(</td>
          <td class="paramtype">const short&nbsp;</td>
          <td class="paramname"> <em>x</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="hashtab_8c_source.html#l00210">210</a> of file <a class="el" href="hashtab_8c_source.html">hashtab.c</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00211"></a>00211 {
<a name="l00212"></a>00212    <span class="comment">/* hmmmm.... modulus is best &lt; 65535 !! */</span>
<a name="l00213"></a>00213    <span class="keywordflow">return</span> x;
<a name="l00214"></a>00214 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="af8904cce564fd39de28b566bb8c261eb"></a><!-- doxytag: member="hashtab.c::ast_hashtab_hash_string" ref="af8904cce564fd39de28b566bb8c261eb" args="(const void *obj)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int ast_hashtab_hash_string </td>
          <td>(</td>
          <td class="paramtype">const void *&nbsp;</td>
          <td class="paramname"> <em>obj</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Hashes a string to a <a class="el" href="structnumber.html" title="Number structure.">number</a>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>obj</em>&nbsp;</td><td>the string to hash </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Integer hash of the specified string </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd>ast_hashtable_hash_string_nocase </dd>
<dd>
<a class="el" href="hashtab_8c.html#ab39dc11651e79b5ac59e15a1be73e81f" title="Hashes a string to a number using a modified Shift-And-XOR algorithm.">ast_hashtab_hash_string_sax</a> </dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>A modulus will be applied to the return value of this function </dd></dl>

<p>Definition at line <a class="el" href="hashtab_8c_source.html#l00153">153</a> of file <a class="el" href="hashtab_8c_source.html">hashtab.c</a>.</p>

<p>References <a class="el" href="app__jack_8c_source.html#l00142">str</a>, and <a class="el" href="res__adsi_8c_source.html#l00893">total</a>.</p>

<p>Referenced by <a class="el" href="pbx_8c_source.html#l01037">ast_hashtab_hash_contexts()</a>, <a class="el" href="pbx_8c_source.html#l01043">hashtab_hash_extens()</a>, and <a class="el" href="pbx_8c_source.html#l01059">hashtab_hash_labels()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00154"></a>00154 {
<a name="l00155"></a>00155    <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *<a class="code" href="app__jack_8c.html#af25d6dc49269fa2003ac7c7fa6f13915">str</a> = (<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *) obj;
<a name="l00156"></a>00156    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="res__adsi_8c.html#ac7af894858cf396a219d632f40afdc8d">total</a>;
<a name="l00157"></a>00157 
<a name="l00158"></a>00158    <span class="keywordflow">for</span> (total = 0; *str; str++) {
<a name="l00159"></a>00159       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> tmp = total;
<a name="l00160"></a>00160       total &lt;&lt;= 1; <span class="comment">/* multiply by 2 */</span>
<a name="l00161"></a>00161       total += tmp; <span class="comment">/* multiply by 3 */</span>
<a name="l00162"></a>00162       total &lt;&lt;= 2; <span class="comment">/* multiply by 12 */</span>
<a name="l00163"></a>00163       total += tmp; <span class="comment">/* multiply by 13 */</span>
<a name="l00164"></a>00164 
<a name="l00165"></a>00165       total += ((<span class="keywordtype">unsigned</span> int)(*str));
<a name="l00166"></a>00166    }
<a name="l00167"></a>00167    <span class="keywordflow">return</span> total;
<a name="l00168"></a>00168 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a09610a365395d3d7b1a8ce18fc6e5b2c"></a><!-- doxytag: member="hashtab.c::ast_hashtab_hash_string_nocase" ref="a09610a365395d3d7b1a8ce18fc6e5b2c" args="(const void *obj)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int ast_hashtab_hash_string_nocase </td>
          <td>(</td>
          <td class="paramtype">const void *&nbsp;</td>
          <td class="paramname"> <em>obj</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Hashes a string to a <a class="el" href="structnumber.html" title="Number structure.">number</a> ignoring case. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>obj</em>&nbsp;</td><td>the string to hash </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Integer hash of the specified string </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd>ast_hashtable_hash_string </dd>
<dd>
<a class="el" href="hashtab_8c.html#ab39dc11651e79b5ac59e15a1be73e81f" title="Hashes a string to a number using a modified Shift-And-XOR algorithm.">ast_hashtab_hash_string_sax</a> </dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>A modulus will be applied to the return value of this function </dd></dl>

<p>Definition at line <a class="el" href="hashtab_8c_source.html#l00181">181</a> of file <a class="el" href="hashtab_8c_source.html">hashtab.c</a>.</p>

<p>References <a class="el" href="app__jack_8c_source.html#l00142">str</a>, and <a class="el" href="res__adsi_8c_source.html#l00893">total</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00182"></a>00182 {
<a name="l00183"></a>00183    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *<a class="code" href="app__jack_8c.html#af25d6dc49269fa2003ac7c7fa6f13915">str</a> = obj;
<a name="l00184"></a>00184    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="res__adsi_8c.html#ac7af894858cf396a219d632f40afdc8d">total</a>;
<a name="l00185"></a>00185 
<a name="l00186"></a>00186    <span class="keywordflow">for</span> (total = 0; *str; str++) {
<a name="l00187"></a>00187       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> tmp = total;
<a name="l00188"></a>00188       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> charval = toupper(*str);
<a name="l00189"></a>00189 
<a name="l00190"></a>00190       <span class="comment">/* hopefully, the following is faster than multiplication by 7 */</span>
<a name="l00191"></a>00191       <span class="comment">/* why do I go to this bother? A good compiler will do this</span>
<a name="l00192"></a>00192 <span class="comment">         anyway, if I say total *= 13 */</span>
<a name="l00193"></a>00193       <span class="comment">/* BTW, tried *= 7, and it doesn&apos;t do as well in spreading things around! */</span>
<a name="l00194"></a>00194       total &lt;&lt;= 1; <span class="comment">/* multiply by 2 */</span>
<a name="l00195"></a>00195       total += tmp; <span class="comment">/* multiply by 3 */</span>
<a name="l00196"></a>00196       total &lt;&lt;= 2; <span class="comment">/* multiply by 12 */</span>
<a name="l00197"></a>00197       total += tmp; <span class="comment">/* multiply by 13 */</span>
<a name="l00198"></a>00198 
<a name="l00199"></a>00199       total += (charval);
<a name="l00200"></a>00200    }
<a name="l00201"></a>00201 
<a name="l00202"></a>00202    <span class="keywordflow">return</span> total;
<a name="l00203"></a>00203 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="ab39dc11651e79b5ac59e15a1be73e81f"></a><!-- doxytag: member="hashtab.c::ast_hashtab_hash_string_sax" ref="ab39dc11651e79b5ac59e15a1be73e81f" args="(const void *obj)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int ast_hashtab_hash_string_sax </td>
          <td>(</td>
          <td class="paramtype">const void *&nbsp;</td>
          <td class="paramname"> <em>obj</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Hashes a string to a <a class="el" href="structnumber.html" title="Number structure.">number</a> using a modified Shift-And-XOR algorithm. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>obj</em>&nbsp;</td><td>the string to hash </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Integer has of the specified string </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd>ast_hastable_hash_string </dd>
<dd>
ast_hastable_hash_string_nocase </dd></dl>

<p>Definition at line <a class="el" href="hashtab_8c_source.html#l00170">170</a> of file <a class="el" href="hashtab_8c_source.html">hashtab.c</a>.</p>

<p>References <a class="el" href="app__jack_8c_source.html#l00142">str</a>, and <a class="el" href="res__adsi_8c_source.html#l00893">total</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00171"></a>00171 {
<a name="l00172"></a>00172    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *<a class="code" href="app__jack_8c.html#af25d6dc49269fa2003ac7c7fa6f13915">str</a> = obj;
<a name="l00173"></a>00173    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="res__adsi_8c.html#ac7af894858cf396a219d632f40afdc8d">total</a> = 0, c = 0;
<a name="l00174"></a>00174 
<a name="l00175"></a>00175    <span class="keywordflow">while</span> ((c = *str++))
<a name="l00176"></a>00176       total ^= (total &lt;&lt; 5) + (total &gt;&gt; 2) + (total &lt;&lt; 10) + c;
<a name="l00177"></a>00177 
<a name="l00178"></a>00178    <span class="keywordflow">return</span> total;
<a name="l00179"></a>00179 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="af8f5e362aad984cbed2a1ece67717869"></a><!-- doxytag: member="hashtab.c::ast_hashtab_initlock" ref="af8f5e362aad984cbed2a1ece67717869" args="(struct ast_hashtab *tab)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ast_hashtab_initlock </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structast__hashtab.html">ast_hashtab</a> *&nbsp;</td>
          <td class="paramname"> <em>tab</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Call this after you create the table to init the lock. </p>

<p>Definition at line <a class="el" href="hashtab_8c_source.html#l00369">369</a> of file <a class="el" href="hashtab_8c_source.html">hashtab.c</a>.</p>

<p>References <a class="el" href="lock_8h_source.html#l01770">ast_rwlock_init()</a>, and <a class="el" href="hashtab_8h_source.html#l00098">ast_hashtab::lock</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00370"></a>00370 {
<a name="l00371"></a>00371    <a class="code" href="lock_8h.html#aeae3552501126e03a4fa95f4acd0ee67">ast_rwlock_init</a>(&amp;tab-&gt;<a class="code" href="structast__hashtab.html#ace4e0066a5b24f84b90536e9906619f6">lock</a>);
<a name="l00372"></a>00372 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="af3e13ed429193a2bf4f0b9d93ac5d7c1"></a><!-- doxytag: member="hashtab.c::ast_hashtab_insert_immediate" ref="af3e13ed429193a2bf4f0b9d93ac5d7c1" args="(struct ast_hashtab *tab, const void *obj)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ast_hashtab_insert_immediate </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structast__hashtab.html">ast_hashtab</a> *&nbsp;</td>
          <td class="paramname"> <em>tab</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&nbsp;</td>
          <td class="paramname"> <em>obj</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Insert without checking. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>tab</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>obj</em>&nbsp;</td><td>Normally, you'd insert "safely" by checking to see if the element is already there; in this case, you must already have checked. If an element is already in the hashtable, that matches this one, most likely this one will be found first. </td></tr>
  </table>
  </dd>
</dl>
<dl class="note"><dt><b>Note:</b></dt><dd>will force a resize if the resize func returns 1 </dd></dl>
<dl><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>1</em>&nbsp;</td><td>on success </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>0</em>&nbsp;</td><td>if there's a problem </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="hashtab_8c_source.html#l00428">428</a> of file <a class="el" href="hashtab_8c_source.html">hashtab.c</a>.</p>

<p>References <a class="el" href="hashtab_8c_source.html#l00457">ast_hashtab_insert_immediate_bucket()</a>, <a class="el" href="lock_8h_source.html#l01791">ast_rwlock_unlock()</a>, <a class="el" href="lock_8h_source.html#l01827">ast_rwlock_wrlock()</a>, <a class="el" href="hashtab_8h_source.html#l00096">ast_hashtab::do_locking</a>, <a class="el" href="structast__hashtab.html#a391f7b59a3476dc3bf1ffa1b28852670">ast_hashtab::hash</a>, <a class="el" href="hashtab_8h_source.html#l00091">ast_hashtab::hash_tab_size</a>, and <a class="el" href="hashtab_8h_source.html#l00098">ast_hashtab::lock</a>.</p>

<p>Referenced by <a class="el" href="pbx_8c_source.html#l06424">ast_context_find_or_create()</a>, and <a class="el" href="pbx_8c_source.html#l04828">ast_context_remove_extension_callerid2()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00430"></a>00430 {
<a name="l00431"></a>00431    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> h;
<a name="l00432"></a>00432    <span class="keywordtype">int</span> res=0;
<a name="l00433"></a>00433 
<a name="l00434"></a>00434    <span class="keywordflow">if</span> (!tab || !obj)
<a name="l00435"></a>00435       <span class="keywordflow">return</span> res;
<a name="l00436"></a>00436 
<a name="l00437"></a>00437    <span class="keywordflow">if</span> (tab-&gt;<a class="code" href="structast__hashtab.html#ac53417dd5a9c9583bdacc986bb861c60">do_locking</a>)
<a name="l00438"></a>00438       <a class="code" href="lock_8h.html#a952527792bba2a323118ae911f9aa1f7">ast_rwlock_wrlock</a>(&amp;tab-&gt;<a class="code" href="structast__hashtab.html#ace4e0066a5b24f84b90536e9906619f6">lock</a>);
<a name="l00439"></a>00439 
<a name="l00440"></a>00440    h = (*tab-&gt;<a class="code" href="structast__hashtab.html#a391f7b59a3476dc3bf1ffa1b28852670">hash</a>)(obj) % tab-&gt;<a class="code" href="structast__hashtab.html#a65e874326c71bc3cc8009f6899ca4eb6">hash_tab_size</a>;
<a name="l00441"></a>00441 
<a name="l00442"></a>00442 <span class="preprocessor">#if (defined(MALLOC_DEBUG) &amp;&amp; !defined(STANDALONE))</span>
<a name="l00443"></a>00443 <span class="preprocessor"></span>   res = _ast_hashtab_insert_immediate_bucket(tab, obj, h, file, lineno, func);
<a name="l00444"></a>00444 <span class="preprocessor">#else</span>
<a name="l00445"></a>00445 <span class="preprocessor"></span>   res = <a class="code" href="hashtab_8h.html#a1faf757f0e58decf2bbb2a924f7e5510" title="Insert without checking, hashing or locking.">ast_hashtab_insert_immediate_bucket</a>(tab, obj, h);
<a name="l00446"></a>00446 <span class="preprocessor">#endif</span>
<a name="l00447"></a>00447 <span class="preprocessor"></span>
<a name="l00448"></a>00448    <span class="keywordflow">if</span> (tab-&gt;<a class="code" href="structast__hashtab.html#ac53417dd5a9c9583bdacc986bb861c60">do_locking</a>)
<a name="l00449"></a>00449       <a class="code" href="lock_8h.html#a21ce13cd6c771d5855f47ae7a1dd50b6">ast_rwlock_unlock</a>(&amp;tab-&gt;<a class="code" href="structast__hashtab.html#ace4e0066a5b24f84b90536e9906619f6">lock</a>);
<a name="l00450"></a>00450 
<a name="l00451"></a>00451    <span class="keywordflow">return</span> res;
<a name="l00452"></a>00452 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a1faf757f0e58decf2bbb2a924f7e5510"></a><!-- doxytag: member="hashtab.c::ast_hashtab_insert_immediate_bucket" ref="a1faf757f0e58decf2bbb2a924f7e5510" args="(struct ast_hashtab *tab, const void *obj, unsigned int h)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ast_hashtab_insert_immediate_bucket </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structast__hashtab.html">ast_hashtab</a> *&nbsp;</td>
          <td class="paramname"> <em>tab</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&nbsp;</td>
          <td class="paramname"> <em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>h</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Insert without checking, hashing or locking. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>tab</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>obj</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>h</em>&nbsp;</td><td>hashed index value</td></tr>
  </table>
  </dd>
</dl>
<dl class="note"><dt><b>Note:</b></dt><dd>Will force a resize if the resize func returns 1 </dd></dl>
<dl><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>1</em>&nbsp;</td><td>on success </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>0</em>&nbsp;</td><td>if there's a problem </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="hashtab_8c_source.html#l00457">457</a> of file <a class="el" href="hashtab_8c_source.html">hashtab.c</a>.</p>

<p>References <a class="el" href="astmm_8c_source.html#l00199">__ast_calloc()</a>, <a class="el" href="hashtab_8h_source.html#l00082">ast_hashtab::array</a>, <a class="el" href="astmm_8h_source.html#l00072">ast_calloc</a>, <a class="el" href="hashtab_8c_source.html#l00638">ast_hashtab_resize()</a>, <a class="el" href="hashtab_8h_source.html#l00092">ast_hashtab::hash_tab_elements</a>, <a class="el" href="hashtab_8h_source.html#l00093">ast_hashtab::largest_bucket_size</a>, <a class="el" href="hashtab_8h_source.html#l00074">ast_hashtab_bucket::next</a>, <a class="el" href="hashtab_8h_source.html#l00073">ast_hashtab_bucket::object</a>, <a class="el" href="hashtab_8h_source.html#l00075">ast_hashtab_bucket::prev</a>, <a class="el" href="structast__hashtab.html#a54c408904d1a28302f6cf7051b1dc9e2">ast_hashtab::resize</a>, <a class="el" href="hashtab_8h_source.html#l00083">ast_hashtab::tlist</a>, and <a class="el" href="hashtab_8c_source.html#l00341">tlist_add_head()</a>.</p>

<p>Referenced by <a class="el" href="hashtab_8c_source.html#l00276">ast_hashtab_dup()</a>, <a class="el" href="hashtab_8c_source.html#l00428">ast_hashtab_insert_immediate()</a>, and <a class="el" href="hashtab_8c_source.html#l00499">ast_hashtab_insert_safe()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00459"></a>00459 {
<a name="l00460"></a>00460    <span class="keywordtype">int</span> c;
<a name="l00461"></a>00461    <span class="keyword">struct </span><a class="code" href="structast__hashtab__bucket.html">ast_hashtab_bucket</a> *b;
<a name="l00462"></a>00462 
<a name="l00463"></a>00463    <span class="keywordflow">if</span> (!tab || !obj)
<a name="l00464"></a>00464       <span class="keywordflow">return</span> 0;
<a name="l00465"></a>00465 
<a name="l00466"></a>00466    <span class="keywordflow">for</span> (c = 0, b = tab-&gt;<a class="code" href="structast__hashtab.html#ad4a34c85bbad8598fd1e6cf37608d370">array</a>[h]; b; b= b-&gt;<a class="code" href="structast__hashtab__bucket.html#a277291f5bb0f819abb0f739591ccd961">next</a>)
<a name="l00467"></a>00467       c++;
<a name="l00468"></a>00468 
<a name="l00469"></a>00469    <span class="keywordflow">if</span> (c + 1 &gt; tab-&gt;<a class="code" href="structast__hashtab.html#ad7e3544b53e89218feb557a33730eef2">largest_bucket_size</a>)
<a name="l00470"></a>00470       tab-&gt;<a class="code" href="structast__hashtab.html#ad7e3544b53e89218feb557a33730eef2">largest_bucket_size</a> = c + 1;
<a name="l00471"></a>00471 
<a name="l00472"></a>00472    <span class="keywordflow">if</span> (!(b =
<a name="l00473"></a>00473 #<span class="keywordflow">if</span> (defined(MALLOC_DEBUG) &amp;&amp; !defined(STANDALONE))
<a name="l00474"></a>00474          <a class="code" href="astmm_8h.html#ad800d5c993a0c605f6e061bdef1b524c">__ast_calloc</a>(1, <span class="keyword">sizeof</span>(*b), file, lineno, func)
<a name="l00475"></a>00475 #<span class="keywordflow">else</span>
<a name="l00476"></a>00476          <a class="code" href="astmm_8h.html#a1cb33b63d94fbbde94234b062249e015">ast_calloc</a>(1, <span class="keyword">sizeof</span>(*b))
<a name="l00477"></a>00477 #endif
<a name="l00478"></a>00478       )) <span class="keywordflow">return</span> 0;
<a name="l00479"></a>00479 
<a name="l00480"></a>00480    b-&gt;<a class="code" href="structast__hashtab__bucket.html#ac4fffd2513f3061cbd51acf5381177c8">object</a> = obj;
<a name="l00481"></a>00481    b-&gt;<a class="code" href="structast__hashtab__bucket.html#a277291f5bb0f819abb0f739591ccd961">next</a> = tab-&gt;<a class="code" href="structast__hashtab.html#ad4a34c85bbad8598fd1e6cf37608d370">array</a>[h];
<a name="l00482"></a>00482    tab-&gt;<a class="code" href="structast__hashtab.html#ad4a34c85bbad8598fd1e6cf37608d370">array</a>[h] = b;
<a name="l00483"></a>00483 
<a name="l00484"></a>00484    <span class="keywordflow">if</span> (b-&gt;<a class="code" href="structast__hashtab__bucket.html#a277291f5bb0f819abb0f739591ccd961">next</a>)
<a name="l00485"></a>00485       b-&gt;<a class="code" href="structast__hashtab__bucket.html#a277291f5bb0f819abb0f739591ccd961">next</a>-&gt;<a class="code" href="structast__hashtab__bucket.html#af0ab45e37ae5f4c9a984ecea99ec9be4">prev</a> = b;
<a name="l00486"></a>00486 
<a name="l00487"></a>00487    <a class="code" href="hashtab_8c.html#a0a70cc0111c648216070a8415fe6d133">tlist_add_head</a>(&amp;(tab-&gt;<a class="code" href="structast__hashtab.html#abc3c4c519a852f85284868cb68c8a44e">tlist</a>), b);
<a name="l00488"></a>00488    tab-&gt;<a class="code" href="structast__hashtab.html#a46bc973b99fd63faabcf465499d58167">hash_tab_elements</a>++;
<a name="l00489"></a>00489 
<a name="l00490"></a>00490    <span class="keywordflow">if</span> ((*tab-&gt;<a class="code" href="structast__hashtab.html#a54c408904d1a28302f6cf7051b1dc9e2">resize</a>)(tab))
<a name="l00491"></a>00491       <a class="code" href="hashtab_8c.html#a148f269e2a72507129357e2ef2fcd72e">ast_hashtab_resize</a>(tab);
<a name="l00492"></a>00492 
<a name="l00493"></a>00493    <span class="keywordflow">return</span> 1;
<a name="l00494"></a>00494 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="afc129daca552e4483e6990a1e37d7e51"></a><!-- doxytag: member="hashtab.c::ast_hashtab_insert_safe" ref="afc129daca552e4483e6990a1e37d7e51" args="(struct ast_hashtab *tab, const void *obj)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ast_hashtab_insert_safe </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structast__hashtab.html">ast_hashtab</a> *&nbsp;</td>
          <td class="paramname"> <em>tab</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&nbsp;</td>
          <td class="paramname"> <em>obj</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Check and insert new object only if it is not there. </p>
<dl class="note"><dt><b>Note:</b></dt><dd>Will force a resize if the resize func returns 1 </dd></dl>
<dl><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>1</em>&nbsp;</td><td>on success </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>0</em>&nbsp;</td><td>if there's a problem, or it's already there. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="hashtab_8c_source.html#l00499">499</a> of file <a class="el" href="hashtab_8c_source.html">hashtab.c</a>.</p>

<p>References <a class="el" href="hashtab_8c_source.html#l00457">ast_hashtab_insert_immediate_bucket()</a>, <a class="el" href="hashtab_8c_source.html#l00575">ast_hashtab_lookup_bucket()</a>, <a class="el" href="lock_8h_source.html#l01791">ast_rwlock_unlock()</a>, <a class="el" href="lock_8h_source.html#l01827">ast_rwlock_wrlock()</a>, <a class="el" href="hashtab_8h_source.html#l00096">ast_hashtab::do_locking</a>, and <a class="el" href="hashtab_8h_source.html#l00098">ast_hashtab::lock</a>.</p>

<p>Referenced by <a class="el" href="pbx_8c_source.html#l07451">add_pri_lockopt()</a>, <a class="el" href="pbx_8c_source.html#l07637">ast_add_extension2_lockopt()</a>, <a class="el" href="pbx_8c_source.html#l06424">ast_context_find_or_create()</a>, and <a class="el" href="sched_8c_source.html#l00354">schedule()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00501"></a>00501 {
<a name="l00502"></a>00502    <span class="comment">/* check to see if the element is already there; insert only if</span>
<a name="l00503"></a>00503 <span class="comment">      it is not there. */</span>
<a name="l00504"></a>00504    <span class="comment">/* will force a resize if the resize func returns 1 */</span>
<a name="l00505"></a>00505    <span class="comment">/* returns 1 on success, 0 if there&apos;s a problem, or it&apos;s already there. */</span>
<a name="l00506"></a>00506    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="structbucket.html">bucket</a> = 0;
<a name="l00507"></a>00507 
<a name="l00508"></a>00508    <span class="keywordflow">if</span> (tab-&gt;<a class="code" href="structast__hashtab.html#ac53417dd5a9c9583bdacc986bb861c60">do_locking</a>)
<a name="l00509"></a>00509       <a class="code" href="lock_8h.html#a952527792bba2a323118ae911f9aa1f7">ast_rwlock_wrlock</a>(&amp;tab-&gt;<a class="code" href="structast__hashtab.html#ace4e0066a5b24f84b90536e9906619f6">lock</a>);
<a name="l00510"></a>00510 
<a name="l00511"></a>00511    <span class="keywordflow">if</span> (!<a class="code" href="hashtab_8h.html#a3e6e0ac05049c19407ca7c6ed473b968" title="Similar to ast_hashtab_lookup but sets h to the key hash value if the lookup fails...">ast_hashtab_lookup_bucket</a>(tab, obj, &amp;bucket)) {
<a name="l00512"></a>00512 <span class="preprocessor">#if (defined(MALLOC_DEBUG) &amp;&amp; !defined(STANDALONE))</span>
<a name="l00513"></a>00513 <span class="preprocessor"></span>      <span class="keywordtype">int</span> ret2 = _ast_hashtab_insert_immediate_bucket(tab, obj, bucket, file, lineno, func);
<a name="l00514"></a>00514 <span class="preprocessor">#else</span>
<a name="l00515"></a>00515 <span class="preprocessor"></span>      <span class="keywordtype">int</span> ret2 = <a class="code" href="hashtab_8h.html#a1faf757f0e58decf2bbb2a924f7e5510" title="Insert without checking, hashing or locking.">ast_hashtab_insert_immediate_bucket</a>(tab, obj, bucket);
<a name="l00516"></a>00516 <span class="preprocessor">#endif</span>
<a name="l00517"></a>00517 <span class="preprocessor"></span>
<a name="l00518"></a>00518       <span class="keywordflow">if</span> (tab-&gt;<a class="code" href="structast__hashtab.html#ac53417dd5a9c9583bdacc986bb861c60">do_locking</a>)
<a name="l00519"></a>00519          <a class="code" href="lock_8h.html#a21ce13cd6c771d5855f47ae7a1dd50b6">ast_rwlock_unlock</a>(&amp;tab-&gt;<a class="code" href="structast__hashtab.html#ace4e0066a5b24f84b90536e9906619f6">lock</a>);
<a name="l00520"></a>00520 
<a name="l00521"></a>00521       <span class="keywordflow">return</span> ret2;
<a name="l00522"></a>00522    }
<a name="l00523"></a>00523 
<a name="l00524"></a>00524    <span class="keywordflow">if</span> (tab-&gt;<a class="code" href="structast__hashtab.html#ac53417dd5a9c9583bdacc986bb861c60">do_locking</a>)
<a name="l00525"></a>00525       <a class="code" href="lock_8h.html#a21ce13cd6c771d5855f47ae7a1dd50b6">ast_rwlock_unlock</a>(&amp;tab-&gt;<a class="code" href="structast__hashtab.html#ace4e0066a5b24f84b90536e9906619f6">lock</a>);
<a name="l00526"></a>00526 
<a name="l00527"></a>00527    <span class="keywordflow">return</span> 0;
<a name="l00528"></a>00528 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a78b1f7bc201afd020f6270378173bb79"></a><!-- doxytag: member="hashtab.c::ast_hashtab_lookup" ref="a78b1f7bc201afd020f6270378173bb79" args="(struct ast_hashtab *tab, const void *obj)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* ast_hashtab_lookup </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structast__hashtab.html">ast_hashtab</a> *&nbsp;</td>
          <td class="paramname"> <em>tab</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&nbsp;</td>
          <td class="paramname"> <em>obj</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Lookup this object in the hash table. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>tab</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>obj</em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>a</em>&nbsp;</td><td>ptr if found </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>NULL</em>&nbsp;</td><td>if not found </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="hashtab_8c_source.html#l00530">530</a> of file <a class="el" href="hashtab_8c_source.html">hashtab.c</a>.</p>

<p>References <a class="el" href="hashtab_8c_source.html#l00593">ast_hashtab_lookup_internal()</a>, <a class="el" href="lock_8h_source.html#l01796">ast_rwlock_rdlock()</a>, <a class="el" href="lock_8h_source.html#l01791">ast_rwlock_unlock()</a>, <a class="el" href="hashtab_8h_source.html#l00096">ast_hashtab::do_locking</a>, <a class="el" href="structast__hashtab.html#a391f7b59a3476dc3bf1ffa1b28852670">ast_hashtab::hash</a>, <a class="el" href="hashtab_8h_source.html#l00091">ast_hashtab::hash_tab_size</a>, and <a class="el" href="hashtab_8h_source.html#l00098">ast_hashtab::lock</a>.</p>

<p>Referenced by <a class="el" href="pbx_8c_source.html#l07637">ast_add_extension2_lockopt()</a>, <a class="el" href="pbx_8c_source.html#l02430">ast_context_find()</a>, <a class="el" href="pbx_8c_source.html#l06424">ast_context_find_or_create()</a>, <a class="el" href="pbx_8c_source.html#l04988">ast_context_lockmacro()</a>, <a class="el" href="pbx_8c_source.html#l04828">ast_context_remove_extension_callerid2()</a>, <a class="el" href="pbx_8c_source.html#l05028">ast_context_unlockmacro()</a>, <a class="el" href="sched_8c_source.html#l00461">ast_sched_del()</a>, <a class="el" href="sched_8c_source.html#l00444">ast_sched_find_data()</a>, <a class="el" href="sched_8c_source.html#l00645">ast_sched_when()</a>, <a class="el" href="pbx_8c_source.html#l06539">context_merge()</a>, <a class="el" href="pbx_8c_source.html#l04641">find_context()</a>, <a class="el" href="pbx_8c_source.html#l04658">find_context_locked()</a>, and <a class="el" href="pbx_8c_source.html#l02469">pbx_find_extension()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00531"></a>00531 {
<a name="l00532"></a>00532    <span class="comment">/* lookup this object in the hash table. return a ptr if found, or NULL if not */</span>
<a name="l00533"></a>00533    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> h;
<a name="l00534"></a>00534    <span class="keywordtype">void</span> *ret;
<a name="l00535"></a>00535 
<a name="l00536"></a>00536    <span class="keywordflow">if</span> (!tab || !obj)
<a name="l00537"></a>00537       <span class="keywordflow">return</span> 0;
<a name="l00538"></a>00538 
<a name="l00539"></a>00539    <span class="keywordflow">if</span> (tab-&gt;<a class="code" href="structast__hashtab.html#ac53417dd5a9c9583bdacc986bb861c60">do_locking</a>)
<a name="l00540"></a>00540       <a class="code" href="lock_8h.html#ae6703edce409c34119e27bdca1186d10">ast_rwlock_rdlock</a>(&amp;tab-&gt;<a class="code" href="structast__hashtab.html#ace4e0066a5b24f84b90536e9906619f6">lock</a>);
<a name="l00541"></a>00541 
<a name="l00542"></a>00542    h = (*tab-&gt;<a class="code" href="structast__hashtab.html#a391f7b59a3476dc3bf1ffa1b28852670">hash</a>)(obj) % tab-&gt;<a class="code" href="structast__hashtab.html#a65e874326c71bc3cc8009f6899ca4eb6">hash_tab_size</a>;
<a name="l00543"></a>00543 
<a name="l00544"></a>00544    ret = <a class="code" href="hashtab_8c.html#aa8bea126883ca6d3df972eb50110933a">ast_hashtab_lookup_internal</a>(tab,obj,h);
<a name="l00545"></a>00545 
<a name="l00546"></a>00546    <span class="keywordflow">if</span> (tab-&gt;<a class="code" href="structast__hashtab.html#ac53417dd5a9c9583bdacc986bb861c60">do_locking</a>)
<a name="l00547"></a>00547       <a class="code" href="lock_8h.html#a21ce13cd6c771d5855f47ae7a1dd50b6">ast_rwlock_unlock</a>(&amp;tab-&gt;<a class="code" href="structast__hashtab.html#ace4e0066a5b24f84b90536e9906619f6">lock</a>);
<a name="l00548"></a>00548 
<a name="l00549"></a>00549    <span class="keywordflow">return</span> ret;
<a name="l00550"></a>00550 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="af629a9b97b7c185c9f0d691088e24fe9"></a><!-- doxytag: member="hashtab.c::ast_hashtab_lookup_bucket" ref="af629a9b97b7c185c9f0d691088e24fe9" args="(struct ast_hashtab *tab, const void *obj, unsigned int *bucket)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* ast_hashtab_lookup_bucket </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structast__hashtab.html">ast_hashtab</a> *&nbsp;</td>
          <td class="paramname"> <em>tab</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&nbsp;</td>
          <td class="paramname"> <em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int *&nbsp;</td>
          <td class="paramname"> <em>h</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Similar to ast_hashtab_lookup but sets h to the key hash value if the lookup fails. </p>
<dl class="note"><dt><b>Note:</b></dt><dd>This has the modulus applied, and will not be useful for long term storage if the table is resizable. </dd></dl>

<p>Definition at line <a class="el" href="hashtab_8c_source.html#l00575">575</a> of file <a class="el" href="hashtab_8c_source.html">hashtab.c</a>.</p>

<p>References <a class="el" href="hashtab_8c_source.html#l00593">ast_hashtab_lookup_internal()</a>, <a class="el" href="structast__hashtab.html#a391f7b59a3476dc3bf1ffa1b28852670">ast_hashtab::hash</a>, and <a class="el" href="hashtab_8h_source.html#l00091">ast_hashtab::hash_tab_size</a>.</p>

<p>Referenced by <a class="el" href="hashtab_8c_source.html#l00499">ast_hashtab_insert_safe()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00576"></a>00576 {
<a name="l00577"></a>00577    <span class="comment">/* lookup this object in the hash table. return a ptr if found, or NULL if not */</span>
<a name="l00578"></a>00578    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> h;
<a name="l00579"></a>00579    <span class="keywordtype">void</span> *ret;
<a name="l00580"></a>00580 
<a name="l00581"></a>00581    <span class="keywordflow">if</span> (!tab || !obj)
<a name="l00582"></a>00582       <span class="keywordflow">return</span> 0;
<a name="l00583"></a>00583 
<a name="l00584"></a>00584    h = (*tab-&gt;<a class="code" href="structast__hashtab.html#a391f7b59a3476dc3bf1ffa1b28852670">hash</a>)(obj) % tab-&gt;<a class="code" href="structast__hashtab.html#a65e874326c71bc3cc8009f6899ca4eb6">hash_tab_size</a>;
<a name="l00585"></a>00585 
<a name="l00586"></a>00586    ret = <a class="code" href="hashtab_8c.html#aa8bea126883ca6d3df972eb50110933a">ast_hashtab_lookup_internal</a>(tab,obj,h);
<a name="l00587"></a>00587 
<a name="l00588"></a>00588    *<a class="code" href="structbucket.html">bucket</a> = h;
<a name="l00589"></a>00589 
<a name="l00590"></a>00590    <span class="keywordflow">return</span> ret;
<a name="l00591"></a>00591 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="aa8bea126883ca6d3df972eb50110933a"></a><!-- doxytag: member="hashtab.c::ast_hashtab_lookup_internal" ref="aa8bea126883ca6d3df972eb50110933a" args="(struct ast_hashtab *tab, const void *obj, unsigned int h)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void * ast_hashtab_lookup_internal </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structast__hashtab.html">ast_hashtab</a> *&nbsp;</td>
          <td class="paramname"> <em>tab</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&nbsp;</td>
          <td class="paramname"> <em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>h</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="hashtab_8c_source.html#l00593">593</a> of file <a class="el" href="hashtab_8c_source.html">hashtab.c</a>.</p>

<p>References <a class="el" href="hashtab_8h_source.html#l00082">ast_hashtab::array</a>, <a class="el" href="structast__hashtab.html#a0f84e89988b57ec4039f039eb818be65">ast_hashtab::compare</a>, <a class="el" href="hashtab_8h_source.html#l00074">ast_hashtab_bucket::next</a>, and <a class="el" href="hashtab_8h_source.html#l00073">ast_hashtab_bucket::object</a>.</p>

<p>Referenced by <a class="el" href="hashtab_8c_source.html#l00530">ast_hashtab_lookup()</a>, <a class="el" href="hashtab_8c_source.html#l00575">ast_hashtab_lookup_bucket()</a>, and <a class="el" href="hashtab_8c_source.html#l00553">ast_hashtab_lookup_with_hash()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00594"></a>00594 {
<a name="l00595"></a>00595    <span class="keyword">struct </span><a class="code" href="structast__hashtab__bucket.html">ast_hashtab_bucket</a> *b;
<a name="l00596"></a>00596 
<a name="l00597"></a>00597    <span class="keywordflow">for</span> (b = tab-&gt;<a class="code" href="structast__hashtab.html#ad4a34c85bbad8598fd1e6cf37608d370">array</a>[h]; b; b = b-&gt;<a class="code" href="structast__hashtab__bucket.html#a277291f5bb0f819abb0f739591ccd961">next</a>) {
<a name="l00598"></a>00598       <span class="keywordflow">if</span> (!(*tab-&gt;<a class="code" href="structast__hashtab.html#a0f84e89988b57ec4039f039eb818be65">compare</a>)(obj,b-&gt;<a class="code" href="structast__hashtab__bucket.html#ac4fffd2513f3061cbd51acf5381177c8">object</a>)) {
<a name="l00599"></a>00599          <span class="comment">/* I can&apos;t touch obj in this func, but the outside world is welcome to */</span>
<a name="l00600"></a>00600          <span class="keywordflow">return</span> (<span class="keywordtype">void</span>*) b-&gt;<a class="code" href="structast__hashtab__bucket.html#ac4fffd2513f3061cbd51acf5381177c8">object</a>;
<a name="l00601"></a>00601       }
<a name="l00602"></a>00602    }
<a name="l00603"></a>00603 
<a name="l00604"></a>00604    <span class="keywordflow">return</span> NULL;
<a name="l00605"></a>00605 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="ad55e8dcfd056731bcdf275dee3dbad20"></a><!-- doxytag: member="hashtab.c::ast_hashtab_lookup_with_hash" ref="ad55e8dcfd056731bcdf275dee3dbad20" args="(struct ast_hashtab *tab, const void *obj, unsigned int hashval)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* ast_hashtab_lookup_with_hash </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structast__hashtab.html">ast_hashtab</a> *&nbsp;</td>
          <td class="paramname"> <em>tab</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&nbsp;</td>
          <td class="paramname"> <em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>hashval</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Use this if have the hash <a class="el" href="structval.html">val</a> for the object. </p>
<dl class="note"><dt><b>Note:</b></dt><dd>This and avoid the recalc of the hash (the modulus (table_size) is not applied) </dd></dl>

<p>Definition at line <a class="el" href="hashtab_8c_source.html#l00553">553</a> of file <a class="el" href="hashtab_8c_source.html">hashtab.c</a>.</p>

<p>References <a class="el" href="hashtab_8c_source.html#l00593">ast_hashtab_lookup_internal()</a>, <a class="el" href="lock_8h_source.html#l01796">ast_rwlock_rdlock()</a>, <a class="el" href="lock_8h_source.html#l01791">ast_rwlock_unlock()</a>, <a class="el" href="hashtab_8h_source.html#l00096">ast_hashtab::do_locking</a>, <a class="el" href="hashtab_8h_source.html#l00091">ast_hashtab::hash_tab_size</a>, and <a class="el" href="hashtab_8h_source.html#l00098">ast_hashtab::lock</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00554"></a>00554 {
<a name="l00555"></a>00555    <span class="comment">/* lookup this object in the hash table. return a ptr if found, or NULL if not */</span>
<a name="l00556"></a>00556    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> h;
<a name="l00557"></a>00557    <span class="keywordtype">void</span> *ret;
<a name="l00558"></a>00558 
<a name="l00559"></a>00559    <span class="keywordflow">if</span> (!tab || !obj)
<a name="l00560"></a>00560       <span class="keywordflow">return</span> 0;
<a name="l00561"></a>00561 
<a name="l00562"></a>00562    <span class="keywordflow">if</span> (tab-&gt;<a class="code" href="structast__hashtab.html#ac53417dd5a9c9583bdacc986bb861c60">do_locking</a>)
<a name="l00563"></a>00563       <a class="code" href="lock_8h.html#ae6703edce409c34119e27bdca1186d10">ast_rwlock_rdlock</a>(&amp;tab-&gt;<a class="code" href="structast__hashtab.html#ace4e0066a5b24f84b90536e9906619f6">lock</a>);
<a name="l00564"></a>00564 
<a name="l00565"></a>00565    h = hashval % tab-&gt;<a class="code" href="structast__hashtab.html#a65e874326c71bc3cc8009f6899ca4eb6">hash_tab_size</a>;
<a name="l00566"></a>00566 
<a name="l00567"></a>00567    ret = <a class="code" href="hashtab_8c.html#aa8bea126883ca6d3df972eb50110933a">ast_hashtab_lookup_internal</a>(tab,obj,h);
<a name="l00568"></a>00568 
<a name="l00569"></a>00569    <span class="keywordflow">if</span> (tab-&gt;<a class="code" href="structast__hashtab.html#ac53417dd5a9c9583bdacc986bb861c60">do_locking</a>)
<a name="l00570"></a>00570       <a class="code" href="lock_8h.html#a21ce13cd6c771d5855f47ae7a1dd50b6">ast_rwlock_unlock</a>(&amp;tab-&gt;<a class="code" href="structast__hashtab.html#ace4e0066a5b24f84b90536e9906619f6">lock</a>);
<a name="l00571"></a>00571 
<a name="l00572"></a>00572    <span class="keywordflow">return</span> ret;
<a name="l00573"></a>00573 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a743bfd52a8c9eb5d939ff5944758d846"></a><!-- doxytag: member="hashtab.c::ast_hashtab_newsize_java" ref="a743bfd52a8c9eb5d939ff5944758d846" args="(struct ast_hashtab *tab)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ast_hashtab_newsize_java </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structast__hashtab.html">ast_hashtab</a> *&nbsp;</td>
          <td class="paramname"> <em>tab</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create a prime <a class="el" href="structnumber.html" title="Number structure.">number</a> roughly 2x the current table size. </p>

<p>Definition at line <a class="el" href="hashtab_8c_source.html#l00127">127</a> of file <a class="el" href="hashtab_8c_source.html">hashtab.c</a>.</p>

<p>References <a class="el" href="hashtab_8c_source.html#l00101">ast_is_prime()</a>, and <a class="el" href="hashtab_8h_source.html#l00091">ast_hashtab::hash_tab_size</a>.</p>

<p>Referenced by <a class="el" href="pbx_8c_source.html#l07637">ast_add_extension2_lockopt()</a>, <a class="el" href="pbx_8c_source.html#l06424">ast_context_find_or_create()</a>, <a class="el" href="hashtab_8c_source.html#l00222">ast_hashtab_create()</a>, <a class="el" href="pbx__lua_8c_source.html#l00845">lua_register_switches()</a>, <a class="el" href="pbx__ael_8c_source.html#l00113">pbx_load_module()</a>, and <a class="el" href="sched_8c_source.html#l00239">sched_context_create()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00128"></a>00128 {
<a name="l00129"></a>00129    <span class="keywordtype">int</span> i = (tab-&gt;<a class="code" href="structast__hashtab.html#a65e874326c71bc3cc8009f6899ca4eb6">hash_tab_size</a> &lt;&lt; 1); <span class="comment">/* multiply by two */</span>
<a name="l00130"></a>00130 
<a name="l00131"></a>00131    <span class="keywordflow">while</span> (!<a class="code" href="hashtab_8h.html#a76a1018cc569eb65a6b29fab0a8481c1" title="Determines if the specified number is prime.">ast_is_prime</a>(i))
<a name="l00132"></a>00132       i++;
<a name="l00133"></a>00133 
<a name="l00134"></a>00134    <span class="keywordflow">return</span> i;
<a name="l00135"></a>00135 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a9c96afbac0ae8e85362cf5d64f05d350"></a><!-- doxytag: member="hashtab.c::ast_hashtab_newsize_none" ref="a9c96afbac0ae8e85362cf5d64f05d350" args="(struct ast_hashtab *tab)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ast_hashtab_newsize_none </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structast__hashtab.html">ast_hashtab</a> *&nbsp;</td>
          <td class="paramname"> <em>tab</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>always return current size -- no resizing </p>

<p>Definition at line <a class="el" href="hashtab_8c_source.html#l00148">148</a> of file <a class="el" href="hashtab_8c_source.html">hashtab.c</a>.</p>

<p>References <a class="el" href="hashtab_8h_source.html#l00091">ast_hashtab::hash_tab_size</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00149"></a>00149 {
<a name="l00150"></a>00150    <span class="keywordflow">return</span> tab-&gt;<a class="code" href="structast__hashtab.html#a65e874326c71bc3cc8009f6899ca4eb6">hash_tab_size</a>;
<a name="l00151"></a>00151 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="ac7c44d4b109e42af1ad35c72979af131"></a><!-- doxytag: member="hashtab.c::ast_hashtab_newsize_tight" ref="ac7c44d4b109e42af1ad35c72979af131" args="(struct ast_hashtab *tab)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ast_hashtab_newsize_tight </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structast__hashtab.html">ast_hashtab</a> *&nbsp;</td>
          <td class="paramname"> <em>tab</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="hashtab_8c_source.html#l00137">137</a> of file <a class="el" href="hashtab_8c_source.html">hashtab.c</a>.</p>

<p>References <a class="el" href="hashtab_8c_source.html#l00101">ast_is_prime()</a>, and <a class="el" href="hashtab_8h_source.html#l00091">ast_hashtab::hash_tab_size</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00138"></a>00138 {
<a name="l00139"></a>00139    <span class="keywordtype">int</span> x = (tab-&gt;<a class="code" href="structast__hashtab.html#a65e874326c71bc3cc8009f6899ca4eb6">hash_tab_size</a> &lt;&lt; 1);
<a name="l00140"></a>00140    <span class="keywordtype">int</span> i = (tab-&gt;<a class="code" href="structast__hashtab.html#a65e874326c71bc3cc8009f6899ca4eb6">hash_tab_size</a> + x);
<a name="l00141"></a>00141 
<a name="l00142"></a>00142    <span class="keywordflow">while</span> (!<a class="code" href="hashtab_8h.html#a76a1018cc569eb65a6b29fab0a8481c1" title="Determines if the specified number is prime.">ast_is_prime</a>(i))
<a name="l00143"></a>00143       i++;
<a name="l00144"></a>00144 
<a name="l00145"></a>00145    <span class="keywordflow">return</span> i;
<a name="l00146"></a>00146 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a43983b6169e9a0f9af48cca5cf9d3197"></a><!-- doxytag: member="hashtab.c::ast_hashtab_next" ref="a43983b6169e9a0f9af48cca5cf9d3197" args="(struct ast_hashtab_iter *it)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* ast_hashtab_next </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structast__hashtab__iter.html">ast_hashtab_iter</a> *&nbsp;</td>
          <td class="paramname"> <em>it</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets the next object in the list, advances iter one step returns null on end of traversal. </p>

<p>Definition at line <a class="el" href="hashtab_8c_source.html#l00749">749</a> of file <a class="el" href="hashtab_8c_source.html">hashtab.c</a>.</p>

<p>References <a class="el" href="hashtab_8h_source.html#l00105">ast_hashtab_iter::next</a>, <a class="el" href="hashtab_8h_source.html#l00073">ast_hashtab_bucket::object</a>, and <a class="el" href="hashtab_8h_source.html#l00076">ast_hashtab_bucket::tnext</a>.</p>

<p>Referenced by <a class="el" href="pbx_8c_source.html#l08276">__ast_context_destroy()</a>, <a class="el" href="pbx_8c_source.html#l06623">ast_merge_contexts_and_delete()</a>, <a class="el" href="pbx_8c_source.html#l06539">context_merge()</a>, and <a class="el" href="pbx_8c_source.html#l02000">create_match_char_tree()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00750"></a>00750 {
<a name="l00751"></a>00751    <span class="comment">/* returns the next object in the list, advances iter one step */</span>
<a name="l00752"></a>00752    <span class="keyword">struct </span><a class="code" href="structast__hashtab__bucket.html">ast_hashtab_bucket</a> *retval;
<a name="l00753"></a>00753 
<a name="l00754"></a>00754    <span class="keywordflow">if</span> (it &amp;&amp; it-&gt;<a class="code" href="structast__hashtab__iter.html#a277291f5bb0f819abb0f739591ccd961">next</a>) { <span class="comment">/* there&apos;s a next in the bucket list */</span>
<a name="l00755"></a>00755       retval = it-&gt;<a class="code" href="structast__hashtab__iter.html#a277291f5bb0f819abb0f739591ccd961">next</a>;
<a name="l00756"></a>00756       it-&gt;<a class="code" href="structast__hashtab__iter.html#a277291f5bb0f819abb0f739591ccd961">next</a> = retval-&gt;<a class="code" href="structast__hashtab__bucket.html#ad3f87b9bd48bdc73946d7f5c48d3f00a">tnext</a>;
<a name="l00757"></a>00757       <span class="keywordflow">return</span> (<span class="keywordtype">void</span> *) retval-&gt;<a class="code" href="structast__hashtab__bucket.html#ac4fffd2513f3061cbd51acf5381177c8">object</a>;
<a name="l00758"></a>00758    }
<a name="l00759"></a>00759 
<a name="l00760"></a>00760    <span class="keywordflow">return</span> NULL;
<a name="l00761"></a>00761 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a56846aff6af7e13e3cffc9d21594fb40"></a><!-- doxytag: member="hashtab.c::ast_hashtab_rdlock" ref="a56846aff6af7e13e3cffc9d21594fb40" args="(struct ast_hashtab *tab)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ast_hashtab_rdlock </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structast__hashtab.html">ast_hashtab</a> *&nbsp;</td>
          <td class="paramname"> <em>tab</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Request a read-lock on the table -- don't change anything! </p>

<p>Definition at line <a class="el" href="hashtab_8c_source.html#l00364">364</a> of file <a class="el" href="hashtab_8c_source.html">hashtab.c</a>.</p>

<p>References <a class="el" href="lock_8h_source.html#l01796">ast_rwlock_rdlock()</a>, and <a class="el" href="hashtab_8h_source.html#l00098">ast_hashtab::lock</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00365"></a>00365 {
<a name="l00366"></a>00366    <a class="code" href="lock_8h.html#ae6703edce409c34119e27bdca1186d10">ast_rwlock_rdlock</a>(&amp;tab-&gt;<a class="code" href="structast__hashtab.html#ace4e0066a5b24f84b90536e9906619f6">lock</a>);
<a name="l00367"></a>00367 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a86729040ecad330864abfa0e2b2c0af1"></a><!-- doxytag: member="hashtab.c::ast_hashtab_remove_object_internal" ref="a86729040ecad330864abfa0e2b2c0af1" args="(struct ast_hashtab *tab, struct ast_hashtab_bucket *b, int h)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void* ast_hashtab_remove_object_internal </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structast__hashtab.html">ast_hashtab</a> *&nbsp;</td>
          <td class="paramname"> <em>tab</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structast__hashtab__bucket.html">ast_hashtab_bucket</a> *&nbsp;</td>
          <td class="paramname"> <em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>h</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="hashtab_8c_source.html#l00763">763</a> of file <a class="el" href="hashtab_8c_source.html">hashtab.c</a>.</p>

<p>References <a class="el" href="hashtab_8h_source.html#l00082">ast_hashtab::array</a>, <a class="el" href="astmm_8h_source.html#l00084">free</a>, <a class="el" href="hashtab_8h_source.html#l00092">ast_hashtab::hash_tab_elements</a>, <a class="el" href="hashtab_8h_source.html#l00074">ast_hashtab_bucket::next</a>, <a class="el" href="hashtab_8h_source.html#l00073">ast_hashtab_bucket::object</a>, <a class="el" href="hashtab_8h_source.html#l00075">ast_hashtab_bucket::prev</a>, <a class="el" href="hashtab_8h_source.html#l00083">ast_hashtab::tlist</a>, <a class="el" href="hashtab_8c_source.html#l00326">tlist_del_item()</a>, <a class="el" href="hashtab_8h_source.html#l00076">ast_hashtab_bucket::tnext</a>, and <a class="el" href="hashtab_8h_source.html#l00077">ast_hashtab_bucket::tprev</a>.</p>

<p>Referenced by <a class="el" href="hashtab_8c_source.html#l00831">ast_hashtab_remove_object_via_lookup_nolock()</a>, and <a class="el" href="hashtab_8c_source.html#l00876">ast_hashtab_remove_this_object_nolock()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00764"></a>00764 {
<a name="l00765"></a>00765    <span class="keyword">const</span> <span class="keywordtype">void</span> *obj2;
<a name="l00766"></a>00766 
<a name="l00767"></a>00767    <span class="keywordflow">if</span> (b-&gt;<a class="code" href="structast__hashtab__bucket.html#af0ab45e37ae5f4c9a984ecea99ec9be4">prev</a>)
<a name="l00768"></a>00768       b-&gt;<a class="code" href="structast__hashtab__bucket.html#af0ab45e37ae5f4c9a984ecea99ec9be4">prev</a>-&gt;<a class="code" href="structast__hashtab__bucket.html#a277291f5bb0f819abb0f739591ccd961">next</a> = b-&gt;<a class="code" href="structast__hashtab__bucket.html#a277291f5bb0f819abb0f739591ccd961">next</a>;
<a name="l00769"></a>00769    <span class="keywordflow">else</span>
<a name="l00770"></a>00770       tab-&gt;<a class="code" href="structast__hashtab.html#ad4a34c85bbad8598fd1e6cf37608d370">array</a>[h] = b-&gt;<a class="code" href="structast__hashtab__bucket.html#a277291f5bb0f819abb0f739591ccd961">next</a>;
<a name="l00771"></a>00771 
<a name="l00772"></a>00772    <span class="keywordflow">if</span> (b-&gt;<a class="code" href="structast__hashtab__bucket.html#a277291f5bb0f819abb0f739591ccd961">next</a>)
<a name="l00773"></a>00773       b-&gt;<a class="code" href="structast__hashtab__bucket.html#a277291f5bb0f819abb0f739591ccd961">next</a>-&gt;<a class="code" href="structast__hashtab__bucket.html#af0ab45e37ae5f4c9a984ecea99ec9be4">prev</a> = b-&gt;<a class="code" href="structast__hashtab__bucket.html#af0ab45e37ae5f4c9a984ecea99ec9be4">prev</a>;
<a name="l00774"></a>00774 
<a name="l00775"></a>00775    <a class="code" href="hashtab_8c.html#acea5c0d1395a2a9a8e5287a37b0b8c7c">tlist_del_item</a>(&amp;(tab-&gt;<a class="code" href="structast__hashtab.html#abc3c4c519a852f85284868cb68c8a44e">tlist</a>), b);
<a name="l00776"></a>00776 
<a name="l00777"></a>00777    obj2 = b-&gt;<a class="code" href="structast__hashtab__bucket.html#ac4fffd2513f3061cbd51acf5381177c8">object</a>;
<a name="l00778"></a>00778    b-&gt;<a class="code" href="structast__hashtab__bucket.html#ac4fffd2513f3061cbd51acf5381177c8">object</a> = b-&gt;<a class="code" href="structast__hashtab__bucket.html#a277291f5bb0f819abb0f739591ccd961">next</a> = (<span class="keywordtype">void</span>*)2;
<a name="l00779"></a>00779    <a class="code" href="astmm_8h.html#aa7157aa9480bb73f090dca36776419bf">free</a>(b); <span class="comment">/* free up the hashbucket */</span>
<a name="l00780"></a>00780    tab-&gt;<a class="code" href="structast__hashtab.html#a46bc973b99fd63faabcf465499d58167">hash_tab_elements</a>--;
<a name="l00781"></a>00781 <span class="preprocessor">#ifdef DEBUG</span>
<a name="l00782"></a>00782 <span class="preprocessor"></span>   {
<a name="l00783"></a>00783       <span class="keywordtype">int</span> c2;
<a name="l00784"></a>00784       <span class="keyword">struct </span><a class="code" href="structast__hashtab__bucket.html">ast_hashtab_bucket</a> *b2;
<a name="l00785"></a>00785       <span class="comment">/* do a little checking */</span>
<a name="l00786"></a>00786       <span class="keywordflow">for</span> (c2 = 0, b2 = tab-&gt;<a class="code" href="structast__hashtab.html#abc3c4c519a852f85284868cb68c8a44e">tlist</a>; b2; b2 = b2-&gt;<a class="code" href="structast__hashtab__bucket.html#ad3f87b9bd48bdc73946d7f5c48d3f00a">tnext</a>) {
<a name="l00787"></a>00787          c2++;
<a name="l00788"></a>00788       }
<a name="l00789"></a>00789       <span class="keywordflow">if</span> (c2 != tab-&gt;<a class="code" href="structast__hashtab.html#a46bc973b99fd63faabcf465499d58167">hash_tab_elements</a>) {
<a name="l00790"></a>00790          printf(<span class="stringliteral">&quot;Hey! we didn&apos;t delete right! there are %d elements in the list, and we expected %d\n&quot;</span>,
<a name="l00791"></a>00791                c2, tab-&gt;<a class="code" href="structast__hashtab.html#a46bc973b99fd63faabcf465499d58167">hash_tab_elements</a>);
<a name="l00792"></a>00792       }
<a name="l00793"></a>00793       <span class="keywordflow">for</span> (c2 = 0, b2 = tab-&gt;<a class="code" href="structast__hashtab.html#abc3c4c519a852f85284868cb68c8a44e">tlist</a>; b2; b2 = b2-&gt;<a class="code" href="structast__hashtab__bucket.html#ad3f87b9bd48bdc73946d7f5c48d3f00a">tnext</a>) {
<a name="l00794"></a>00794          <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> obj3 = (<span class="keywordtype">unsigned</span> long) obj2;
<a name="l00795"></a>00795          <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> b3 = (<span class="keywordtype">unsigned</span> long) b;
<a name="l00796"></a>00796          <span class="keywordflow">if</span> (b2-&gt;<a class="code" href="structast__hashtab__bucket.html#ac4fffd2513f3061cbd51acf5381177c8">object</a> == obj2)
<a name="l00797"></a>00797             printf(<span class="stringliteral">&quot;Hey-- you&apos;ve still got a bucket pointing at ht_element %x\n&quot;</span>, obj3);
<a name="l00798"></a>00798          <span class="keywordflow">if</span> (b2-&gt;<a class="code" href="structast__hashtab__bucket.html#a277291f5bb0f819abb0f739591ccd961">next</a> == b)
<a name="l00799"></a>00799             printf(<span class="stringliteral">&quot;Hey-- you&apos;ve still got a bucket with next ptr pointing to deleted bucket %x\n&quot;</span>, b3);
<a name="l00800"></a>00800          <span class="keywordflow">if</span> (b2-&gt;<a class="code" href="structast__hashtab__bucket.html#af0ab45e37ae5f4c9a984ecea99ec9be4">prev</a> == b)
<a name="l00801"></a>00801             printf(<span class="stringliteral">&quot;Hey-- you&apos;ve still got a bucket with prev ptr pointing to deleted bucket %x\n&quot;</span>, b3);
<a name="l00802"></a>00802          <span class="keywordflow">if</span> (b2-&gt;<a class="code" href="structast__hashtab__bucket.html#a6c8449130d6e42faf1a1879c8f78304a">tprev</a> == b)
<a name="l00803"></a>00803             printf(<span class="stringliteral">&quot;Hey-- you&apos;ve still got a bucket with tprev ptr pointing to deleted bucket %x\n&quot;</span>, b3);
<a name="l00804"></a>00804          <span class="keywordflow">if</span> (b2-&gt;<a class="code" href="structast__hashtab__bucket.html#ad3f87b9bd48bdc73946d7f5c48d3f00a">tnext</a> == b)
<a name="l00805"></a>00805             printf(<span class="stringliteral">&quot;Hey-- you&apos;ve still got a bucket with tnext ptr pointing to deleted bucket %x\n&quot;</span>, b3);
<a name="l00806"></a>00806       }
<a name="l00807"></a>00807    }
<a name="l00808"></a>00808 <span class="preprocessor">#endif</span>
<a name="l00809"></a>00809 <span class="preprocessor"></span>   <span class="keywordflow">return</span> (<span class="keywordtype">void</span> *) obj2; <span class="comment">/* inside this code, the obj&apos;s are untouchable, but outside, they aren&apos;t */</span>
<a name="l00810"></a>00810 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a313b62d20344c2c85461dd4ed893017c"></a><!-- doxytag: member="hashtab.c::ast_hashtab_remove_object_via_lookup" ref="a313b62d20344c2c85461dd4ed893017c" args="(struct ast_hashtab *tab, void *obj)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* ast_hashtab_remove_object_via_lookup </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structast__hashtab.html">ast_hashtab</a> *&nbsp;</td>
          <td class="paramname"> <em>tab</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>obj</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Looks up the object, removes the corresponding <a class="el" href="structbucket.html">bucket</a>. </p>

<p>Definition at line <a class="el" href="hashtab_8c_source.html#l00812">812</a> of file <a class="el" href="hashtab_8c_source.html">hashtab.c</a>.</p>

<p>References <a class="el" href="hashtab_8c_source.html#l00831">ast_hashtab_remove_object_via_lookup_nolock()</a>, <a class="el" href="lock_8h_source.html#l01791">ast_rwlock_unlock()</a>, <a class="el" href="lock_8h_source.html#l01827">ast_rwlock_wrlock()</a>, <a class="el" href="hashtab_8h_source.html#l00096">ast_hashtab::do_locking</a>, and <a class="el" href="hashtab_8h_source.html#l00098">ast_hashtab::lock</a>.</p>

<p>Referenced by <a class="el" href="pbx_8c_source.html#l07451">add_pri_lockopt()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00813"></a>00813 {
<a name="l00814"></a>00814    <span class="comment">/* looks up the object; removes the corresponding bucket */</span>
<a name="l00815"></a>00815    <span class="keyword">const</span> <span class="keywordtype">void</span> *obj2;
<a name="l00816"></a>00816 
<a name="l00817"></a>00817    <span class="keywordflow">if</span> (!tab || !obj)
<a name="l00818"></a>00818       <span class="keywordflow">return</span> 0;
<a name="l00819"></a>00819 
<a name="l00820"></a>00820    <span class="keywordflow">if</span> (tab-&gt;<a class="code" href="structast__hashtab.html#ac53417dd5a9c9583bdacc986bb861c60">do_locking</a>)
<a name="l00821"></a>00821       <a class="code" href="lock_8h.html#a952527792bba2a323118ae911f9aa1f7">ast_rwlock_wrlock</a>(&amp;tab-&gt;<a class="code" href="structast__hashtab.html#ace4e0066a5b24f84b90536e9906619f6">lock</a>);
<a name="l00822"></a>00822 
<a name="l00823"></a>00823    obj2 = <a class="code" href="hashtab_8h.html#ad7ee24c838111389b9781324364f8c00" title="Looks up the object, removes the corresponding bucket.">ast_hashtab_remove_object_via_lookup_nolock</a>(tab,obj);
<a name="l00824"></a>00824 
<a name="l00825"></a>00825    <span class="keywordflow">if</span> (tab-&gt;<a class="code" href="structast__hashtab.html#ac53417dd5a9c9583bdacc986bb861c60">do_locking</a>)
<a name="l00826"></a>00826       <a class="code" href="lock_8h.html#a21ce13cd6c771d5855f47ae7a1dd50b6">ast_rwlock_unlock</a>(&amp;tab-&gt;<a class="code" href="structast__hashtab.html#ace4e0066a5b24f84b90536e9906619f6">lock</a>);
<a name="l00827"></a>00827 
<a name="l00828"></a>00828    <span class="keywordflow">return</span> (<span class="keywordtype">void</span> *)obj2;
<a name="l00829"></a>00829 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="ad7ee24c838111389b9781324364f8c00"></a><!-- doxytag: member="hashtab.c::ast_hashtab_remove_object_via_lookup_nolock" ref="ad7ee24c838111389b9781324364f8c00" args="(struct ast_hashtab *tab, void *obj)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* ast_hashtab_remove_object_via_lookup_nolock </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structast__hashtab.html">ast_hashtab</a> *&nbsp;</td>
          <td class="paramname"> <em>tab</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>obj</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Looks up the object, removes the corresponding <a class="el" href="structbucket.html">bucket</a>. </p>

<p>Definition at line <a class="el" href="hashtab_8c_source.html#l00831">831</a> of file <a class="el" href="hashtab_8c_source.html">hashtab.c</a>.</p>

<p>References <a class="el" href="hashtab_8h_source.html#l00082">ast_hashtab::array</a>, <a class="el" href="hashtab_8c_source.html#l00763">ast_hashtab_remove_object_internal()</a>, <a class="el" href="structast__hashtab.html#a0f84e89988b57ec4039f039eb818be65">ast_hashtab::compare</a>, <a class="el" href="structast__hashtab.html#a391f7b59a3476dc3bf1ffa1b28852670">ast_hashtab::hash</a>, <a class="el" href="hashtab_8h_source.html#l00091">ast_hashtab::hash_tab_size</a>, <a class="el" href="hashtab_8h_source.html#l00074">ast_hashtab_bucket::next</a>, and <a class="el" href="hashtab_8h_source.html#l00073">ast_hashtab_bucket::object</a>.</p>

<p>Referenced by <a class="el" href="hashtab_8c_source.html#l00812">ast_hashtab_remove_object_via_lookup()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00832"></a>00832 {
<a name="l00833"></a>00833    <span class="comment">/* looks up the object; removes the corresponding bucket */</span>
<a name="l00834"></a>00834    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> h;
<a name="l00835"></a>00835    <span class="keyword">struct </span><a class="code" href="structast__hashtab__bucket.html">ast_hashtab_bucket</a> *b;
<a name="l00836"></a>00836 
<a name="l00837"></a>00837    <span class="keywordflow">if</span> (!tab || !obj)
<a name="l00838"></a>00838       <span class="keywordflow">return</span> 0;
<a name="l00839"></a>00839 
<a name="l00840"></a>00840    h = (*tab-&gt;<a class="code" href="structast__hashtab.html#a391f7b59a3476dc3bf1ffa1b28852670">hash</a>)(obj) % tab-&gt;<a class="code" href="structast__hashtab.html#a65e874326c71bc3cc8009f6899ca4eb6">hash_tab_size</a>;
<a name="l00841"></a>00841    <span class="keywordflow">for</span> (b = tab-&gt;<a class="code" href="structast__hashtab.html#ad4a34c85bbad8598fd1e6cf37608d370">array</a>[h]; b; b = b-&gt;<a class="code" href="structast__hashtab__bucket.html#a277291f5bb0f819abb0f739591ccd961">next</a>) {
<a name="l00842"></a>00842 
<a name="l00843"></a>00843       <span class="keywordflow">if</span> (!(*tab-&gt;<a class="code" href="structast__hashtab.html#a0f84e89988b57ec4039f039eb818be65">compare</a>)(obj, b-&gt;<a class="code" href="structast__hashtab__bucket.html#ac4fffd2513f3061cbd51acf5381177c8">object</a>)) {
<a name="l00844"></a>00844          <span class="keyword">const</span> <span class="keywordtype">void</span> *obj2;
<a name="l00845"></a>00845 
<a name="l00846"></a>00846          obj2 = <a class="code" href="hashtab_8c.html#a86729040ecad330864abfa0e2b2c0af1">ast_hashtab_remove_object_internal</a>(tab, b, h);
<a name="l00847"></a>00847 
<a name="l00848"></a>00848          <span class="keywordflow">return</span> (<span class="keywordtype">void</span> *) obj2; <span class="comment">/* inside this code, the obj&apos;s are untouchable, but outside, they aren&apos;t */</span>
<a name="l00849"></a>00849       }
<a name="l00850"></a>00850    }
<a name="l00851"></a>00851 
<a name="l00852"></a>00852    <span class="keywordflow">return</span> 0;
<a name="l00853"></a>00853 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a71bd19ff2f6fad1cf5e01f9b8cad6f66"></a><!-- doxytag: member="hashtab.c::ast_hashtab_remove_this_object" ref="a71bd19ff2f6fad1cf5e01f9b8cad6f66" args="(struct ast_hashtab *tab, void *obj)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* ast_hashtab_remove_this_object </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structast__hashtab.html">ast_hashtab</a> *&nbsp;</td>
          <td class="paramname"> <em>tab</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>obj</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Hash the object and then compare ptrs in <a class="el" href="structbucket.html">bucket</a> list instead of calling the compare routine, will remove the <a class="el" href="structbucket.html">bucket</a>. </p>

<p>Definition at line <a class="el" href="hashtab_8c_source.html#l00855">855</a> of file <a class="el" href="hashtab_8c_source.html">hashtab.c</a>.</p>

<p>References <a class="el" href="hashtab_8c_source.html#l00876">ast_hashtab_remove_this_object_nolock()</a>, <a class="el" href="lock_8h_source.html#l01791">ast_rwlock_unlock()</a>, <a class="el" href="lock_8h_source.html#l01827">ast_rwlock_wrlock()</a>, <a class="el" href="hashtab_8h_source.html#l00096">ast_hashtab::do_locking</a>, and <a class="el" href="hashtab_8h_source.html#l00098">ast_hashtab::lock</a>.</p>

<p>Referenced by <a class="el" href="pbx_8c_source.html#l08276">__ast_context_destroy()</a>, <a class="el" href="pbx_8c_source.html#l04828">ast_context_remove_extension_callerid2()</a>, <a class="el" href="sched_8c_source.html#l00461">ast_sched_del()</a>, and <a class="el" href="sched_8c_source.html#l00581">ast_sched_runq()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00856"></a>00856 {
<a name="l00857"></a>00857    <span class="comment">/* looks up the object by hash and then comparing pts in bucket list instead of</span>
<a name="l00858"></a>00858 <span class="comment">      calling the compare routine; removes the bucket -- a slightly cheaper operation */</span>
<a name="l00859"></a>00859    <span class="comment">/* looks up the object; removes the corresponding bucket */</span>
<a name="l00860"></a>00860    <span class="keyword">const</span> <span class="keywordtype">void</span> *obj2;
<a name="l00861"></a>00861 
<a name="l00862"></a>00862    <span class="keywordflow">if</span> (!tab || !obj)
<a name="l00863"></a>00863       <span class="keywordflow">return</span> 0;
<a name="l00864"></a>00864 
<a name="l00865"></a>00865    <span class="keywordflow">if</span> (tab-&gt;<a class="code" href="structast__hashtab.html#ac53417dd5a9c9583bdacc986bb861c60">do_locking</a>)
<a name="l00866"></a>00866       <a class="code" href="lock_8h.html#a952527792bba2a323118ae911f9aa1f7">ast_rwlock_wrlock</a>(&amp;tab-&gt;<a class="code" href="structast__hashtab.html#ace4e0066a5b24f84b90536e9906619f6">lock</a>);
<a name="l00867"></a>00867 
<a name="l00868"></a>00868    obj2 = <a class="code" href="hashtab_8h.html#ae9ca6365402722ebda78f20c9245b1fe" title="Hash the object and then compare ptrs in bucket list instead of calling the compare...">ast_hashtab_remove_this_object_nolock</a>(tab,obj);
<a name="l00869"></a>00869 
<a name="l00870"></a>00870    <span class="keywordflow">if</span> (tab-&gt;<a class="code" href="structast__hashtab.html#ac53417dd5a9c9583bdacc986bb861c60">do_locking</a>)
<a name="l00871"></a>00871       <a class="code" href="lock_8h.html#a21ce13cd6c771d5855f47ae7a1dd50b6">ast_rwlock_unlock</a>(&amp;tab-&gt;<a class="code" href="structast__hashtab.html#ace4e0066a5b24f84b90536e9906619f6">lock</a>);
<a name="l00872"></a>00872 
<a name="l00873"></a>00873    <span class="keywordflow">return</span> (<span class="keywordtype">void</span> *)obj2;
<a name="l00874"></a>00874 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="ae9ca6365402722ebda78f20c9245b1fe"></a><!-- doxytag: member="hashtab.c::ast_hashtab_remove_this_object_nolock" ref="ae9ca6365402722ebda78f20c9245b1fe" args="(struct ast_hashtab *tab, void *obj)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* ast_hashtab_remove_this_object_nolock </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structast__hashtab.html">ast_hashtab</a> *&nbsp;</td>
          <td class="paramname"> <em>tab</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>obj</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Hash the object and then compare ptrs in <a class="el" href="structbucket.html">bucket</a> list instead of calling the compare routine, will remove the <a class="el" href="structbucket.html">bucket</a>. </p>

<p>Definition at line <a class="el" href="hashtab_8c_source.html#l00876">876</a> of file <a class="el" href="hashtab_8c_source.html">hashtab.c</a>.</p>

<p>References <a class="el" href="hashtab_8h_source.html#l00082">ast_hashtab::array</a>, <a class="el" href="hashtab_8c_source.html#l00763">ast_hashtab_remove_object_internal()</a>, <a class="el" href="structast__hashtab.html#a391f7b59a3476dc3bf1ffa1b28852670">ast_hashtab::hash</a>, <a class="el" href="hashtab_8h_source.html#l00091">ast_hashtab::hash_tab_size</a>, <a class="el" href="hashtab_8h_source.html#l00074">ast_hashtab_bucket::next</a>, and <a class="el" href="hashtab_8h_source.html#l00073">ast_hashtab_bucket::object</a>.</p>

<p>Referenced by <a class="el" href="hashtab_8c_source.html#l00855">ast_hashtab_remove_this_object()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00877"></a>00877 {
<a name="l00878"></a>00878    <span class="comment">/* looks up the object by hash and then comparing pts in bucket list instead of</span>
<a name="l00879"></a>00879 <span class="comment">      calling the compare routine; removes the bucket -- a slightly cheaper operation */</span>
<a name="l00880"></a>00880    <span class="comment">/* looks up the object; removes the corresponding bucket */</span>
<a name="l00881"></a>00881    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> h;
<a name="l00882"></a>00882    <span class="keyword">struct </span><a class="code" href="structast__hashtab__bucket.html">ast_hashtab_bucket</a> *b;
<a name="l00883"></a>00883 
<a name="l00884"></a>00884    <span class="keywordflow">if</span> (!tab || !obj)
<a name="l00885"></a>00885       <span class="keywordflow">return</span> 0;
<a name="l00886"></a>00886 
<a name="l00887"></a>00887    h = (*tab-&gt;<a class="code" href="structast__hashtab.html#a391f7b59a3476dc3bf1ffa1b28852670">hash</a>)(obj) % tab-&gt;<a class="code" href="structast__hashtab.html#a65e874326c71bc3cc8009f6899ca4eb6">hash_tab_size</a>;
<a name="l00888"></a>00888    <span class="keywordflow">for</span> (b = tab-&gt;<a class="code" href="structast__hashtab.html#ad4a34c85bbad8598fd1e6cf37608d370">array</a>[h]; b; b = b-&gt;<a class="code" href="structast__hashtab__bucket.html#a277291f5bb0f819abb0f739591ccd961">next</a>) {
<a name="l00889"></a>00889 
<a name="l00890"></a>00890       <span class="keywordflow">if</span> (obj == b-&gt;<a class="code" href="structast__hashtab__bucket.html#ac4fffd2513f3061cbd51acf5381177c8">object</a>) {
<a name="l00891"></a>00891          <span class="keyword">const</span> <span class="keywordtype">void</span> *obj2;
<a name="l00892"></a>00892          obj2 = <a class="code" href="hashtab_8c.html#a86729040ecad330864abfa0e2b2c0af1">ast_hashtab_remove_object_internal</a>(tab, b, h);
<a name="l00893"></a>00893 
<a name="l00894"></a>00894          <span class="keywordflow">return</span> (<span class="keywordtype">void</span> *) obj2; <span class="comment">/* inside this code, the obj&apos;s are untouchable, but outside, they aren&apos;t */</span>
<a name="l00895"></a>00895       }
<a name="l00896"></a>00896    }
<a name="l00897"></a>00897 
<a name="l00898"></a>00898    <span class="keywordflow">return</span> 0;
<a name="l00899"></a>00899 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a148f269e2a72507129357e2ef2fcd72e"></a><!-- doxytag: member="hashtab.c::ast_hashtab_resize" ref="a148f269e2a72507129357e2ef2fcd72e" args="(struct ast_hashtab *tab)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void ast_hashtab_resize </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structast__hashtab.html">ast_hashtab</a> *&nbsp;</td>
          <td class="paramname"> <em>tab</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="hashtab_8c_source.html#l00638">638</a> of file <a class="el" href="hashtab_8c_source.html">hashtab.c</a>.</p>

<p>References <a class="el" href="astmm_8c_source.html#l00199">__ast_calloc()</a>, <a class="el" href="hashtab_8h_source.html#l00082">ast_hashtab::array</a>, <a class="el" href="astmm_8h_source.html#l00072">ast_calloc</a>, <a class="el" href="astmm_8h_source.html#l00084">free</a>, <a class="el" href="structast__hashtab.html#a391f7b59a3476dc3bf1ffa1b28852670">ast_hashtab::hash</a>, <a class="el" href="hashtab_8h_source.html#l00091">ast_hashtab::hash_tab_size</a>, <a class="el" href="hashtab_8h_source.html#l00093">ast_hashtab::largest_bucket_size</a>, <a class="el" href="structast__hashtab.html#aa50f8d4f1283e0b777dd85f17423fae1">ast_hashtab::newsize</a>, <a class="el" href="hashtab_8h_source.html#l00074">ast_hashtab_bucket::next</a>, <a class="el" href="hashtab_8h_source.html#l00073">ast_hashtab_bucket::object</a>, <a class="el" href="hashtab_8h_source.html#l00075">ast_hashtab_bucket::prev</a>, <a class="el" href="hashtab_8h_source.html#l00094">ast_hashtab::resize_count</a>, <a class="el" href="hashtab_8h_source.html#l00083">ast_hashtab::tlist</a>, and <a class="el" href="hashtab_8h_source.html#l00076">ast_hashtab_bucket::tnext</a>.</p>

<p>Referenced by <a class="el" href="hashtab_8c_source.html#l00457">ast_hashtab_insert_immediate_bucket()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00640"></a>00640 {
<a name="l00641"></a>00641    <span class="comment">/* this function is called either internally, when the resize func returns 1, or</span>
<a name="l00642"></a>00642 <span class="comment">      externally by the user to force a resize of the hash table */</span>
<a name="l00643"></a>00643    <span class="keywordtype">int</span> newsize = (*tab-&gt;<a class="code" href="structast__hashtab.html#aa50f8d4f1283e0b777dd85f17423fae1">newsize</a>)(tab), i, c;
<a name="l00644"></a>00644    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> h;
<a name="l00645"></a>00645    <span class="keyword">struct </span><a class="code" href="structast__hashtab__bucket.html">ast_hashtab_bucket</a> *b,*bn;
<a name="l00646"></a>00646 
<a name="l00647"></a>00647    <span class="comment">/* Since we keep a DLL of all the buckets in tlist,</span>
<a name="l00648"></a>00648 <span class="comment">      all we have to do is free the array, malloc a new one,</span>
<a name="l00649"></a>00649 <span class="comment">      and then go thru the tlist array and reassign them into</span>
<a name="l00650"></a>00650 <span class="comment">      the bucket arrayj.</span>
<a name="l00651"></a>00651 <span class="comment">   */</span>
<a name="l00652"></a>00652    <span class="keywordflow">for</span> (i = 0; i &lt; tab-&gt;<a class="code" href="structast__hashtab.html#a65e874326c71bc3cc8009f6899ca4eb6">hash_tab_size</a>; i++) { <span class="comment">/* don&apos;t absolutely have to do this, but</span>
<a name="l00653"></a>00653 <span class="comment">                                 why leave ptrs laying around */</span>
<a name="l00654"></a>00654       tab-&gt;<a class="code" href="structast__hashtab.html#ad4a34c85bbad8598fd1e6cf37608d370">array</a>[i] = 0; <span class="comment">/* erase old ptrs */</span>
<a name="l00655"></a>00655    }
<a name="l00656"></a>00656    <a class="code" href="astmm_8h.html#aa7157aa9480bb73f090dca36776419bf">free</a>(tab-&gt;<a class="code" href="structast__hashtab.html#ad4a34c85bbad8598fd1e6cf37608d370">array</a>);
<a name="l00657"></a>00657    <span class="keywordflow">if</span> (!(tab-&gt;<a class="code" href="structast__hashtab.html#ad4a34c85bbad8598fd1e6cf37608d370">array</a> =
<a name="l00658"></a>00658 #if (defined(MALLOC_DEBUG) &amp;&amp; !defined(STANDALONE))
<a name="l00659"></a>00659       <a class="code" href="astmm_8h.html#ad800d5c993a0c605f6e061bdef1b524c">__ast_calloc</a>(newsize, <span class="keyword">sizeof</span>(*(tab-&gt;<a class="code" href="structast__hashtab.html#ad4a34c85bbad8598fd1e6cf37608d370">array</a>)), file, lineno, func)
<a name="l00660"></a>00660 #<span class="keywordflow">else</span>
<a name="l00661"></a>00661       <a class="code" href="astmm_8h.html#a1cb33b63d94fbbde94234b062249e015">ast_calloc</a>(newsize, <span class="keyword">sizeof</span>(*(tab-&gt;<a class="code" href="structast__hashtab.html#ad4a34c85bbad8598fd1e6cf37608d370">array</a>)))
<a name="l00662"></a>00662 #endif
<a name="l00663"></a>00663       ))
<a name="l00664"></a>00664       <span class="keywordflow">return</span>;
<a name="l00665"></a>00665 
<a name="l00666"></a>00666    <span class="comment">/* now sort the buckets into their rightful new slots */</span>
<a name="l00667"></a>00667    tab-&gt;<a class="code" href="structast__hashtab.html#aca6c133e85271118b482d523974fca7e">resize_count</a>++;
<a name="l00668"></a>00668    tab-&gt;<a class="code" href="structast__hashtab.html#a65e874326c71bc3cc8009f6899ca4eb6">hash_tab_size</a> = newsize;
<a name="l00669"></a>00669    tab-&gt;<a class="code" href="structast__hashtab.html#ad7e3544b53e89218feb557a33730eef2">largest_bucket_size</a> = 0;
<a name="l00670"></a>00670 
<a name="l00671"></a>00671    <span class="keywordflow">for</span> (b = tab-&gt;<a class="code" href="structast__hashtab.html#abc3c4c519a852f85284868cb68c8a44e">tlist</a>; b; b = bn) {
<a name="l00672"></a>00672       b-&gt;<a class="code" href="structast__hashtab__bucket.html#af0ab45e37ae5f4c9a984ecea99ec9be4">prev</a> = 0;
<a name="l00673"></a>00673       bn = b-&gt;<a class="code" href="structast__hashtab__bucket.html#ad3f87b9bd48bdc73946d7f5c48d3f00a">tnext</a>;
<a name="l00674"></a>00674       h = (*tab-&gt;<a class="code" href="structast__hashtab.html#a391f7b59a3476dc3bf1ffa1b28852670">hash</a>)(b-&gt;<a class="code" href="structast__hashtab__bucket.html#ac4fffd2513f3061cbd51acf5381177c8">object</a>) % tab-&gt;<a class="code" href="structast__hashtab.html#a65e874326c71bc3cc8009f6899ca4eb6">hash_tab_size</a>;
<a name="l00675"></a>00675       b-&gt;<a class="code" href="structast__hashtab__bucket.html#a277291f5bb0f819abb0f739591ccd961">next</a> = tab-&gt;<a class="code" href="structast__hashtab.html#ad4a34c85bbad8598fd1e6cf37608d370">array</a>[h];
<a name="l00676"></a>00676       <span class="keywordflow">if</span> (b-&gt;<a class="code" href="structast__hashtab__bucket.html#a277291f5bb0f819abb0f739591ccd961">next</a>)
<a name="l00677"></a>00677          b-&gt;<a class="code" href="structast__hashtab__bucket.html#a277291f5bb0f819abb0f739591ccd961">next</a>-&gt;<a class="code" href="structast__hashtab__bucket.html#af0ab45e37ae5f4c9a984ecea99ec9be4">prev</a> = b;
<a name="l00678"></a>00678       tab-&gt;<a class="code" href="structast__hashtab.html#ad4a34c85bbad8598fd1e6cf37608d370">array</a>[h] = b;
<a name="l00679"></a>00679    }
<a name="l00680"></a>00680    <span class="comment">/* recalc the largest bucket size */</span>
<a name="l00681"></a>00681    <span class="keywordflow">for</span> (i = 0; i &lt; tab-&gt;<a class="code" href="structast__hashtab.html#a65e874326c71bc3cc8009f6899ca4eb6">hash_tab_size</a>; i++) {
<a name="l00682"></a>00682       <span class="keywordflow">for</span> (c = 0, b = tab-&gt;<a class="code" href="structast__hashtab.html#ad4a34c85bbad8598fd1e6cf37608d370">array</a>[i]; b; b = b-&gt;<a class="code" href="structast__hashtab__bucket.html#a277291f5bb0f819abb0f739591ccd961">next</a>)
<a name="l00683"></a>00683          c++;
<a name="l00684"></a>00684       <span class="keywordflow">if</span> (c &gt; tab-&gt;<a class="code" href="structast__hashtab.html#ad7e3544b53e89218feb557a33730eef2">largest_bucket_size</a>)
<a name="l00685"></a>00685          tab-&gt;<a class="code" href="structast__hashtab.html#ad7e3544b53e89218feb557a33730eef2">largest_bucket_size</a> = c;
<a name="l00686"></a>00686    }
<a name="l00687"></a>00687 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="aef63906caa0b965e9c8d8561600038e9"></a><!-- doxytag: member="hashtab.c::ast_hashtab_resize_java" ref="aef63906caa0b965e9c8d8561600038e9" args="(struct ast_hashtab *tab)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ast_hashtab_resize_java </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structast__hashtab.html">ast_hashtab</a> *&nbsp;</td>
          <td class="paramname"> <em>tab</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Determines if a table resize should occur using the Java algorithm (if the table load factor is 75% or higher). </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>tab</em>&nbsp;</td><td>the hash table to operate on </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>0</em>&nbsp;</td><td>if the table load factor is less than or equal to 75% </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>1</em>&nbsp;</td><td>if the table load factor is greater than 75% </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="hashtab_8c_source.html#l00084">84</a> of file <a class="el" href="hashtab_8c_source.html">hashtab.c</a>.</p>

<p>References <a class="el" href="hashtab_8h_source.html#l00092">ast_hashtab::hash_tab_elements</a>, and <a class="el" href="hashtab_8h_source.html#l00091">ast_hashtab::hash_tab_size</a>.</p>

<p>Referenced by <a class="el" href="pbx_8c_source.html#l07637">ast_add_extension2_lockopt()</a>, <a class="el" href="pbx_8c_source.html#l06424">ast_context_find_or_create()</a>, <a class="el" href="hashtab_8c_source.html#l00222">ast_hashtab_create()</a>, <a class="el" href="pbx__lua_8c_source.html#l00845">lua_register_switches()</a>, <a class="el" href="pbx__ael_8c_source.html#l00113">pbx_load_module()</a>, and <a class="el" href="sched_8c_source.html#l00239">sched_context_create()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00085"></a>00085 {
<a name="l00086"></a>00086    <span class="keywordtype">double</span> loadfactor = (double) tab-&gt;<a class="code" href="structast__hashtab.html#a46bc973b99fd63faabcf465499d58167">hash_tab_elements</a> / (<span class="keywordtype">double</span>) tab-&gt;<a class="code" href="structast__hashtab.html#a65e874326c71bc3cc8009f6899ca4eb6">hash_tab_size</a>;
<a name="l00087"></a>00087 
<a name="l00088"></a>00088    <span class="keywordflow">return</span> (loadfactor &gt; 0.75);
<a name="l00089"></a>00089 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="af9b890f1277ab38f3b14b4fab1e311d3"></a><!-- doxytag: member="hashtab.c::ast_hashtab_resize_none" ref="af9b890f1277ab38f3b14b4fab1e311d3" args="(struct ast_hashtab *tab)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ast_hashtab_resize_none </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structast__hashtab.html">ast_hashtab</a> *&nbsp;</td>
          <td class="paramname"> <em>tab</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Effectively disables resizing by always returning 0, regardless of of load factor. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>tab</em>&nbsp;</td><td>the hash table to operate on </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 is always returned </dd></dl>

<p>Definition at line <a class="el" href="hashtab_8c_source.html#l00096">96</a> of file <a class="el" href="hashtab_8c_source.html">hashtab.c</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00097"></a>00097 {
<a name="l00098"></a>00098    <span class="keywordflow">return</span> 0;
<a name="l00099"></a>00099 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="ad1c8c01df7f3a22daaf5b220dbd6eb5c"></a><!-- doxytag: member="hashtab.c::ast_hashtab_resize_tight" ref="ad1c8c01df7f3a22daaf5b220dbd6eb5c" args="(struct ast_hashtab *tab)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ast_hashtab_resize_tight </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structast__hashtab.html">ast_hashtab</a> *&nbsp;</td>
          <td class="paramname"> <em>tab</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Causes a resize whenever the <a class="el" href="structnumber.html" title="Number structure.">number</a> of elements stored in the table exceeds the <a class="el" href="structnumber.html" title="Number structure.">number</a> of buckets in the table. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>tab</em>&nbsp;</td><td>the hash table to operate on </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>0</em>&nbsp;</td><td>if the <a class="el" href="structnumber.html" title="Number structure.">number</a> of elements in the table is less than or equal to the <a class="el" href="structnumber.html" title="Number structure.">number</a> of buckets </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>1</em>&nbsp;</td><td>if the <a class="el" href="structnumber.html" title="Number structure.">number</a> of elements in the table exceeds the <a class="el" href="structnumber.html" title="Number structure.">number</a> of buckets </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="hashtab_8c_source.html#l00091">91</a> of file <a class="el" href="hashtab_8c_source.html">hashtab.c</a>.</p>

<p>References <a class="el" href="hashtab_8h_source.html#l00092">ast_hashtab::hash_tab_elements</a>, and <a class="el" href="hashtab_8h_source.html#l00091">ast_hashtab::hash_tab_size</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00092"></a>00092 {
<a name="l00093"></a>00093    <span class="keywordflow">return</span> (tab-&gt;<a class="code" href="structast__hashtab.html#a46bc973b99fd63faabcf465499d58167">hash_tab_elements</a> &gt; tab-&gt;<a class="code" href="structast__hashtab.html#a65e874326c71bc3cc8009f6899ca4eb6">hash_tab_size</a>); <span class="comment">/* this is quicker than division */</span>
<a name="l00094"></a>00094 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="ac3452d3a8bca5b4f2611bb96b7a44f31"></a><!-- doxytag: member="hashtab.c::ast_hashtab_size" ref="ac3452d3a8bca5b4f2611bb96b7a44f31" args="(struct ast_hashtab *tab)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ast_hashtab_size </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structast__hashtab.html">ast_hashtab</a> *&nbsp;</td>
          <td class="paramname"> <em>tab</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the <a class="el" href="structnumber.html" title="Number structure.">number</a> of elements stored in the hashtab. </p>

<p>Definition at line <a class="el" href="hashtab_8c_source.html#l00621">621</a> of file <a class="el" href="hashtab_8c_source.html">hashtab.c</a>.</p>

<p>References <a class="el" href="hashtab_8h_source.html#l00092">ast_hashtab::hash_tab_elements</a>.</p>

<p>Referenced by <a class="el" href="pbx_8c_source.html#l04828">ast_context_remove_extension_callerid2()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00622"></a>00622 {
<a name="l00623"></a>00623    <span class="keywordflow">return</span> tab-&gt;<a class="code" href="structast__hashtab.html#a46bc973b99fd63faabcf465499d58167">hash_tab_elements</a>;
<a name="l00624"></a>00624 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="ac5a19bffadbbd4eb31f190e576f88512"></a><!-- doxytag: member="hashtab.c::ast_hashtab_start_traversal" ref="ac5a19bffadbbd4eb31f190e576f88512" args="(struct ast_hashtab *tab)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structast__hashtab__iter.html">ast_hashtab_iter</a>* ast_hashtab_start_traversal </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structast__hashtab.html">ast_hashtab</a> *&nbsp;</td>
          <td class="paramname"> <em>tab</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [read]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gives an iterator to hastable. </p>

<p>Definition at line <a class="el" href="hashtab_8c_source.html#l00692">692</a> of file <a class="el" href="hashtab_8c_source.html">hashtab.c</a>.</p>

<p>References <a class="el" href="astmm_8c_source.html#l00199">__ast_calloc()</a>, <a class="el" href="astmm_8h_source.html#l00072">ast_calloc</a>, <a class="el" href="lock_8h_source.html#l01796">ast_rwlock_rdlock()</a>, <a class="el" href="hashtab_8h_source.html#l00096">ast_hashtab::do_locking</a>, <a class="el" href="hashtab_8h_source.html#l00098">ast_hashtab::lock</a>, <a class="el" href="hashtab_8h_source.html#l00105">ast_hashtab_iter::next</a>, <a class="el" href="hashtab_8h_source.html#l00104">ast_hashtab_iter::tab</a>, and <a class="el" href="hashtab_8h_source.html#l00083">ast_hashtab::tlist</a>.</p>

<p>Referenced by <a class="el" href="pbx_8c_source.html#l08276">__ast_context_destroy()</a>, <a class="el" href="pbx_8c_source.html#l06623">ast_merge_contexts_and_delete()</a>, <a class="el" href="pbx_8c_source.html#l06539">context_merge()</a>, and <a class="el" href="pbx_8c_source.html#l02000">create_match_char_tree()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00694"></a>00694 {
<a name="l00695"></a>00695    <span class="comment">/* returns an iterator */</span>
<a name="l00696"></a>00696    <span class="keyword">struct </span><a class="code" href="structast__hashtab__iter.html" title="an iterator for traversing the buckets">ast_hashtab_iter</a> *it;
<a name="l00697"></a>00697 
<a name="l00698"></a>00698    <span class="keywordflow">if</span> (!(it =
<a name="l00699"></a>00699 #<span class="keywordflow">if</span> (defined(MALLOC_DEBUG) &amp;&amp; !defined(STANDALONE))
<a name="l00700"></a>00700          <a class="code" href="astmm_8h.html#ad800d5c993a0c605f6e061bdef1b524c">__ast_calloc</a>(1, <span class="keyword">sizeof</span>(*it), file, lineno, func)
<a name="l00701"></a>00701 #<span class="keywordflow">else</span>
<a name="l00702"></a>00702          <a class="code" href="astmm_8h.html#a1cb33b63d94fbbde94234b062249e015">ast_calloc</a>(1, <span class="keyword">sizeof</span>(*it))
<a name="l00703"></a>00703 #endif
<a name="l00704"></a>00704       ))
<a name="l00705"></a>00705       <span class="keywordflow">return</span> NULL;
<a name="l00706"></a>00706 
<a name="l00707"></a>00707    it-&gt;<a class="code" href="structast__hashtab__iter.html#a277291f5bb0f819abb0f739591ccd961">next</a> = tab-&gt;<a class="code" href="structast__hashtab.html#abc3c4c519a852f85284868cb68c8a44e">tlist</a>;
<a name="l00708"></a>00708    it-&gt;<a class="code" href="structast__hashtab__iter.html#a544ff1295545c4490180d179a5482f20">tab</a> = tab;
<a name="l00709"></a>00709    <span class="keywordflow">if</span> (tab-&gt;<a class="code" href="structast__hashtab.html#ac53417dd5a9c9583bdacc986bb861c60">do_locking</a>)
<a name="l00710"></a>00710       <a class="code" href="lock_8h.html#ae6703edce409c34119e27bdca1186d10">ast_rwlock_rdlock</a>(&amp;tab-&gt;<a class="code" href="structast__hashtab.html#ace4e0066a5b24f84b90536e9906619f6">lock</a>);
<a name="l00711"></a>00711 
<a name="l00712"></a>00712    <span class="keywordflow">return</span> it;
<a name="l00713"></a>00713 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a82f79ee2e22d2a5bba10f7730bc14a5c"></a><!-- doxytag: member="hashtab.c::ast_hashtab_start_write_traversal" ref="a82f79ee2e22d2a5bba10f7730bc14a5c" args="(struct ast_hashtab *tab)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structast__hashtab__iter.html">ast_hashtab_iter</a>* ast_hashtab_start_write_traversal </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structast__hashtab.html">ast_hashtab</a> *&nbsp;</td>
          <td class="paramname"> <em>tab</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [read]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gives an iterator to hastable. </p>

<p>Definition at line <a class="el" href="hashtab_8c_source.html#l00719">719</a> of file <a class="el" href="hashtab_8c_source.html">hashtab.c</a>.</p>

<p>References <a class="el" href="astmm_8c_source.html#l00199">__ast_calloc()</a>, <a class="el" href="astmm_8h_source.html#l00072">ast_calloc</a>, <a class="el" href="lock_8h_source.html#l01827">ast_rwlock_wrlock()</a>, <a class="el" href="hashtab_8h_source.html#l00096">ast_hashtab::do_locking</a>, <a class="el" href="hashtab_8h_source.html#l00098">ast_hashtab::lock</a>, <a class="el" href="hashtab_8h_source.html#l00105">ast_hashtab_iter::next</a>, <a class="el" href="hashtab_8h_source.html#l00104">ast_hashtab_iter::tab</a>, and <a class="el" href="hashtab_8h_source.html#l00083">ast_hashtab::tlist</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00721"></a>00721 {
<a name="l00722"></a>00722    <span class="comment">/* returns an iterator */</span>
<a name="l00723"></a>00723    <span class="keyword">struct </span><a class="code" href="structast__hashtab__iter.html" title="an iterator for traversing the buckets">ast_hashtab_iter</a> *it;
<a name="l00724"></a>00724 
<a name="l00725"></a>00725    <span class="keywordflow">if</span> (!(it =
<a name="l00726"></a>00726 #<span class="keywordflow">if</span> (defined(MALLOC_DEBUG) &amp;&amp; !defined(STANDALONE))
<a name="l00727"></a>00727          <a class="code" href="astmm_8h.html#ad800d5c993a0c605f6e061bdef1b524c">__ast_calloc</a>(1, <span class="keyword">sizeof</span>(*it), file, lineno, func)
<a name="l00728"></a>00728 #<span class="keywordflow">else</span>
<a name="l00729"></a>00729          <a class="code" href="astmm_8h.html#a1cb33b63d94fbbde94234b062249e015">ast_calloc</a>(1, <span class="keyword">sizeof</span>(*it))
<a name="l00730"></a>00730 #endif
<a name="l00731"></a>00731       ))
<a name="l00732"></a>00732       <span class="keywordflow">return</span> NULL;
<a name="l00733"></a>00733 
<a name="l00734"></a>00734    it-&gt;<a class="code" href="structast__hashtab__iter.html#a277291f5bb0f819abb0f739591ccd961">next</a> = tab-&gt;<a class="code" href="structast__hashtab.html#abc3c4c519a852f85284868cb68c8a44e">tlist</a>;
<a name="l00735"></a>00735    it-&gt;<a class="code" href="structast__hashtab__iter.html#a544ff1295545c4490180d179a5482f20">tab</a> = tab;
<a name="l00736"></a>00736    <span class="keywordflow">if</span> (tab-&gt;<a class="code" href="structast__hashtab.html#ac53417dd5a9c9583bdacc986bb861c60">do_locking</a>)
<a name="l00737"></a>00737       <a class="code" href="lock_8h.html#a952527792bba2a323118ae911f9aa1f7">ast_rwlock_wrlock</a>(&amp;tab-&gt;<a class="code" href="structast__hashtab.html#ace4e0066a5b24f84b90536e9906619f6">lock</a>);
<a name="l00738"></a>00738 
<a name="l00739"></a>00739    <span class="keywordflow">return</span> it;
<a name="l00740"></a>00740 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a0075220de774384c45e3cf3906d51110"></a><!-- doxytag: member="hashtab.c::ast_hashtab_unlock" ref="a0075220de774384c45e3cf3906d51110" args="(struct ast_hashtab *tab)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ast_hashtab_unlock </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structast__hashtab.html">ast_hashtab</a> *&nbsp;</td>
          <td class="paramname"> <em>tab</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>release a read- or write- lock. </p>

<p>Definition at line <a class="el" href="hashtab_8c_source.html#l00379">379</a> of file <a class="el" href="hashtab_8c_source.html">hashtab.c</a>.</p>

<p>References <a class="el" href="lock_8h_source.html#l01791">ast_rwlock_unlock()</a>, and <a class="el" href="hashtab_8h_source.html#l00098">ast_hashtab::lock</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00380"></a>00380 {
<a name="l00381"></a>00381    <a class="code" href="lock_8h.html#a21ce13cd6c771d5855f47ae7a1dd50b6">ast_rwlock_unlock</a>(&amp;tab-&gt;<a class="code" href="structast__hashtab.html#ace4e0066a5b24f84b90536e9906619f6">lock</a>);
<a name="l00382"></a>00382 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a2afda46f84d0aec79d91155b6981800a"></a><!-- doxytag: member="hashtab.c::ast_hashtab_wrlock" ref="a2afda46f84d0aec79d91155b6981800a" args="(struct ast_hashtab *tab)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ast_hashtab_wrlock </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structast__hashtab.html">ast_hashtab</a> *&nbsp;</td>
          <td class="paramname"> <em>tab</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Request a write-lock on the table. </p>

<p>Definition at line <a class="el" href="hashtab_8c_source.html#l00359">359</a> of file <a class="el" href="hashtab_8c_source.html">hashtab.c</a>.</p>

<p>References <a class="el" href="lock_8h_source.html#l01827">ast_rwlock_wrlock()</a>, and <a class="el" href="hashtab_8h_source.html#l00098">ast_hashtab::lock</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00360"></a>00360 {
<a name="l00361"></a>00361    <a class="code" href="lock_8h.html#a952527792bba2a323118ae911f9aa1f7">ast_rwlock_wrlock</a>(&amp;tab-&gt;<a class="code" href="structast__hashtab.html#ace4e0066a5b24f84b90536e9906619f6">lock</a>);
<a name="l00362"></a>00362 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a76a1018cc569eb65a6b29fab0a8481c1"></a><!-- doxytag: member="hashtab.c::ast_is_prime" ref="a76a1018cc569eb65a6b29fab0a8481c1" args="(int num)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ast_is_prime </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>num</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Determines if the specified <a class="el" href="structnumber.html" title="Number structure.">number</a> is prime. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>num</em>&nbsp;</td><td>the <a class="el" href="structnumber.html" title="Number structure.">number</a> to test </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>0</em>&nbsp;</td><td>if the <a class="el" href="structnumber.html" title="Number structure.">number</a> is not prime </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>1</em>&nbsp;</td><td>if the <a class="el" href="structnumber.html" title="Number structure.">number</a> is prime </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="hashtab_8c_source.html#l00101">101</a> of file <a class="el" href="hashtab_8c_source.html">hashtab.c</a>.</p>

<p>Referenced by <a class="el" href="hashtab_8c_source.html#l00222">ast_hashtab_create()</a>, <a class="el" href="hashtab_8c_source.html#l00127">ast_hashtab_newsize_java()</a>, and <a class="el" href="hashtab_8c_source.html#l00137">ast_hashtab_newsize_tight()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00102"></a>00102 {
<a name="l00103"></a>00103    <span class="keywordtype">int</span> tnum, limit;
<a name="l00104"></a>00104 
<a name="l00105"></a>00105    <span class="keywordflow">if</span> (!(<a class="code" href="adsistub_8c.html#af6fc584548091f45267cfaf7066119bd">num</a> &amp; 0x1)) <span class="comment">/* even number -- not prime */</span>
<a name="l00106"></a>00106       <span class="keywordflow">return</span> 0;
<a name="l00107"></a>00107 
<a name="l00108"></a>00108    <span class="comment">/* Loop through ODD numbers starting with 3 */</span>
<a name="l00109"></a>00109 
<a name="l00110"></a>00110    tnum = 3;
<a name="l00111"></a>00111    limit = <a class="code" href="adsistub_8c.html#af6fc584548091f45267cfaf7066119bd">num</a>;
<a name="l00112"></a>00112    <span class="keywordflow">while</span> (tnum &lt; limit) {
<a name="l00113"></a>00113       <span class="keywordflow">if</span> (!(<a class="code" href="adsistub_8c.html#af6fc584548091f45267cfaf7066119bd">num</a> % tnum))
<a name="l00114"></a>00114          <span class="keywordflow">return</span> 0;
<a name="l00115"></a>00115 
<a name="l00116"></a>00116       <span class="comment">/* really, we only need to check sqrt(num) numbers */</span>
<a name="l00117"></a>00117       limit = <a class="code" href="adsistub_8c.html#af6fc584548091f45267cfaf7066119bd">num</a> / tnum;
<a name="l00118"></a>00118 
<a name="l00119"></a>00119       <span class="comment">/* we only check odd numbers */</span>
<a name="l00120"></a>00120       tnum = tnum + 2;
<a name="l00121"></a>00121    }
<a name="l00122"></a>00122 
<a name="l00123"></a>00123    <span class="comment">/* if we made it through the loop, the number is a prime */</span>
<a name="l00124"></a>00124    <span class="keywordflow">return</span> 1;
<a name="l00125"></a>00125 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a0a70cc0111c648216070a8415fe6d133"></a><!-- doxytag: member="hashtab.c::tlist_add_head" ref="a0a70cc0111c648216070a8415fe6d133" args="(struct ast_hashtab_bucket **head, struct ast_hashtab_bucket *item)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void tlist_add_head </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structast__hashtab__bucket.html">ast_hashtab_bucket</a> **&nbsp;</td>
          <td class="paramname"> <em>head</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structast__hashtab__bucket.html">ast_hashtab_bucket</a> *&nbsp;</td>
          <td class="paramname"> <em>item</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="hashtab_8c_source.html#l00341">341</a> of file <a class="el" href="hashtab_8c_source.html">hashtab.c</a>.</p>

<p>References <a class="el" href="hashtab_8h_source.html#l00076">ast_hashtab_bucket::tnext</a>, and <a class="el" href="hashtab_8h_source.html#l00077">ast_hashtab_bucket::tprev</a>.</p>

<p>Referenced by <a class="el" href="hashtab_8c_source.html#l00457">ast_hashtab_insert_immediate_bucket()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00342"></a>00342 {
<a name="l00343"></a>00343    <span class="keywordflow">if</span> (*head) {
<a name="l00344"></a>00344       item-&gt;<a class="code" href="structast__hashtab__bucket.html#ad3f87b9bd48bdc73946d7f5c48d3f00a">tnext</a> = *head;
<a name="l00345"></a>00345       item-&gt;<a class="code" href="structast__hashtab__bucket.html#a6c8449130d6e42faf1a1879c8f78304a">tprev</a> = NULL;
<a name="l00346"></a>00346       (*head)-&gt;<a class="code" href="structast__hashtab__bucket.html#a6c8449130d6e42faf1a1879c8f78304a">tprev</a> = item;
<a name="l00347"></a>00347       *head = item;
<a name="l00348"></a>00348    } <span class="keywordflow">else</span> {
<a name="l00349"></a>00349       <span class="comment">/* the list is empty */</span>
<a name="l00350"></a>00350       *head = item;
<a name="l00351"></a>00351       item-&gt;<a class="code" href="structast__hashtab__bucket.html#a6c8449130d6e42faf1a1879c8f78304a">tprev</a> = NULL;
<a name="l00352"></a>00352       item-&gt;<a class="code" href="structast__hashtab__bucket.html#ad3f87b9bd48bdc73946d7f5c48d3f00a">tnext</a> = NULL;
<a name="l00353"></a>00353    }
<a name="l00354"></a>00354 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="acea5c0d1395a2a9a8e5287a37b0b8c7c"></a><!-- doxytag: member="hashtab.c::tlist_del_item" ref="acea5c0d1395a2a9a8e5287a37b0b8c7c" args="(struct ast_hashtab_bucket **head, struct ast_hashtab_bucket *item)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void tlist_del_item </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structast__hashtab__bucket.html">ast_hashtab_bucket</a> **&nbsp;</td>
          <td class="paramname"> <em>head</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structast__hashtab__bucket.html">ast_hashtab_bucket</a> *&nbsp;</td>
          <td class="paramname"> <em>item</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="hashtab_8c_source.html#l00326">326</a> of file <a class="el" href="hashtab_8c_source.html">hashtab.c</a>.</p>

<p>References <a class="el" href="hashtab_8h_source.html#l00076">ast_hashtab_bucket::tnext</a>, and <a class="el" href="hashtab_8h_source.html#l00077">ast_hashtab_bucket::tprev</a>.</p>

<p>Referenced by <a class="el" href="hashtab_8c_source.html#l00384">ast_hashtab_destroy()</a>, and <a class="el" href="hashtab_8c_source.html#l00763">ast_hashtab_remove_object_internal()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00327"></a>00327 {
<a name="l00328"></a>00328    <span class="comment">/* item had better be in the list! or suffer the weirdness that occurs, later! */</span>
<a name="l00329"></a>00329    <span class="keywordflow">if</span> (*head == item) { <span class="comment">/* first item in the list */</span>
<a name="l00330"></a>00330       *head = item-&gt;<a class="code" href="structast__hashtab__bucket.html#ad3f87b9bd48bdc73946d7f5c48d3f00a">tnext</a>;
<a name="l00331"></a>00331       <span class="keywordflow">if</span> (item-&gt;<a class="code" href="structast__hashtab__bucket.html#ad3f87b9bd48bdc73946d7f5c48d3f00a">tnext</a>)
<a name="l00332"></a>00332          item-&gt;<a class="code" href="structast__hashtab__bucket.html#ad3f87b9bd48bdc73946d7f5c48d3f00a">tnext</a>-&gt;<a class="code" href="structast__hashtab__bucket.html#a6c8449130d6e42faf1a1879c8f78304a">tprev</a> = NULL;
<a name="l00333"></a>00333    } <span class="keywordflow">else</span> {
<a name="l00334"></a>00334       <span class="comment">/* short circuit stuff */</span>
<a name="l00335"></a>00335       item-&gt;<a class="code" href="structast__hashtab__bucket.html#a6c8449130d6e42faf1a1879c8f78304a">tprev</a>-&gt;<a class="code" href="structast__hashtab__bucket.html#ad3f87b9bd48bdc73946d7f5c48d3f00a">tnext</a> = item-&gt;<a class="code" href="structast__hashtab__bucket.html#ad3f87b9bd48bdc73946d7f5c48d3f00a">tnext</a>;
<a name="l00336"></a>00336       <span class="keywordflow">if</span> (item-&gt;<a class="code" href="structast__hashtab__bucket.html#ad3f87b9bd48bdc73946d7f5c48d3f00a">tnext</a>)
<a name="l00337"></a>00337          item-&gt;<a class="code" href="structast__hashtab__bucket.html#ad3f87b9bd48bdc73946d7f5c48d3f00a">tnext</a>-&gt;<a class="code" href="structast__hashtab__bucket.html#a6c8449130d6e42faf1a1879c8f78304a">tprev</a> = item-&gt;<a class="code" href="structast__hashtab__bucket.html#a6c8449130d6e42faf1a1879c8f78304a">tprev</a>;
<a name="l00338"></a>00338    }
<a name="l00339"></a>00339 }
</pre></div></p>

</div>
</div>
</div>
<hr size="1"/><address style="text-align: right;"><small>Generated on Wed May 5 15:22:10 2010 for Asterisk - the Open Source PBX by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.1 </small></address>
</body>
</html>
