<HTML>
    <HEAD>
      <TITLE>Asterisk.org: Developer Documentation (5 May 2010)</TITLE>
      <LINK HREF="doxygen.css" REL="stylesheet" TYPE="text/css">
    </HEAD>
    <BODY BGCOLOR="#FFFFFF">
<div><font size="2" align="right">Wed May 5 15:18:41 2010</font></div>

<h2>Asterisk developer's documentation</h2>
<hr/>
<!-- Generated by Doxygen 1.6.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
  <div class="navpath"><a class="el" href="dir_1ab815038f534adda65c8b4ae4993449.html">include</a>&nbsp;&raquo&nbsp;<a class="el" href="dir_16d825f1fa9ecca2e70b1a8d9256d0e6.html">asterisk</a>
  </div>
</div>
<div class="contents">
<h1>hashtab.h</h1><a href="hashtab_8h.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">/*</span>
<a name="l00002"></a>00002 <span class="comment"> * Asterisk -- An open source telephony toolkit.</span>
<a name="l00003"></a>00003 <span class="comment"> *</span>
<a name="l00004"></a>00004 <span class="comment"> * Copyright (C) 2006, Digium, Inc.</span>
<a name="l00005"></a>00005 <span class="comment"> *</span>
<a name="l00006"></a>00006 <span class="comment"> * Steve Murphy &lt;murf@digium.com&gt;</span>
<a name="l00007"></a>00007 <span class="comment"> *</span>
<a name="l00008"></a>00008 <span class="comment"> * See http://www.asterisk.org for more information about</span>
<a name="l00009"></a>00009 <span class="comment"> * the Asterisk project. Please do not directly contact</span>
<a name="l00010"></a>00010 <span class="comment"> * any of the maintainers of this project for assistance;</span>
<a name="l00011"></a>00011 <span class="comment"> * the project provides a web site, mailing lists and IRC</span>
<a name="l00012"></a>00012 <span class="comment"> * channels for your use.</span>
<a name="l00013"></a>00013 <span class="comment"> *</span>
<a name="l00014"></a>00014 <span class="comment"> * This program is free software, distributed under the terms of</span>
<a name="l00015"></a>00015 <span class="comment"> * the GNU General Public License Version 2. See the LICENSE file</span>
<a name="l00016"></a>00016 <span class="comment"> * at the top of the source tree.</span>
<a name="l00017"></a>00017 <span class="comment"> */</span>
<a name="l00018"></a>00018 <span class="preprocessor">#ifndef _ASTERISK_HASHTAB_H_</span>
<a name="l00019"></a>00019 <span class="preprocessor"></span><span class="preprocessor">#define _ASTERISK_HASHTAB_H_</span>
<a name="l00020"></a><a class="code" href="hashtab_8h.html#a1afa73d7fa95d01675c545859245071b">00020</a> <span class="preprocessor"></span><span class="preprocessor">#define __USE_UNIX98 1          </span><span class="comment">/* to get the MUTEX_RECURSIVE stuff */</span>
<a name="l00021"></a>00021 <span class="comment"></span>
<a name="l00022"></a>00022 <span class="comment">/*! \file</span>
<a name="l00023"></a>00023 <span class="comment"> * \brief Generic (perhaps overly so) hashtable implementation</span>
<a name="l00024"></a>00024 <span class="comment"> * \ref AstHash</span>
<a name="l00025"></a>00025 <span class="comment"> */</span><span class="comment"></span>
<a name="l00026"></a>00026 <span class="comment">/*! \page AstHash Hash Table support in Asterisk</span>
<a name="l00027"></a>00027 <span class="comment"></span>
<a name="l00028"></a>00028 <span class="comment">A hash table is a structure that allows for an exact-match search</span>
<a name="l00029"></a>00029 <span class="comment">in O(1) (or close to that) time.</span>
<a name="l00030"></a>00030 <span class="comment"></span>
<a name="l00031"></a>00031 <span class="comment">The method: given: a set of {key,val} pairs. (at a minimum).</span>
<a name="l00032"></a>00032 <span class="comment">            given: a hash function, which, given a key,</span>
<a name="l00033"></a>00033 <span class="comment">            will return an integer. Ideally, each key in the</span>
<a name="l00034"></a>00034 <span class="comment">            set will have its own unique associated hash value.</span>
<a name="l00035"></a>00035 <span class="comment">         This hash number will index into an array. &quot;buckets&quot;</span>
<a name="l00036"></a>00036 <span class="comment">            are what the elements of this array are called. To</span>
<a name="l00037"></a>00037 <span class="comment">            handle possible collisions in hash values, buckets can form a list.</span>
<a name="l00038"></a>00038 <span class="comment"></span>
<a name="l00039"></a>00039 <span class="comment">The key for a value must be contained in the value, or we won&apos;t</span>
<a name="l00040"></a>00040 <span class="comment">be able to find it in the bucket list.</span>
<a name="l00041"></a>00041 <span class="comment"></span>
<a name="l00042"></a>00042 <span class="comment">This implementation is pretty generic, because:</span>
<a name="l00043"></a>00043 <span class="comment"></span>
<a name="l00044"></a>00044 <span class="comment"> 1. The value and key are expected to be in a structure</span>
<a name="l00045"></a>00045 <span class="comment">    (along with other data, perhaps) and it&apos;s address is a &quot;void *&quot;.</span>
<a name="l00046"></a>00046 <span class="comment"> 2. The pointer to a compare function must be passed in at the</span>
<a name="l00047"></a>00047 <span class="comment">    time of creation, and is stored in the hashtable.</span>
<a name="l00048"></a>00048 <span class="comment"> 3. The pointer to a resize function, which returns 1 if the</span>
<a name="l00049"></a>00049 <span class="comment">    hash table is to be grown. A default routine is provided</span>
<a name="l00050"></a>00050 <span class="comment">    if the pointer is NULL, and uses the java hashtable metric</span>
<a name="l00051"></a>00051 <span class="comment">    of a 75% load factor.</span>
<a name="l00052"></a>00052 <span class="comment"> 4. The pointer to a &quot;new size&quot; function, which returns a preferable</span>
<a name="l00053"></a>00053 <span class="comment">    new size for the hash table bucket array. By default, a function</span>
<a name="l00054"></a>00054 <span class="comment">    is supplied which roughly doubles the size of the array, is provided.</span>
<a name="l00055"></a>00055 <span class="comment">    This size should ideally be a prime number.</span>
<a name="l00056"></a>00056 <span class="comment"> 5. The hashing function pointer must also be supplied. This function</span>
<a name="l00057"></a>00057 <span class="comment">    must be written by the user to access the keys in the objects being</span>
<a name="l00058"></a>00058 <span class="comment">    stored. Some helper functions that use a simple &quot;mult by prime, add</span>
<a name="l00059"></a>00059 <span class="comment">    the next char&quot;, sort of string hash, or a simple modulus of the hash</span>
<a name="l00060"></a>00060 <span class="comment">    table size for ints, is provided; the user can use these simple</span>
<a name="l00061"></a>00061 <span class="comment">    algorithms to generate a hash, or implement any other algorithms they</span>
<a name="l00062"></a>00062 <span class="comment">    wish.</span>
<a name="l00063"></a>00063 <span class="comment"> 6. Recently updated the hash routines to use Doubly-linked lists for buckets,</span>
<a name="l00064"></a>00064 <span class="comment">    and added a doubly-linked list that threads thru every bucket in the table.</span>
<a name="l00065"></a>00065 <span class="comment">    The list of all buckets is on the HashTab struct. The Traversal was modified</span>
<a name="l00066"></a>00066 <span class="comment">    to go thru this list instead of searching the bucket array for buckets.</span>
<a name="l00067"></a>00067 <span class="comment">    This also should make it safe to remove a bucket during the traversal.</span>
<a name="l00068"></a>00068 <span class="comment">    Removal and destruction routines will work faster.</span>
<a name="l00069"></a>00069 <span class="comment">*/</span>
<a name="l00070"></a>00070 
<a name="l00071"></a><a class="code" href="structast__hashtab__bucket.html">00071</a> <span class="keyword">struct </span><a class="code" href="structast__hashtab__bucket.html">ast_hashtab_bucket</a>
<a name="l00072"></a>00072 {
<a name="l00073"></a><a class="code" href="structast__hashtab__bucket.html#ac4fffd2513f3061cbd51acf5381177c8">00073</a>    <span class="keyword">const</span> <span class="keywordtype">void</span> *<a class="code" href="structast__hashtab__bucket.html#ac4fffd2513f3061cbd51acf5381177c8">object</a>;                    <span class="comment">/*!&lt; whatever it is we are storing in this table */</span>
<a name="l00074"></a><a class="code" href="structast__hashtab__bucket.html#a277291f5bb0f819abb0f739591ccd961">00074</a>    <span class="keyword">struct </span><a class="code" href="structast__hashtab__bucket.html">ast_hashtab_bucket</a> *<a class="code" href="structast__hashtab__bucket.html#a277291f5bb0f819abb0f739591ccd961">next</a>;       <span class="comment">/*!&lt; a DLL of buckets in hash collision */</span>
<a name="l00075"></a><a class="code" href="structast__hashtab__bucket.html#af0ab45e37ae5f4c9a984ecea99ec9be4">00075</a>    <span class="keyword">struct </span><a class="code" href="structast__hashtab__bucket.html">ast_hashtab_bucket</a> *<a class="code" href="structast__hashtab__bucket.html#af0ab45e37ae5f4c9a984ecea99ec9be4">prev</a>;       <span class="comment">/*!&lt; a DLL of buckets in hash collision */</span>
<a name="l00076"></a><a class="code" href="structast__hashtab__bucket.html#ad3f87b9bd48bdc73946d7f5c48d3f00a">00076</a>    <span class="keyword">struct </span><a class="code" href="structast__hashtab__bucket.html">ast_hashtab_bucket</a> *<a class="code" href="structast__hashtab__bucket.html#ad3f87b9bd48bdc73946d7f5c48d3f00a">tnext</a>;      <span class="comment">/*!&lt; a DLL of all the hash buckets for traversal */</span>
<a name="l00077"></a><a class="code" href="structast__hashtab__bucket.html#a6c8449130d6e42faf1a1879c8f78304a">00077</a>    <span class="keyword">struct </span><a class="code" href="structast__hashtab__bucket.html">ast_hashtab_bucket</a> *<a class="code" href="structast__hashtab__bucket.html#a6c8449130d6e42faf1a1879c8f78304a">tprev</a>;      <span class="comment">/*!&lt; a DLL of all the hash buckets for traversal */</span>
<a name="l00078"></a>00078 };
<a name="l00079"></a>00079 
<a name="l00080"></a><a class="code" href="structast__hashtab.html">00080</a> <span class="keyword">struct </span><a class="code" href="structast__hashtab.html">ast_hashtab</a>
<a name="l00081"></a>00081 {
<a name="l00082"></a><a class="code" href="structast__hashtab.html#ad4a34c85bbad8598fd1e6cf37608d370">00082</a>    <span class="keyword">struct </span><a class="code" href="structast__hashtab__bucket.html">ast_hashtab_bucket</a> **<a class="code" href="structast__hashtab.html#ad4a34c85bbad8598fd1e6cf37608d370">array</a>;
<a name="l00083"></a><a class="code" href="structast__hashtab.html#abc3c4c519a852f85284868cb68c8a44e">00083</a>    <span class="keyword">struct </span><a class="code" href="structast__hashtab__bucket.html">ast_hashtab_bucket</a> *<a class="code" href="structast__hashtab.html#abc3c4c519a852f85284868cb68c8a44e">tlist</a>;      <span class="comment">/*!&lt; the head of a DLList of all the hashbuckets in the table (for traversal). */</span>
<a name="l00084"></a>00084 
<a name="l00085"></a>00085    int (*<a class="code" href="structast__hashtab.html#a0f84e89988b57ec4039f039eb818be65">compare</a>) (<span class="keyword">const</span> <span class="keywordtype">void</span> *a, <span class="keyword">const</span> <span class="keywordtype">void</span> *b);  <span class="comment">/*!&lt; a ptr to func that returns int, and take two void* ptrs, compares them,</span>
<a name="l00086"></a>00086 <span class="comment">                                        rets -1 if a &lt; b; rets 0 if a==b; rets 1 if a&gt;b */</span>
<a name="l00087"></a>00087    int (*<a class="code" href="structast__hashtab.html#aa50f8d4f1283e0b777dd85f17423fae1">newsize</a>) (<span class="keyword">struct </span><a class="code" href="structast__hashtab.html">ast_hashtab</a> *tab); <span class="comment">/*!&lt; a ptr to func that returns int, a new size for hash tab, based on curr_size */</span>
<a name="l00088"></a>00088    int (*<a class="code" href="structast__hashtab.html#a54c408904d1a28302f6cf7051b1dc9e2">resize</a>) (<span class="keyword">struct </span><a class="code" href="structast__hashtab.html">ast_hashtab</a> *tab);  <span class="comment">/*!&lt; a function to decide whether this hashtable should be resized now */</span>
<a name="l00089"></a>00089    <span class="keywordtype">unsigned</span> int (*<a class="code" href="structast__hashtab.html#a391f7b59a3476dc3bf1ffa1b28852670">hash</a>) (<span class="keyword">const</span> <span class="keywordtype">void</span> *obj);         <span class="comment">/*!&lt; a hash func ptr for this table. Given a raw ptr to an obj,</span>
<a name="l00090"></a>00090 <span class="comment">                                        it calcs a hash.*/</span>
<a name="l00091"></a><a class="code" href="structast__hashtab.html#a65e874326c71bc3cc8009f6899ca4eb6">00091</a>    <span class="keywordtype">int</span> <a class="code" href="structast__hashtab.html#a65e874326c71bc3cc8009f6899ca4eb6">hash_tab_size</a>;                            <span class="comment">/*!&lt; the size of the bucket array */</span>
<a name="l00092"></a><a class="code" href="structast__hashtab.html#a46bc973b99fd63faabcf465499d58167">00092</a>    <span class="keywordtype">int</span> <a class="code" href="structast__hashtab.html#a46bc973b99fd63faabcf465499d58167">hash_tab_elements</a>;                        <span class="comment">/*!&lt; the number of objects currently stored in the table */</span>
<a name="l00093"></a><a class="code" href="structast__hashtab.html#ad7e3544b53e89218feb557a33730eef2">00093</a>    <span class="keywordtype">int</span> <a class="code" href="structast__hashtab.html#ad7e3544b53e89218feb557a33730eef2">largest_bucket_size</a>;                      <span class="comment">/*!&lt; a stat on the health of the table */</span>
<a name="l00094"></a><a class="code" href="structast__hashtab.html#aca6c133e85271118b482d523974fca7e">00094</a>    <span class="keywordtype">int</span> <a class="code" href="structast__hashtab.html#aca6c133e85271118b482d523974fca7e">resize_count</a>;                             <span class="comment">/*!&lt; a count of the number of times this table has been</span>
<a name="l00095"></a>00095 <span class="comment">                                        resized */</span>
<a name="l00096"></a><a class="code" href="structast__hashtab.html#ac53417dd5a9c9583bdacc986bb861c60">00096</a>    <span class="keywordtype">int</span> <a class="code" href="structast__hashtab.html#ac53417dd5a9c9583bdacc986bb861c60">do_locking</a>;                               <span class="comment">/*!&lt; if 1 use locks to guarantee safety of insertions/deletions */</span>
<a name="l00097"></a>00097    <span class="comment">/* this spot reserved for the proper lock storage */</span>
<a name="l00098"></a><a class="code" href="structast__hashtab.html#ace4e0066a5b24f84b90536e9906619f6">00098</a>    <a class="code" href="lock_8h.html#af7598796d461f7dcb95cea6be65806f8">ast_rwlock_t</a> <a class="code" href="structast__hashtab.html#ace4e0066a5b24f84b90536e9906619f6">lock</a>;                                <span class="comment">/* is this as good as it sounds? */</span>
<a name="l00099"></a>00099 };
<a name="l00100"></a>00100 <span class="comment"></span>
<a name="l00101"></a>00101 <span class="comment">/*! \brief an iterator for traversing the buckets */</span>
<a name="l00102"></a><a class="code" href="structast__hashtab__iter.html">00102</a> <span class="keyword">struct </span><a class="code" href="structast__hashtab__iter.html" title="an iterator for traversing the buckets">ast_hashtab_iter</a>
<a name="l00103"></a>00103 {
<a name="l00104"></a><a class="code" href="structast__hashtab__iter.html#a544ff1295545c4490180d179a5482f20">00104</a>    <span class="keyword">struct </span><a class="code" href="structast__hashtab.html">ast_hashtab</a> *<a class="code" href="structast__hashtab__iter.html#a544ff1295545c4490180d179a5482f20">tab</a>;
<a name="l00105"></a><a class="code" href="structast__hashtab__iter.html#a277291f5bb0f819abb0f739591ccd961">00105</a>    <span class="keyword">struct </span><a class="code" href="structast__hashtab__bucket.html">ast_hashtab_bucket</a> *<a class="code" href="structast__hashtab__iter.html#a277291f5bb0f819abb0f739591ccd961">next</a>;
<a name="l00106"></a>00106 };
<a name="l00107"></a>00107 
<a name="l00108"></a>00108 
<a name="l00109"></a>00109 <span class="comment">/* some standard, default routines for general use */</span>
<a name="l00110"></a>00110 <span class="comment"></span>
<a name="l00111"></a>00111 <span class="comment">/*!</span>
<a name="l00112"></a>00112 <span class="comment"> * \brief Determines if the specified number is prime.</span>
<a name="l00113"></a>00113 <span class="comment"> *</span>
<a name="l00114"></a>00114 <span class="comment"> * \param num the number to test</span>
<a name="l00115"></a>00115 <span class="comment"> * \retval 0 if the number is not prime</span>
<a name="l00116"></a>00116 <span class="comment"> * \retval 1 if the number is prime</span>
<a name="l00117"></a>00117 <span class="comment"> */</span>
<a name="l00118"></a>00118 <span class="keywordtype">int</span> <a class="code" href="hashtab_8h.html#a76a1018cc569eb65a6b29fab0a8481c1" title="Determines if the specified number is prime.">ast_is_prime</a>(<span class="keywordtype">int</span> <a class="code" href="adsistub_8c.html#af6fc584548091f45267cfaf7066119bd">num</a>);
<a name="l00119"></a>00119 <span class="comment"></span>
<a name="l00120"></a>00120 <span class="comment">/*!</span>
<a name="l00121"></a>00121 <span class="comment"> * \brief Compares two strings for equality.</span>
<a name="l00122"></a>00122 <span class="comment"> *</span>
<a name="l00123"></a>00123 <span class="comment"> * \param a a character string</span>
<a name="l00124"></a>00124 <span class="comment"> * \param b a character string</span>
<a name="l00125"></a>00125 <span class="comment"> * \retval 0 if the strings match</span>
<a name="l00126"></a>00126 <span class="comment"> * \retval &lt;0 if string a is less than string b</span>
<a name="l00127"></a>00127 <span class="comment"> * \retval &gt;0 if string a is greather than string b</span>
<a name="l00128"></a>00128 <span class="comment"> */</span>
<a name="l00129"></a>00129 <span class="keywordtype">int</span> <a class="code" href="hashtab_8h.html#a86ab6cf47bb9ae77f1c2db2b515c1628" title="Compares two strings for equality.">ast_hashtab_compare_strings</a>(<span class="keyword">const</span> <span class="keywordtype">void</span> *a, <span class="keyword">const</span> <span class="keywordtype">void</span> *b);
<a name="l00130"></a>00130 <span class="comment"></span>
<a name="l00131"></a>00131 <span class="comment">/*!</span>
<a name="l00132"></a>00132 <span class="comment"> * \brief Compares two strings for equality, ignoring case.</span>
<a name="l00133"></a>00133 <span class="comment"> *</span>
<a name="l00134"></a>00134 <span class="comment"> * \param a a character string</span>
<a name="l00135"></a>00135 <span class="comment"> * \param b a character string</span>
<a name="l00136"></a>00136 <span class="comment"> * \retval 0 if the strings match</span>
<a name="l00137"></a>00137 <span class="comment"> * \retval &lt;0 if string a is less than string b</span>
<a name="l00138"></a>00138 <span class="comment"> * \retval &gt;0 if string a is greather than string b</span>
<a name="l00139"></a>00139 <span class="comment"> */</span>
<a name="l00140"></a>00140 <span class="keywordtype">int</span> <a class="code" href="hashtab_8h.html#a944f4df390d07aead023abdcf4b7fc2e" title="Compares two strings for equality, ignoring case.">ast_hashtab_compare_strings_nocase</a>(<span class="keyword">const</span> <span class="keywordtype">void</span> *a, <span class="keyword">const</span> <span class="keywordtype">void</span> *b);
<a name="l00141"></a>00141 <span class="comment"></span>
<a name="l00142"></a>00142 <span class="comment">/*!</span>
<a name="l00143"></a>00143 <span class="comment"> * \brief Compares two integers for equality.</span>
<a name="l00144"></a>00144 <span class="comment"> *</span>
<a name="l00145"></a>00145 <span class="comment"> * \param a an integer pointer (int *)</span>
<a name="l00146"></a>00146 <span class="comment"> * \param b an integer pointer (int *)</span>
<a name="l00147"></a>00147 <span class="comment"> * \retval 0 if the integers pointed to are equal</span>
<a name="l00148"></a>00148 <span class="comment"> * \retval 1 if a is greater than b</span>
<a name="l00149"></a>00149 <span class="comment"> * \retval -1 if a is less than b</span>
<a name="l00150"></a>00150 <span class="comment"> */</span>
<a name="l00151"></a>00151 <span class="keywordtype">int</span> <a class="code" href="hashtab_8h.html#a5d02fdad6e9d1d15946a028a52851f2b" title="Compares two integers for equality.">ast_hashtab_compare_ints</a>(<span class="keyword">const</span> <span class="keywordtype">void</span> *a, <span class="keyword">const</span> <span class="keywordtype">void</span> *b);
<a name="l00152"></a>00152 <span class="comment"></span>
<a name="l00153"></a>00153 <span class="comment">/*!</span>
<a name="l00154"></a>00154 <span class="comment"> * \brief Compares two shorts for equality.</span>
<a name="l00155"></a>00155 <span class="comment"> *</span>
<a name="l00156"></a>00156 <span class="comment"> * \param a a short pointer (short *)</span>
<a name="l00157"></a>00157 <span class="comment"> * \param b a short pointer (short *)</span>
<a name="l00158"></a>00158 <span class="comment"> * \retval 0 if the shorts pointed to are equal</span>
<a name="l00159"></a>00159 <span class="comment"> * \retval 1 if a is greater than b</span>
<a name="l00160"></a>00160 <span class="comment"> * \retval -1 if a is less than b</span>
<a name="l00161"></a>00161 <span class="comment"> */</span>
<a name="l00162"></a>00162 <span class="keywordtype">int</span> <a class="code" href="hashtab_8h.html#ae179496ae1f9bbfd5608faa4a8d53310" title="Compares two shorts for equality.">ast_hashtab_compare_shorts</a>(<span class="keyword">const</span> <span class="keywordtype">void</span> *a, <span class="keyword">const</span> <span class="keywordtype">void</span> *b);
<a name="l00163"></a>00163 <span class="comment"></span>
<a name="l00164"></a>00164 <span class="comment">/*!</span>
<a name="l00165"></a>00165 <span class="comment"> * \brief Determines if a table resize should occur using the Java algorithm</span>
<a name="l00166"></a>00166 <span class="comment"> *        (if the table load factor is 75% or higher).</span>
<a name="l00167"></a>00167 <span class="comment"> *</span>
<a name="l00168"></a>00168 <span class="comment"> * \param tab the hash table to operate on</span>
<a name="l00169"></a>00169 <span class="comment"> * \retval 0 if the table load factor is less than or equal to 75%</span>
<a name="l00170"></a>00170 <span class="comment"> * \retval 1 if the table load factor is greater than 75%</span>
<a name="l00171"></a>00171 <span class="comment"> */</span>
<a name="l00172"></a>00172 <span class="keywordtype">int</span> <a class="code" href="hashtab_8h.html#aef63906caa0b965e9c8d8561600038e9" title="Determines if a table resize should occur using the Java algorithm (if the table...">ast_hashtab_resize_java</a>(<span class="keyword">struct</span> <a class="code" href="structast__hashtab.html">ast_hashtab</a> *tab);
<a name="l00173"></a>00173 <span class="comment"></span>
<a name="l00174"></a>00174 <span class="comment">/*! \brief Causes a resize whenever the number of elements stored in the table</span>
<a name="l00175"></a>00175 <span class="comment"> *         exceeds the number of buckets in the table.</span>
<a name="l00176"></a>00176 <span class="comment"> *</span>
<a name="l00177"></a>00177 <span class="comment"> * \param tab the hash table to operate on</span>
<a name="l00178"></a>00178 <span class="comment"> * \retval 0 if the number of elements in the table is less than or equal to</span>
<a name="l00179"></a>00179 <span class="comment"> *           the number of buckets</span>
<a name="l00180"></a>00180 <span class="comment"> * \retval 1 if the number of elements in the table exceeds the number of</span>
<a name="l00181"></a>00181 <span class="comment"> *           buckets</span>
<a name="l00182"></a>00182 <span class="comment"> */</span>
<a name="l00183"></a>00183 <span class="keywordtype">int</span> <a class="code" href="hashtab_8h.html#ad1c8c01df7f3a22daaf5b220dbd6eb5c" title="Causes a resize whenever the number of elements stored in the table exceeds the number...">ast_hashtab_resize_tight</a>(<span class="keyword">struct</span> <a class="code" href="structast__hashtab.html">ast_hashtab</a> *tab);
<a name="l00184"></a>00184 <span class="comment"></span>
<a name="l00185"></a>00185 <span class="comment">/*!</span>
<a name="l00186"></a>00186 <span class="comment"> * \brief Effectively disables resizing by always returning 0, regardless of</span>
<a name="l00187"></a>00187 <span class="comment"> *        of load factor.</span>
<a name="l00188"></a>00188 <span class="comment"> *</span>
<a name="l00189"></a>00189 <span class="comment"> * \param tab the hash table to operate on</span>
<a name="l00190"></a>00190 <span class="comment"> * \return 0 is always returned</span>
<a name="l00191"></a>00191 <span class="comment"> */</span>
<a name="l00192"></a>00192 <span class="keywordtype">int</span> <a class="code" href="hashtab_8h.html#af9b890f1277ab38f3b14b4fab1e311d3" title="Effectively disables resizing by always returning 0, regardless of of load factor...">ast_hashtab_resize_none</a>(<span class="keyword">struct</span> <a class="code" href="structast__hashtab.html">ast_hashtab</a> *tab);
<a name="l00193"></a>00193 <span class="comment"></span>
<a name="l00194"></a>00194 <span class="comment">/*! \brief Create a prime number roughly 2x the current table size */</span>
<a name="l00195"></a>00195 <span class="keywordtype">int</span> <a class="code" href="hashtab_8h.html#a743bfd52a8c9eb5d939ff5944758d846" title="Create a prime number roughly 2x the current table size.">ast_hashtab_newsize_java</a>(<span class="keyword">struct</span> <a class="code" href="structast__hashtab.html">ast_hashtab</a> *tab);
<a name="l00196"></a>00196 
<a name="l00197"></a>00197 <span class="comment">/* not yet specified, probably will return 1.5x the current table size */</span>
<a name="l00198"></a>00198 <span class="keywordtype">int</span> <a class="code" href="hashtab_8h.html#ac7c44d4b109e42af1ad35c72979af131">ast_hashtab_newsize_tight</a>(<span class="keyword">struct</span> <a class="code" href="structast__hashtab.html">ast_hashtab</a> *tab);
<a name="l00199"></a>00199 <span class="comment"></span>
<a name="l00200"></a>00200 <span class="comment">/*! \brief always return current size -- no resizing */</span>
<a name="l00201"></a>00201 <span class="keywordtype">int</span> <a class="code" href="hashtab_8h.html#a9c96afbac0ae8e85362cf5d64f05d350" title="always return current size -- no resizing">ast_hashtab_newsize_none</a>(<span class="keyword">struct</span> <a class="code" href="structast__hashtab.html">ast_hashtab</a> *tab);
<a name="l00202"></a>00202 <span class="comment"></span>
<a name="l00203"></a>00203 <span class="comment">/*!</span>
<a name="l00204"></a>00204 <span class="comment"> * \brief Hashes a string to a number</span>
<a name="l00205"></a>00205 <span class="comment"> *</span>
<a name="l00206"></a>00206 <span class="comment"> * \param obj the string to hash</span>
<a name="l00207"></a>00207 <span class="comment"> * \return Integer hash of the specified string</span>
<a name="l00208"></a>00208 <span class="comment"> * \sa ast_hashtable_hash_string_nocase</span>
<a name="l00209"></a>00209 <span class="comment"> * \sa ast_hashtab_hash_string_sax</span>
<a name="l00210"></a>00210 <span class="comment"> * \note A modulus will be applied to the return value of this function</span>
<a name="l00211"></a>00211 <span class="comment"> */</span>
<a name="l00212"></a>00212 <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="hashtab_8h.html#af8904cce564fd39de28b566bb8c261eb" title="Hashes a string to a number.">ast_hashtab_hash_string</a>(<span class="keyword">const</span> <span class="keywordtype">void</span> *obj);
<a name="l00213"></a>00213 <span class="comment"></span>
<a name="l00214"></a>00214 <span class="comment">/*!</span>
<a name="l00215"></a>00215 <span class="comment"> * \brief Hashes a string to a number ignoring case</span>
<a name="l00216"></a>00216 <span class="comment"> *</span>
<a name="l00217"></a>00217 <span class="comment"> * \param obj the string to hash</span>
<a name="l00218"></a>00218 <span class="comment"> * \return Integer hash of the specified string</span>
<a name="l00219"></a>00219 <span class="comment"> * \sa ast_hashtable_hash_string</span>
<a name="l00220"></a>00220 <span class="comment"> * \sa ast_hashtab_hash_string_sax</span>
<a name="l00221"></a>00221 <span class="comment"> * \note A modulus will be applied to the return value of this function</span>
<a name="l00222"></a>00222 <span class="comment"> */</span>
<a name="l00223"></a>00223 <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="hashtab_8h.html#a09610a365395d3d7b1a8ce18fc6e5b2c" title="Hashes a string to a number ignoring case.">ast_hashtab_hash_string_nocase</a>(<span class="keyword">const</span> <span class="keywordtype">void</span> *obj);
<a name="l00224"></a>00224 <span class="comment"></span>
<a name="l00225"></a>00225 <span class="comment">/*!</span>
<a name="l00226"></a>00226 <span class="comment"> * \brief Hashes a string to a number using a modified Shift-And-XOR algorithm</span>
<a name="l00227"></a>00227 <span class="comment"> *</span>
<a name="l00228"></a>00228 <span class="comment"> * \param obj the string to hash</span>
<a name="l00229"></a>00229 <span class="comment"> * \return Integer has of the specified string</span>
<a name="l00230"></a>00230 <span class="comment"> * \sa ast_hastable_hash_string</span>
<a name="l00231"></a>00231 <span class="comment"> * \sa ast_hastable_hash_string_nocase</span>
<a name="l00232"></a>00232 <span class="comment"> */</span>
<a name="l00233"></a>00233 <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="hashtab_8h.html#ab39dc11651e79b5ac59e15a1be73e81f" title="Hashes a string to a number using a modified Shift-And-XOR algorithm.">ast_hashtab_hash_string_sax</a>(<span class="keyword">const</span> <span class="keywordtype">void</span> *obj);
<a name="l00234"></a>00234 
<a name="l00235"></a>00235 
<a name="l00236"></a>00236 <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="hashtab_8h.html#a42e7322ae7381ee379bfe15798ca75e2">ast_hashtab_hash_int</a>(<span class="keyword">const</span> <span class="keywordtype">int</span> <a class="code" href="adsistub_8c.html#af6fc584548091f45267cfaf7066119bd">num</a>);  <span class="comment">/* right now, both these funcs are just result = num%modulus; */</span>
<a name="l00237"></a>00237 
<a name="l00238"></a>00238 
<a name="l00239"></a>00239 <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="hashtab_8h.html#a56c7bc5c72240c44819ff88573054c18">ast_hashtab_hash_short</a>(<span class="keyword">const</span> <span class="keywordtype">short</span> <a class="code" href="adsistub_8c.html#af6fc584548091f45267cfaf7066119bd">num</a>);
<a name="l00240"></a>00240 
<a name="l00241"></a>00241 <span class="comment"></span>
<a name="l00242"></a>00242 <span class="comment">/*!</span>
<a name="l00243"></a>00243 <span class="comment"> * \brief Create the hashtable list</span>
<a name="l00244"></a>00244 <span class="comment"> * \param initial_buckets starting number of buckets</span>
<a name="l00245"></a>00245 <span class="comment"> * \param compare a func ptr to compare two elements in the hash -- cannot be null</span>
<a name="l00246"></a>00246 <span class="comment"> * \param resize a func ptr to decide if the table needs to be resized, a NULL ptr here will cause a default to be used</span>
<a name="l00247"></a>00247 <span class="comment"> * \param newsize a func ptr that returns a new size of the array. A NULL will cause a default to be used</span>
<a name="l00248"></a>00248 <span class="comment"> * \param hash a func ptr to do the hashing</span>
<a name="l00249"></a>00249 <span class="comment"> * \param do_locking use locks to guarantee safety of iterators/insertion/deletion -- real simpleminded right now</span>
<a name="l00250"></a>00250 <span class="comment">*/</span>
<a name="l00251"></a>00251 <span class="preprocessor">#if (defined(MALLOC_DEBUG) &amp;&amp; !defined(STANDALONE))</span>
<a name="l00252"></a>00252 <span class="preprocessor"></span><span class="keyword">struct </span><a class="code" href="structast__hashtab.html">ast_hashtab</a> * _ast_hashtab_create(<span class="keywordtype">int</span> initial_buckets,
<a name="l00253"></a>00253                <span class="keywordtype">int</span> (*<a class="code" href="app__directory_8c.html#adf773af7f5d8ca288a3a68fc3659d95c">compare</a>)(<span class="keyword">const</span> <span class="keywordtype">void</span> *a, <span class="keyword">const</span> <span class="keywordtype">void</span> *b),
<a name="l00254"></a>00254                <span class="keywordtype">int</span> (*<a class="code" href="structast__hashtab.html#a54c408904d1a28302f6cf7051b1dc9e2">resize</a>)(<span class="keyword">struct</span> <a class="code" href="structast__hashtab.html">ast_hashtab</a> *),
<a name="l00255"></a>00255                <span class="keywordtype">int</span> (*<a class="code" href="structast__hashtab.html#aa50f8d4f1283e0b777dd85f17423fae1">newsize</a>)(<span class="keyword">struct</span> <a class="code" href="structast__hashtab.html">ast_hashtab</a> *tab),
<a name="l00256"></a>00256                <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> (*<a class="code" href="structast__hashtab.html#a391f7b59a3476dc3bf1ffa1b28852670">hash</a>)(<span class="keyword">const</span> <span class="keywordtype">void</span> *obj),
<a name="l00257"></a>00257                <span class="keywordtype">int</span> <a class="code" href="structast__hashtab.html#ac53417dd5a9c9583bdacc986bb861c60">do_locking</a>, <span class="keyword">const</span> <span class="keywordtype">char</span> *file, <span class="keywordtype">int</span> lineno, <span class="keyword">const</span> <span class="keywordtype">char</span> *function);
<a name="l00258"></a>00258 <span class="preprocessor">#define ast_hashtab_create(a,b,c,d,e,f)   _ast_hashtab_create(a,b,c,d,e,f,__FILE__,__LINE__,__PRETTY_FUNCTION__)</span>
<a name="l00259"></a>00259 <span class="preprocessor"></span><span class="preprocessor">#else</span>
<a name="l00260"></a>00260 <span class="preprocessor"></span><span class="keyword">struct </span><a class="code" href="structast__hashtab.html">ast_hashtab</a> * <a class="code" href="hashtab_8h.html#a85701d44df4ea1e746bde709a91a4192" title="Create the hashtable list.">ast_hashtab_create</a>(<span class="keywordtype">int</span> initial_buckets,
<a name="l00261"></a>00261                <span class="keywordtype">int</span> (*<a class="code" href="app__directory_8c.html#adf773af7f5d8ca288a3a68fc3659d95c">compare</a>)(<span class="keyword">const</span> <span class="keywordtype">void</span> *a, <span class="keyword">const</span> <span class="keywordtype">void</span> *b),
<a name="l00262"></a>00262                <span class="keywordtype">int</span> (*<a class="code" href="structast__hashtab.html#a54c408904d1a28302f6cf7051b1dc9e2">resize</a>)(<span class="keyword">struct</span> <a class="code" href="structast__hashtab.html">ast_hashtab</a> *),
<a name="l00263"></a>00263                <span class="keywordtype">int</span> (*<a class="code" href="structast__hashtab.html#aa50f8d4f1283e0b777dd85f17423fae1">newsize</a>)(<span class="keyword">struct</span> <a class="code" href="structast__hashtab.html">ast_hashtab</a> *tab),
<a name="l00264"></a>00264                <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> (*<a class="code" href="structast__hashtab.html#a391f7b59a3476dc3bf1ffa1b28852670">hash</a>)(<span class="keyword">const</span> <span class="keywordtype">void</span> *obj),
<a name="l00265"></a>00265                <span class="keywordtype">int</span> <a class="code" href="structast__hashtab.html#ac53417dd5a9c9583bdacc986bb861c60">do_locking</a> );
<a name="l00266"></a>00266 <span class="preprocessor">#endif</span>
<a name="l00267"></a>00267 <span class="preprocessor"></span><span class="comment"></span>
<a name="l00268"></a>00268 <span class="comment">/*!</span>
<a name="l00269"></a>00269 <span class="comment"> * \brief This func will free the hash table and all its memory.</span>
<a name="l00270"></a>00270 <span class="comment"> * \note It doesn&apos;t touch the objects stored in it, unless you</span>
<a name="l00271"></a>00271 <span class="comment"> *       specify a destroy func; it will call that func for each</span>
<a name="l00272"></a>00272 <span class="comment"> *       object in the hashtab, remove all the objects, and then</span>
<a name="l00273"></a>00273 <span class="comment"> *       free the hashtab itself. If no destroyfunc is specified</span>
<a name="l00274"></a>00274 <span class="comment"> *       then the routine will assume you will free it yourself.</span>
<a name="l00275"></a>00275 <span class="comment"> * \param tab</span>
<a name="l00276"></a>00276 <span class="comment"> * \param objdestroyfunc</span>
<a name="l00277"></a>00277 <span class="comment">*/</span>
<a name="l00278"></a>00278 <span class="keywordtype">void</span> <a class="code" href="hashtab_8h.html#a6103589badf8d9440a0cece2802c4c3a" title="This func will free the hash table and all its memory.">ast_hashtab_destroy</a>( <span class="keyword">struct</span> <a class="code" href="structast__hashtab.html">ast_hashtab</a> *tab, <span class="keywordtype">void</span> (*objdestroyfunc)(<span class="keywordtype">void</span> *obj));
<a name="l00279"></a>00279 
<a name="l00280"></a>00280 <span class="comment"></span>
<a name="l00281"></a>00281 <span class="comment">/*!</span>
<a name="l00282"></a>00282 <span class="comment"> * \brief Insert without checking</span>
<a name="l00283"></a>00283 <span class="comment"> * \param tab</span>
<a name="l00284"></a>00284 <span class="comment"> * \param obj</span>
<a name="l00285"></a>00285 <span class="comment"> *</span>
<a name="l00286"></a>00286 <span class="comment"> * Normally, you&apos;d insert &quot;safely&quot; by checking to see if the element is</span>
<a name="l00287"></a>00287 <span class="comment"> * already there; in this case, you must already have checked. If an element</span>
<a name="l00288"></a>00288 <span class="comment"> * is already in the hashtable, that matches this one, most likely this one</span>
<a name="l00289"></a>00289 <span class="comment"> * will be found first.</span>
<a name="l00290"></a>00290 <span class="comment"> * \note will force a resize if the resize func returns 1</span>
<a name="l00291"></a>00291 <span class="comment"> * \retval 1 on success</span>
<a name="l00292"></a>00292 <span class="comment"> * \retval 0 if there&apos;s a problem</span>
<a name="l00293"></a>00293 <span class="comment">*/</span>
<a name="l00294"></a>00294 <span class="preprocessor">#if (defined(MALLOC_DEBUG) &amp;&amp; !defined(STANDALONE))</span>
<a name="l00295"></a>00295 <span class="preprocessor"></span><span class="keywordtype">int</span> _ast_hashtab_insert_immediate(<span class="keyword">struct</span> <a class="code" href="structast__hashtab.html">ast_hashtab</a> *tab, <span class="keyword">const</span> <span class="keywordtype">void</span> *obj, <span class="keyword">const</span> <span class="keywordtype">char</span> *file, <span class="keywordtype">int</span> lineno, <span class="keyword">const</span> <span class="keywordtype">char</span> *func);
<a name="l00296"></a>00296 <span class="preprocessor">#define  ast_hashtab_insert_immediate(a,b)   _ast_hashtab_insert_immediate(a, b, __FILE__, __LINE__, __PRETTY_FUNCTION__)</span>
<a name="l00297"></a>00297 <span class="preprocessor"></span><span class="preprocessor">#else</span>
<a name="l00298"></a>00298 <span class="preprocessor"></span><span class="keywordtype">int</span> <a class="code" href="hashtab_8h.html#af3e13ed429193a2bf4f0b9d93ac5d7c1" title="Insert without checking.">ast_hashtab_insert_immediate</a>(<span class="keyword">struct</span> <a class="code" href="structast__hashtab.html">ast_hashtab</a> *tab, <span class="keyword">const</span> <span class="keywordtype">void</span> *obj);
<a name="l00299"></a>00299 <span class="preprocessor">#endif</span>
<a name="l00300"></a>00300 <span class="preprocessor"></span><span class="comment"></span>
<a name="l00301"></a>00301 <span class="comment">/*!</span>
<a name="l00302"></a>00302 <span class="comment"> * \brief Insert without checking, hashing or locking</span>
<a name="l00303"></a>00303 <span class="comment"> * \param tab</span>
<a name="l00304"></a>00304 <span class="comment"> * \param obj</span>
<a name="l00305"></a>00305 <span class="comment"> * \param h hashed index value</span>
<a name="l00306"></a>00306 <span class="comment"> *</span>
<a name="l00307"></a>00307 <span class="comment"> * \note Will force a resize if the resize func returns 1</span>
<a name="l00308"></a>00308 <span class="comment"> * \retval 1 on success</span>
<a name="l00309"></a>00309 <span class="comment"> * \retval 0 if there&apos;s a problem</span>
<a name="l00310"></a>00310 <span class="comment">*/</span>
<a name="l00311"></a>00311 <span class="preprocessor">#if (defined(MALLOC_DEBUG) &amp;&amp; !defined(STANDALONE))</span>
<a name="l00312"></a>00312 <span class="preprocessor"></span><span class="keywordtype">int</span> _ast_hashtab_insert_immediate_bucket(<span class="keyword">struct</span> <a class="code" href="structast__hashtab.html">ast_hashtab</a> *tab, <span class="keyword">const</span> <span class="keywordtype">void</span> *obj, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> h, <span class="keyword">const</span> <span class="keywordtype">char</span> *file, <span class="keywordtype">int</span> lineno, <span class="keyword">const</span> <span class="keywordtype">char</span> *func);
<a name="l00313"></a>00313 <span class="preprocessor">#define  ast_hashtab_insert_immediate_bucket(a,b,c)   _ast_hashtab_insert_immediate_bucket(a, b, c, __FILE__, __LINE__, __PRETTY_FUNCTION__)</span>
<a name="l00314"></a>00314 <span class="preprocessor"></span><span class="preprocessor">#else</span>
<a name="l00315"></a>00315 <span class="preprocessor"></span><span class="keywordtype">int</span> <a class="code" href="hashtab_8h.html#a1faf757f0e58decf2bbb2a924f7e5510" title="Insert without checking, hashing or locking.">ast_hashtab_insert_immediate_bucket</a>(<span class="keyword">struct</span> <a class="code" href="structast__hashtab.html">ast_hashtab</a> *tab, <span class="keyword">const</span> <span class="keywordtype">void</span> *obj, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> h);
<a name="l00316"></a>00316 <span class="preprocessor">#endif</span>
<a name="l00317"></a>00317 <span class="preprocessor"></span><span class="comment"></span>
<a name="l00318"></a>00318 <span class="comment">/*!</span>
<a name="l00319"></a>00319 <span class="comment"> * \brief Check and insert new object only if it is not there.</span>
<a name="l00320"></a>00320 <span class="comment"> * \note Will force a resize if the resize func returns 1</span>
<a name="l00321"></a>00321 <span class="comment"> * \retval 1 on success</span>
<a name="l00322"></a>00322 <span class="comment"> * \retval  0 if there&apos;s a problem, or it&apos;s already there.</span>
<a name="l00323"></a>00323 <span class="comment">*/</span>
<a name="l00324"></a>00324 <span class="preprocessor">#if (defined(MALLOC_DEBUG) &amp;&amp; !defined(STANDALONE))</span>
<a name="l00325"></a>00325 <span class="preprocessor"></span><span class="keywordtype">int</span> _ast_hashtab_insert_safe(<span class="keyword">struct</span> <a class="code" href="structast__hashtab.html">ast_hashtab</a> *tab, <span class="keyword">const</span> <span class="keywordtype">void</span> *obj, <span class="keyword">const</span> <span class="keywordtype">char</span> *file, <span class="keywordtype">int</span> lineno, <span class="keyword">const</span> <span class="keywordtype">char</span> *func);
<a name="l00326"></a>00326 <span class="preprocessor">#define  ast_hashtab_insert_safe(a,b)  _ast_hashtab_insert_safe(a,b,__FILE__, __LINE__, __PRETTY_FUNCTION__)</span>
<a name="l00327"></a>00327 <span class="preprocessor"></span><span class="preprocessor">#else</span>
<a name="l00328"></a>00328 <span class="preprocessor"></span><span class="keywordtype">int</span> <a class="code" href="hashtab_8h.html#afc129daca552e4483e6990a1e37d7e51" title="Check and insert new object only if it is not there.">ast_hashtab_insert_safe</a>(<span class="keyword">struct</span> <a class="code" href="structast__hashtab.html">ast_hashtab</a> *tab, <span class="keyword">const</span> <span class="keywordtype">void</span> *obj);
<a name="l00329"></a>00329 <span class="preprocessor">#endif</span>
<a name="l00330"></a>00330 <span class="preprocessor"></span><span class="comment"></span>
<a name="l00331"></a>00331 <span class="comment">/*!</span>
<a name="l00332"></a>00332 <span class="comment"> * \brief Lookup this object in the hash table.</span>
<a name="l00333"></a>00333 <span class="comment"> * \param tab</span>
<a name="l00334"></a>00334 <span class="comment"> * \param obj</span>
<a name="l00335"></a>00335 <span class="comment"> * \retval a ptr if found</span>
<a name="l00336"></a>00336 <span class="comment"> * \retval NULL if not found</span>
<a name="l00337"></a>00337 <span class="comment">*/</span>
<a name="l00338"></a>00338 <span class="keywordtype">void</span> * <a class="code" href="hashtab_8h.html#a78b1f7bc201afd020f6270378173bb79" title="Lookup this object in the hash table.">ast_hashtab_lookup</a>(<span class="keyword">struct</span> <a class="code" href="structast__hashtab.html">ast_hashtab</a> *tab, <span class="keyword">const</span> <span class="keywordtype">void</span> *obj);
<a name="l00339"></a>00339 <span class="comment"></span>
<a name="l00340"></a>00340 <span class="comment">/*!</span>
<a name="l00341"></a>00341 <span class="comment"> * \brief  Use this if have the hash val for the object</span>
<a name="l00342"></a>00342 <span class="comment"> * \note This and avoid the recalc of the hash (the modulus (table_size) is not applied)</span>
<a name="l00343"></a>00343 <span class="comment">*/</span>
<a name="l00344"></a>00344 <span class="keywordtype">void</span> * <a class="code" href="hashtab_8h.html#ad55e8dcfd056731bcdf275dee3dbad20" title="Use this if have the hash val for the object.">ast_hashtab_lookup_with_hash</a>(<span class="keyword">struct</span> <a class="code" href="structast__hashtab.html">ast_hashtab</a> *tab, <span class="keyword">const</span> <span class="keywordtype">void</span> *obj, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> hashval);
<a name="l00345"></a>00345 <span class="comment"></span>
<a name="l00346"></a>00346 <span class="comment">/*!</span>
<a name="l00347"></a>00347 <span class="comment"> * \brief Similar to ast_hashtab_lookup but sets h to the key hash value if the lookup fails.</span>
<a name="l00348"></a>00348 <span class="comment"> * \note This has the modulus applied, and will not be useful for long term storage if the table is resizable.</span>
<a name="l00349"></a>00349 <span class="comment">*/</span>
<a name="l00350"></a>00350 <span class="keywordtype">void</span> * <a class="code" href="hashtab_8h.html#a3e6e0ac05049c19407ca7c6ed473b968" title="Similar to ast_hashtab_lookup but sets h to the key hash value if the lookup fails...">ast_hashtab_lookup_bucket</a>(<span class="keyword">struct</span> <a class="code" href="structast__hashtab.html">ast_hashtab</a> *tab, <span class="keyword">const</span> <span class="keywordtype">void</span> *obj, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> *h);
<a name="l00351"></a>00351 <span class="comment"></span>
<a name="l00352"></a>00352 <span class="comment">/*! \brief Returns key stats for the table */</span>
<a name="l00353"></a>00353 <span class="keywordtype">void</span> <a class="code" href="hashtab_8h.html#ae52333d2a29053dce852f8a2d35ca421" title="Returns key stats for the table.">ast_hashtab_get_stats</a>( <span class="keyword">struct</span> <a class="code" href="structast__hashtab.html">ast_hashtab</a> *tab, <span class="keywordtype">int</span> *biggest_bucket_size, <span class="keywordtype">int</span> *<a class="code" href="structast__hashtab.html#aca6c133e85271118b482d523974fca7e">resize_count</a>, <span class="keywordtype">int</span> *num_objects, <span class="keywordtype">int</span> *num_buckets);
<a name="l00354"></a>00354 <span class="comment"></span>
<a name="l00355"></a>00355 <span class="comment">/*! \brief Returns the number of elements stored in the hashtab */</span>
<a name="l00356"></a>00356 <span class="keywordtype">int</span> <a class="code" href="hashtab_8h.html#ac3452d3a8bca5b4f2611bb96b7a44f31" title="Returns the number of elements stored in the hashtab.">ast_hashtab_size</a>( <span class="keyword">struct</span> <a class="code" href="structast__hashtab.html">ast_hashtab</a> *tab);
<a name="l00357"></a>00357 <span class="comment"></span>
<a name="l00358"></a>00358 <span class="comment">/*! \brief Returns the size of the bucket array in the hashtab */</span>
<a name="l00359"></a>00359 <span class="keywordtype">int</span> <a class="code" href="hashtab_8h.html#af2042c599c685acc02d267e9a4c906af" title="Returns the size of the bucket array in the hashtab.">ast_hashtab_capacity</a>( <span class="keyword">struct</span> <a class="code" href="structast__hashtab.html">ast_hashtab</a> *tab);
<a name="l00360"></a>00360 <span class="comment"></span>
<a name="l00361"></a>00361 <span class="comment">/*! \brief Return a copy of the hash table */</span>
<a name="l00362"></a>00362 <span class="preprocessor">#if (defined(MALLOC_DEBUG) &amp;&amp; !defined(STANDALONE))</span>
<a name="l00363"></a>00363 <span class="preprocessor"></span><span class="keyword">struct </span><a class="code" href="structast__hashtab.html">ast_hashtab</a> *_ast_hashtab_dup(<span class="keyword">struct</span> <a class="code" href="structast__hashtab.html">ast_hashtab</a> *tab, <span class="keywordtype">void</span> *(*obj_dup_func)(<span class="keyword">const</span> <span class="keywordtype">void</span> *obj), <span class="keyword">const</span> <span class="keywordtype">char</span> *file, <span class="keywordtype">int</span> lineno, <span class="keyword">const</span> <span class="keywordtype">char</span> *func);
<a name="l00364"></a>00364 <span class="preprocessor">#define  ast_hashtab_dup(a,b) _ast_hashtab_dup(a,b,__FILE__,__LINE__,__PRETTY_FUNCTION__)</span>
<a name="l00365"></a>00365 <span class="preprocessor"></span><span class="preprocessor">#else</span>
<a name="l00366"></a>00366 <span class="preprocessor"></span><span class="keyword">struct </span><a class="code" href="structast__hashtab.html">ast_hashtab</a> *<a class="code" href="hashtab_8h.html#a6cfc835043e3be16682295960edddb49" title="Return a copy of the hash table.">ast_hashtab_dup</a>(<span class="keyword">struct</span> <a class="code" href="structast__hashtab.html">ast_hashtab</a> *tab, <span class="keywordtype">void</span> *(*obj_dup_func)(<span class="keyword">const</span> <span class="keywordtype">void</span> *obj));
<a name="l00367"></a>00367 <span class="preprocessor">#endif</span>
<a name="l00368"></a>00368 <span class="preprocessor"></span><span class="comment"></span>
<a name="l00369"></a>00369 <span class="comment">/*! \brief Gives an iterator to hastable */</span>
<a name="l00370"></a>00370 <span class="preprocessor">#if (defined(MALLOC_DEBUG) &amp;&amp; !defined(STANDALONE))</span>
<a name="l00371"></a>00371 <span class="preprocessor"></span><span class="keyword">struct </span><a class="code" href="structast__hashtab__iter.html" title="an iterator for traversing the buckets">ast_hashtab_iter</a> *_ast_hashtab_start_traversal(<span class="keyword">struct</span> <a class="code" href="structast__hashtab.html">ast_hashtab</a> *tab, <span class="keyword">const</span> <span class="keywordtype">char</span> *file, <span class="keywordtype">int</span> lineno, <span class="keyword">const</span> <span class="keywordtype">char</span> *func);
<a name="l00372"></a>00372 <span class="preprocessor">#define  ast_hashtab_start_traversal(a)   _ast_hashtab_start_traversal(a,__FILE__,__LINE__,__PRETTY_FUNCTION__)</span>
<a name="l00373"></a>00373 <span class="preprocessor"></span><span class="preprocessor">#else</span>
<a name="l00374"></a>00374 <span class="preprocessor"></span><span class="keyword">struct </span><a class="code" href="structast__hashtab__iter.html" title="an iterator for traversing the buckets">ast_hashtab_iter</a> *<a class="code" href="hashtab_8h.html#ac5a19bffadbbd4eb31f190e576f88512" title="Gives an iterator to hastable.">ast_hashtab_start_traversal</a>(<span class="keyword">struct</span> <a class="code" href="structast__hashtab.html">ast_hashtab</a> *tab);
<a name="l00375"></a>00375 <span class="preprocessor">#endif</span>
<a name="l00376"></a>00376 <span class="preprocessor"></span><span class="comment"></span>
<a name="l00377"></a>00377 <span class="comment">/*! \brief end the traversal, free the iterator, unlock if necc. */</span>
<a name="l00378"></a>00378 <span class="keywordtype">void</span> <a class="code" href="hashtab_8h.html#a9c804e9bfc8355c25197187f0c6d0265" title="end the traversal, free the iterator, unlock if necc.">ast_hashtab_end_traversal</a>(<span class="keyword">struct</span> <a class="code" href="structast__hashtab__iter.html" title="an iterator for traversing the buckets">ast_hashtab_iter</a> *it);
<a name="l00379"></a>00379 <span class="comment"></span>
<a name="l00380"></a>00380 <span class="comment">/*! \brief Gets the next object in the list, advances iter one step returns null on end of traversal */</span>
<a name="l00381"></a>00381 <span class="keywordtype">void</span> *<a class="code" href="hashtab_8h.html#a43983b6169e9a0f9af48cca5cf9d3197" title="Gets the next object in the list, advances iter one step returns null on end of traversal...">ast_hashtab_next</a>(<span class="keyword">struct</span> <a class="code" href="structast__hashtab__iter.html" title="an iterator for traversing the buckets">ast_hashtab_iter</a> *it);
<a name="l00382"></a>00382 <span class="comment"></span>
<a name="l00383"></a>00383 <span class="comment">/*! \brief Looks up the object, removes the corresponding bucket */</span>
<a name="l00384"></a>00384 <span class="keywordtype">void</span> *<a class="code" href="hashtab_8h.html#a313b62d20344c2c85461dd4ed893017c" title="Looks up the object, removes the corresponding bucket.">ast_hashtab_remove_object_via_lookup</a>(<span class="keyword">struct</span> <a class="code" href="structast__hashtab.html">ast_hashtab</a> *tab, <span class="keywordtype">void</span> *obj);
<a name="l00385"></a>00385 <span class="comment"></span>
<a name="l00386"></a>00386 <span class="comment">/*! \brief Hash the object and then compare ptrs in bucket list instead of</span>
<a name="l00387"></a>00387 <span class="comment">      calling the compare routine, will remove the bucket */</span>
<a name="l00388"></a>00388 <span class="keywordtype">void</span> *<a class="code" href="hashtab_8h.html#a71bd19ff2f6fad1cf5e01f9b8cad6f66" title="Hash the object and then compare ptrs in bucket list instead of calling the compare...">ast_hashtab_remove_this_object</a>(<span class="keyword">struct</span> <a class="code" href="structast__hashtab.html">ast_hashtab</a> *tab, <span class="keywordtype">void</span> *obj);
<a name="l00389"></a>00389 
<a name="l00390"></a>00390 <span class="comment">/* ------------------ */</span>
<a name="l00391"></a>00391 <span class="comment">/* for lock-enabled traversals with ability to remove an object during the traversal*/</span>
<a name="l00392"></a>00392 <span class="comment">/* ------------------ */</span>
<a name="l00393"></a>00393 <span class="comment"></span>
<a name="l00394"></a>00394 <span class="comment">/*! \brief Gives an iterator to hastable */</span>
<a name="l00395"></a>00395 <span class="preprocessor">#if (defined(MALLOC_DEBUG) &amp;&amp; !defined(STANDALONE))</span>
<a name="l00396"></a>00396 <span class="preprocessor"></span><span class="keyword">struct </span><a class="code" href="structast__hashtab__iter.html" title="an iterator for traversing the buckets">ast_hashtab_iter</a> *_ast_hashtab_start_write_traversal(<span class="keyword">struct</span> <a class="code" href="structast__hashtab.html">ast_hashtab</a> *tab, <span class="keyword">const</span> <span class="keywordtype">char</span> *file, <span class="keywordtype">int</span> lineno, <span class="keyword">const</span> <span class="keywordtype">char</span> *func);
<a name="l00397"></a>00397 <span class="preprocessor">#define  ast_hashtab_start_write_traversal(a)   _ast_hashtab_start_write_traversal(a,__FILE__,__LINE__,__PRETTY_FUNCTION__)</span>
<a name="l00398"></a>00398 <span class="preprocessor"></span><span class="preprocessor">#else</span>
<a name="l00399"></a>00399 <span class="preprocessor"></span><span class="keyword">struct </span><a class="code" href="structast__hashtab__iter.html" title="an iterator for traversing the buckets">ast_hashtab_iter</a> *<a class="code" href="hashtab_8h.html#a82f79ee2e22d2a5bba10f7730bc14a5c" title="Gives an iterator to hastable.">ast_hashtab_start_write_traversal</a>(<span class="keyword">struct</span> <a class="code" href="structast__hashtab.html">ast_hashtab</a> *tab);
<a name="l00400"></a>00400 <span class="preprocessor">#endif</span>
<a name="l00401"></a>00401 <span class="preprocessor"></span><span class="comment"></span>
<a name="l00402"></a>00402 <span class="comment">/*! \brief Looks up the object, removes the corresponding bucket */</span>
<a name="l00403"></a>00403 <span class="keywordtype">void</span> *<a class="code" href="hashtab_8h.html#ad7ee24c838111389b9781324364f8c00" title="Looks up the object, removes the corresponding bucket.">ast_hashtab_remove_object_via_lookup_nolock</a>(<span class="keyword">struct</span> <a class="code" href="structast__hashtab.html">ast_hashtab</a> *tab, <span class="keywordtype">void</span> *obj);
<a name="l00404"></a>00404 <span class="comment"></span>
<a name="l00405"></a>00405 <span class="comment">/*! \brief Hash the object and then compare ptrs in bucket list instead of</span>
<a name="l00406"></a>00406 <span class="comment">      calling the compare routine, will remove the bucket */</span>
<a name="l00407"></a>00407 <span class="keywordtype">void</span> *<a class="code" href="hashtab_8h.html#ae9ca6365402722ebda78f20c9245b1fe" title="Hash the object and then compare ptrs in bucket list instead of calling the compare...">ast_hashtab_remove_this_object_nolock</a>(<span class="keyword">struct</span> <a class="code" href="structast__hashtab.html">ast_hashtab</a> *tab, <span class="keywordtype">void</span> *obj);
<a name="l00408"></a>00408 
<a name="l00409"></a>00409 <span class="comment">/* ------------------ */</span>
<a name="l00410"></a>00410 <span class="comment">/* ------------------ */</span>
<a name="l00411"></a>00411 
<a name="l00412"></a>00412 <span class="comment">/* user-controlled hashtab locking. Create a hashtab without locking, then call the</span>
<a name="l00413"></a>00413 <span class="comment">   following locking routines yourself to lock the table between threads. */</span>
<a name="l00414"></a>00414 <span class="comment"></span>
<a name="l00415"></a>00415 <span class="comment">/*! \brief Call this after you create the table to init the lock */</span>
<a name="l00416"></a>00416 <span class="keywordtype">void</span> <a class="code" href="hashtab_8h.html#af8f5e362aad984cbed2a1ece67717869" title="Call this after you create the table to init the lock.">ast_hashtab_initlock</a>(<span class="keyword">struct</span> <a class="code" href="structast__hashtab.html">ast_hashtab</a> *tab);<span class="comment"></span>
<a name="l00417"></a>00417 <span class="comment">/*! \brief Request a write-lock on the table. */</span>
<a name="l00418"></a>00418 <span class="keywordtype">void</span> <a class="code" href="hashtab_8h.html#a2afda46f84d0aec79d91155b6981800a" title="Request a write-lock on the table.">ast_hashtab_wrlock</a>(<span class="keyword">struct</span> <a class="code" href="structast__hashtab.html">ast_hashtab</a> *tab);<span class="comment"></span>
<a name="l00419"></a>00419 <span class="comment">/*! \brief Request a read-lock on the table -- don&apos;t change anything! */</span>
<a name="l00420"></a>00420 <span class="keywordtype">void</span> <a class="code" href="hashtab_8h.html#a56846aff6af7e13e3cffc9d21594fb40" title="Request a read-lock on the table -- don&amp;#39;t change anything!">ast_hashtab_rdlock</a>(<span class="keyword">struct</span> <a class="code" href="structast__hashtab.html">ast_hashtab</a> *tab);<span class="comment"></span>
<a name="l00421"></a>00421 <span class="comment">/*! \brief release a read- or write- lock. */</span>
<a name="l00422"></a>00422 <span class="keywordtype">void</span> <a class="code" href="hashtab_8h.html#a0075220de774384c45e3cf3906d51110" title="release a read- or write- lock.">ast_hashtab_unlock</a>(<span class="keyword">struct</span> <a class="code" href="structast__hashtab.html">ast_hashtab</a> *tab);<span class="comment"></span>
<a name="l00423"></a>00423 <span class="comment">/*! \brief Call this before you destroy the table. */</span>
<a name="l00424"></a>00424 <span class="keywordtype">void</span> <a class="code" href="hashtab_8h.html#a2d63b8b43b3d64700f5e4224c9a707d3" title="Call this before you destroy the table.">ast_hashtab_destroylock</a>(<span class="keyword">struct</span> <a class="code" href="structast__hashtab.html">ast_hashtab</a> *tab);
<a name="l00425"></a>00425 
<a name="l00426"></a>00426 
<a name="l00427"></a>00427 <span class="preprocessor">#endif</span>
</pre></div></div>
<hr size="1"/><address style="text-align: right;"><small>Generated on Wed May 5 15:18:41 2010 for Asterisk - the Open Source PBX by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.1 </small></address>
</body>
</html>
