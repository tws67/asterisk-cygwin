<HTML>
    <HEAD>
      <TITLE>Asterisk.org: Developer Documentation (5 May 2010)</TITLE>
      <LINK HREF="doxygen.css" REL="stylesheet" TYPE="text/css">
    </HEAD>
    <BODY BGCOLOR="#FFFFFF">
<div><font size="2" align="right">Wed May 5 15:22:11 2010</font></div>

<h2>Asterisk developer's documentation</h2>
<hr/>
<!-- Generated by Doxygen 1.6.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
  <div class="navpath"><a class="el" href="dir_afe38fc0ccf2e9eefca5d5c6b03503d9.html">main</a>
  </div>
</div>
<div class="contents">
<h1>heap.c File Reference</h1>
<p>Max Heap data structure.  
<a href="#_details">More...</a></p>
<code>#include &quot;<a class="el" href="asterisk_8h_source.html">asterisk.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="heap_8h_source.html">asterisk/heap.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="utils_8h_source.html">asterisk/utils.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="cli_8h_source.html">asterisk/cli.h</a>&quot;</code><br/>

<p><a href="heap_8c_source.html">Go to the source code of this file.</a></p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Data Structures</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structast__heap.html">ast_heap</a></td></tr>
<tr><td colspan="2"><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="heap_8c.html#afb88fdb31b92d8132e3f37813250612d">_ast_heap_remove</a> (struct <a class="el" href="structast__heap.html">ast_heap</a> *h, unsigned int index)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structast__heap.html">ast_heap</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="heap_8c.html#a2b4b738c784e05941437ff369a399712">ast_heap_create</a> (unsigned int init_height, <a class="el" href="heap_8h.html#a49db3541f7b1c2a7c1c64bcdf1acf257">ast_heap_cmp_fn</a> cmp_fn, ssize_t index_offset)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a max heap.  <a href="#a2b4b738c784e05941437ff369a399712"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structast__heap.html">ast_heap</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="heap_8c.html#a66d0a4a9d9e08e704abc44c856407bb8">ast_heap_destroy</a> (struct <a class="el" href="structast__heap.html">ast_heap</a> *h)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Destroy a max heap.  <a href="#a66d0a4a9d9e08e704abc44c856407bb8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="heap_8c.html#aaa326b988236a0841d41cf2af8ec9b7e">ast_heap_peek</a> (struct <a class="el" href="structast__heap.html">ast_heap</a> *h, unsigned int index)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Peek at an element on a heap.  <a href="#aaa326b988236a0841d41cf2af8ec9b7e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="heap_8c.html#ad56625488a481df852f0b13d58b15a93">ast_heap_pop</a> (struct <a class="el" href="structast__heap.html">ast_heap</a> *h)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Pop the max element off of the heap.  <a href="#ad56625488a481df852f0b13d58b15a93"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="heap_8c.html#a02ac8fc4576c77b09515463858e1d064">ast_heap_push</a> (struct <a class="el" href="structast__heap.html">ast_heap</a> *h, void *elm)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Push an element on to a heap.  <a href="#a02ac8fc4576c77b09515463858e1d064"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="heap_8c.html#a760eb8f29164fd1531133d8dac69b719">ast_heap_rdlock</a> (struct <a class="el" href="structast__heap.html">ast_heap</a> *h)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Read-Lock a heap.  <a href="#a760eb8f29164fd1531133d8dac69b719"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="heap_8c.html#ac68d03b30bb0adc489ccd67a11873b59">ast_heap_remove</a> (struct <a class="el" href="structast__heap.html">ast_heap</a> *h, void *elm)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Remove a specific element from a heap.  <a href="#ac68d03b30bb0adc489ccd67a11873b59"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="heap_8c.html#abb3efaa08e2b1e9423bbbd5e3d9d2acc">ast_heap_size</a> (struct <a class="el" href="structast__heap.html">ast_heap</a> *h)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the current size of a heap.  <a href="#abb3efaa08e2b1e9423bbbd5e3d9d2acc"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="heap_8c.html#a708ec9a605944b90b0ca357ba5ec9f74">ast_heap_unlock</a> (struct <a class="el" href="structast__heap.html">ast_heap</a> *h)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Unlock a heap.  <a href="#a708ec9a605944b90b0ca357ba5ec9f74"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="heap_8c.html#a0d46015f282b349a9b3d0560b5bc07c3">ast_heap_verify</a> (struct <a class="el" href="structast__heap.html">ast_heap</a> *h)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Verify that a heap has been properly constructed.  <a href="#a0d46015f282b349a9b3d0560b5bc07c3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="heap_8c.html#a690f90705aed40a7de352f0071ed7a58">ast_heap_wrlock</a> (struct <a class="el" href="structast__heap.html">ast_heap</a> *h)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Write-Lock a heap.  <a href="#a690f90705aed40a7de352f0071ed7a58"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static ssize_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="heap_8c.html#a5590485773cb3d3213bedc1d39201c50">get_index</a> (struct <a class="el" href="structast__heap.html">ast_heap</a> *h, void *elm)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="heap_8c.html#ae6dbb807fa2a60ce480b99f910ef2a3c">grow_heap</a> (struct <a class="el" href="structast__heap.html">ast_heap</a> *h)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Add a row of additional storage for the heap.  <a href="#ae6dbb807fa2a60ce480b99f910ef2a3c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="heap_8c.html#a750aea78f06637acdd54368ac351d25d">heap_get</a> (struct <a class="el" href="structast__heap.html">ast_heap</a> *h, int i)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="heap_8c.html#a0909ef13c9def687699d49e82bb90337">heap_set</a> (struct <a class="el" href="structast__heap.html">ast_heap</a> *h, int i, void *elm)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="heap_8c.html#a3bee448218fe03b6b23a2c208940a6c3">heap_swap</a> (struct <a class="el" href="structast__heap.html">ast_heap</a> *h, int i, int j)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="heap_8c.html#a82847ffec208b4ed490b40e30b139fe6">left_node</a> (int i)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="heap_8c.html#a278188a6240552e1c40bd58ba9417902">max_heapify</a> (struct <a class="el" href="structast__heap.html">ast_heap</a> *h, int i)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="heap_8c.html#ae3a5f0397c1d0cf66427c8d5810ac280">parent_node</a> (int i)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="heap_8c.html#ac8e0bba7e2f40ea2771f593447eba705">right_node</a> (int i)</td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>Max Heap data structure. </p>
<dl class="author"><dt><b>Author:</b></dt><dd>Russell Bryant &lt;<a href="mailto:russell@digium.com">russell@digium.com</a>&gt; </dd></dl>

<p>Definition in file <a class="el" href="heap_8c_source.html">heap.c</a>.</p>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="afb88fdb31b92d8132e3f37813250612d"></a><!-- doxytag: member="heap.c::_ast_heap_remove" ref="afb88fdb31b92d8132e3f37813250612d" args="(struct ast_heap *h, unsigned int index)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void* _ast_heap_remove </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structast__heap.html">ast_heap</a> *&nbsp;</td>
          <td class="paramname"> <em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>index</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="heap_8c_source.html#l00259">259</a> of file <a class="el" href="heap_8c_source.html">heap.c</a>.</p>

<p>References <a class="el" href="heap_8c_source.html#l00038">ast_heap::cur_len</a>, <a class="el" href="heap_8c_source.html#l00058">heap_get()</a>, <a class="el" href="heap_8c_source.html#l00076">heap_set()</a>, and <a class="el" href="heap_8c_source.html#l00205">max_heapify()</a>.</p>

<p>Referenced by <a class="el" href="heap_8c_source.html#l00286">ast_heap_pop()</a>, and <a class="el" href="heap_8c_source.html#l00275">ast_heap_remove()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00260"></a>00260 {
<a name="l00261"></a>00261    <span class="keywordtype">void</span> *ret;
<a name="l00262"></a>00262 
<a name="l00263"></a>00263    <span class="keywordflow">if</span> (!index || index &gt; h-&gt;<a class="code" href="structast__heap.html#a80fdf040f74e47fedc72cda33b40f13b">cur_len</a>) {
<a name="l00264"></a>00264       <span class="keywordflow">return</span> NULL;
<a name="l00265"></a>00265    }
<a name="l00266"></a>00266 
<a name="l00267"></a>00267    ret = <a class="code" href="heap_8c.html#a750aea78f06637acdd54368ac351d25d">heap_get</a>(h, index);
<a name="l00268"></a>00268    <a class="code" href="heap_8c.html#a0909ef13c9def687699d49e82bb90337">heap_set</a>(h, index, <a class="code" href="heap_8c.html#a750aea78f06637acdd54368ac351d25d">heap_get</a>(h, (h-&gt;<a class="code" href="structast__heap.html#a80fdf040f74e47fedc72cda33b40f13b">cur_len</a>)--));
<a name="l00269"></a>00269 
<a name="l00270"></a>00270    <a class="code" href="heap_8c.html#a278188a6240552e1c40bd58ba9417902">max_heapify</a>(h, index);
<a name="l00271"></a>00271 
<a name="l00272"></a>00272    <span class="keywordflow">return</span> ret;
<a name="l00273"></a>00273 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a2b4b738c784e05941437ff369a399712"></a><!-- doxytag: member="heap.c::ast_heap_create" ref="a2b4b738c784e05941437ff369a399712" args="(unsigned int init_height, ast_heap_cmp_fn cmp_fn, ssize_t index_offset)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structast__heap.html">ast_heap</a>* ast_heap_create </td>
          <td>(</td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>init_height</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="heap_8h.html#a49db3541f7b1c2a7c1c64bcdf1acf257">ast_heap_cmp_fn</a>&nbsp;</td>
          <td class="paramname"> <em>cmp_fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ssize_t&nbsp;</td>
          <td class="paramname"> <em>index_offset</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [read]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create a max heap. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>init_height</em>&nbsp;</td><td>The initial height of the heap to allocate space for. To start out, there will be room for (2 ^ init_height) - 1 entries. However, the heap will grow as needed. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>cmp_fn</em>&nbsp;</td><td>The function that should be used to compare elements in the heap. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>index_offset</em>&nbsp;</td><td>This parameter is optional, but must be provided to be able to use <a class="el" href="heap_8h.html#ac68d03b30bb0adc489ccd67a11873b59" title="Remove a specific element from a heap.">ast_heap_remove()</a>. This is the <a class="el" href="structnumber.html" title="Number structure.">number</a> of bytes into the element where an ssize_t has been made available for the heap's internal use. The heap will use this field to keep track of the element's current position in the heap. The offsetof() macro is useful for providing a proper value for this argument. If <a class="el" href="heap_8h.html#ac68d03b30bb0adc489ccd67a11873b59" title="Remove a specific element from a heap.">ast_heap_remove()</a> will not be used, then a negative value can be provided to indicate that no field for an offset has been allocated.</td></tr>
  </table>
  </dd>
</dl>
<p>Example Usage:</p>
<div class="fragment"><pre class="fragment"> <span class="keyword">struct </span>myobj {
    <span class="keywordtype">int</span> foo;
    <span class="keywordtype">int</span> bar;
    <span class="keywordtype">char</span> stuff[8];
    <span class="keywordtype">char</span> things[8];
    ssize_t __heap_index;
 };

 ...

 <span class="keyword">static</span> <span class="keywordtype">int</span> myobj_cmp(<span class="keywordtype">void</span> *obj1, <span class="keywordtype">void</span> *obj2);

 ...

 <span class="keyword">struct </span><a class="code" href="structast__heap.html">ast_heap</a> *h;

 h = <a class="code" href="heap_8h.html#a2b4b738c784e05941437ff369a399712" title="Create a max heap.">ast_heap_create</a>(8, myobj_cmp, offsetof(<span class="keyword">struct</span> myobj, __heap_index));
</pre></div><dl class="return"><dt><b>Returns:</b></dt><dd>An instance of a max heap </dd></dl>
<dl class="since"><dt><b>Since:</b></dt><dd>1.6.1 </dd></dl>

<p>Definition at line <a class="el" href="heap_8c_source.html#l00114">114</a> of file <a class="el" href="heap_8c_source.html">heap.c</a>.</p>

<p>References <a class="el" href="astmm_8c_source.html#l00199">__ast_calloc()</a>, <a class="el" href="astmm_8h_source.html#l00072">ast_calloc</a>, <a class="el" href="astmm_8h_source.html#l00087">ast_free</a>, <a class="el" href="logger_8c_source.html#l01090">ast_log()</a>, <a class="el" href="lock_8h_source.html#l01770">ast_rwlock_init()</a>, <a class="el" href="heap_8c_source.html#l00039">ast_heap::avail_len</a>, <a class="el" href="heap_8c_source.html#l00036">ast_heap::cmp_fn</a>, <a class="el" href="heap_8c_source.html#l00040">ast_heap::heap</a>, <a class="el" href="heap_8c_source.html#l00037">ast_heap::index_offset</a>, <a class="el" href="heap_8c_source.html#l00035">ast_heap::lock</a>, and <a class="el" href="logger_8h_source.html#l00163">LOG_ERROR</a>.</p>

<p>Referenced by <a class="el" href="timing_8c_source.html#l00283">ast_timing_init()</a>, <a class="el" href="loader_8c_source.html#l00883">load_resource_list()</a>, and <a class="el" href="sched_8c_source.html#l00239">sched_context_create()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00117"></a>00117 {
<a name="l00118"></a>00118    <span class="keyword">struct </span><a class="code" href="structast__heap.html">ast_heap</a> *h;
<a name="l00119"></a>00119 
<a name="l00120"></a>00120    <span class="keywordflow">if</span> (!<a class="code" href="structast__heap.html#ad4e0020882fab5f0738eee8559ae138e">cmp_fn</a>) {
<a name="l00121"></a>00121       <a class="code" href="logger_8h.html#a93dd824dff97fe84941d6d71b7a3710e" title="Used for sending a log message This is the standard logger function. Probably the...">ast_log</a>(<a class="code" href="logger_8h.html#aced66975c154ea0e2a8ec3bc818b4e08">LOG_ERROR</a>, <span class="stringliteral">&quot;A comparison function must be provided\n&quot;</span>);
<a name="l00122"></a>00122       <span class="keywordflow">return</span> NULL;
<a name="l00123"></a>00123    }
<a name="l00124"></a>00124 
<a name="l00125"></a>00125    <span class="keywordflow">if</span> (!init_height) {
<a name="l00126"></a>00126       init_height = 8;
<a name="l00127"></a>00127    }
<a name="l00128"></a>00128 
<a name="l00129"></a>00129    <span class="keywordflow">if</span> (!(h =
<a name="l00130"></a>00130 #ifdef MALLOC_DEBUG
<a name="l00131"></a>00131          <a class="code" href="astmm_8h.html#ad800d5c993a0c605f6e061bdef1b524c">__ast_calloc</a>(1, <span class="keyword">sizeof</span>(*h), file, lineno, func)
<a name="l00132"></a>00132 #<span class="keywordflow">else</span>
<a name="l00133"></a>00133          <a class="code" href="astmm_8h.html#a1cb33b63d94fbbde94234b062249e015">ast_calloc</a>(1, <span class="keyword">sizeof</span>(*h))
<a name="l00134"></a>00134 #endif
<a name="l00135"></a>00135       )) {
<a name="l00136"></a>00136       <span class="keywordflow">return</span> NULL;
<a name="l00137"></a>00137    }
<a name="l00138"></a>00138 
<a name="l00139"></a>00139    h-&gt;<a class="code" href="structast__heap.html#ad4e0020882fab5f0738eee8559ae138e">cmp_fn</a> = <a class="code" href="structast__heap.html#ad4e0020882fab5f0738eee8559ae138e">cmp_fn</a>;
<a name="l00140"></a>00140    h-&gt;<a class="code" href="structast__heap.html#a343df1831d4c9543871a5bc4320a3d18">index_offset</a> = <a class="code" href="structast__heap.html#a343df1831d4c9543871a5bc4320a3d18">index_offset</a>;
<a name="l00141"></a>00141    h-&gt;<a class="code" href="structast__heap.html#ac426c291ec04f174c48a6065c0bbfb1f">avail_len</a> = (1 &lt;&lt; init_height) - 1;
<a name="l00142"></a>00142 
<a name="l00143"></a>00143    <span class="keywordflow">if</span> (!(h-&gt;<a class="code" href="structast__heap.html#a58a9e32eac038c7231ab379249122f64">heap</a> =
<a name="l00144"></a>00144 #ifdef MALLOC_DEBUG
<a name="l00145"></a>00145          <a class="code" href="astmm_8h.html#ad800d5c993a0c605f6e061bdef1b524c">__ast_calloc</a>(1, h-&gt;<a class="code" href="structast__heap.html#ac426c291ec04f174c48a6065c0bbfb1f">avail_len</a> * <span class="keyword">sizeof</span>(<span class="keywordtype">void</span> *), file, lineno, func)
<a name="l00146"></a>00146 #<span class="keywordflow">else</span>
<a name="l00147"></a>00147          <a class="code" href="astmm_8h.html#a1cb33b63d94fbbde94234b062249e015">ast_calloc</a>(1, h-&gt;<a class="code" href="structast__heap.html#ac426c291ec04f174c48a6065c0bbfb1f">avail_len</a> * <span class="keyword">sizeof</span>(<span class="keywordtype">void</span> *))
<a name="l00148"></a>00148 #endif
<a name="l00149"></a>00149       )) {
<a name="l00150"></a>00150       <a class="code" href="astmm_8h.html#a402072d6789f6ed9e3a81da27504127e">ast_free</a>(h);
<a name="l00151"></a>00151       <span class="keywordflow">return</span> NULL;
<a name="l00152"></a>00152    }
<a name="l00153"></a>00153 
<a name="l00154"></a>00154    <a class="code" href="lock_8h.html#aeae3552501126e03a4fa95f4acd0ee67">ast_rwlock_init</a>(&amp;h-&gt;<a class="code" href="structast__heap.html#ace4e0066a5b24f84b90536e9906619f6">lock</a>);
<a name="l00155"></a>00155 
<a name="l00156"></a>00156    <span class="keywordflow">return</span> h;
<a name="l00157"></a>00157 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a66d0a4a9d9e08e704abc44c856407bb8"></a><!-- doxytag: member="heap.c::ast_heap_destroy" ref="a66d0a4a9d9e08e704abc44c856407bb8" args="(struct ast_heap *h)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structast__heap.html">ast_heap</a>* ast_heap_destroy </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structast__heap.html">ast_heap</a> *&nbsp;</td>
          <td class="paramname"> <em>h</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [read]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Destroy a max heap. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>h</em>&nbsp;</td><td>the heap to destroy</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>NULL for convenience </dd></dl>
<dl class="since"><dt><b>Since:</b></dt><dd>1.6.1 </dd></dl>

<p>Definition at line <a class="el" href="heap_8c_source.html#l00159">159</a> of file <a class="el" href="heap_8c_source.html">heap.c</a>.</p>

<p>References <a class="el" href="astmm_8h_source.html#l00087">ast_free</a>, <a class="el" href="lock_8h_source.html#l01786">ast_rwlock_destroy()</a>, <a class="el" href="heap_8c_source.html#l00040">ast_heap::heap</a>, and <a class="el" href="heap_8c_source.html#l00035">ast_heap::lock</a>.</p>

<p>Referenced by <a class="el" href="loader_8c_source.html#l00883">load_resource_list()</a>, and <a class="el" href="sched_8c_source.html#l00260">sched_context_destroy()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00160"></a>00160 {
<a name="l00161"></a>00161    <a class="code" href="astmm_8h.html#a402072d6789f6ed9e3a81da27504127e">ast_free</a>(h-&gt;<a class="code" href="structast__heap.html#a58a9e32eac038c7231ab379249122f64">heap</a>);
<a name="l00162"></a>00162    h-&gt;<a class="code" href="structast__heap.html#a58a9e32eac038c7231ab379249122f64">heap</a> = NULL;
<a name="l00163"></a>00163 
<a name="l00164"></a>00164    <a class="code" href="lock_8h.html#aa1e308479619b6e2a20c7b27479cafa9">ast_rwlock_destroy</a>(&amp;h-&gt;<a class="code" href="structast__heap.html#ace4e0066a5b24f84b90536e9906619f6">lock</a>);
<a name="l00165"></a>00165 
<a name="l00166"></a>00166    <a class="code" href="astmm_8h.html#a402072d6789f6ed9e3a81da27504127e">ast_free</a>(h);
<a name="l00167"></a>00167 
<a name="l00168"></a>00168    <span class="keywordflow">return</span> NULL;
<a name="l00169"></a>00169 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="aaa326b988236a0841d41cf2af8ec9b7e"></a><!-- doxytag: member="heap.c::ast_heap_peek" ref="aaa326b988236a0841d41cf2af8ec9b7e" args="(struct ast_heap *h, unsigned int index)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* ast_heap_peek </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structast__heap.html">ast_heap</a> *&nbsp;</td>
          <td class="paramname"> <em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>index</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Peek at an element on a heap. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>h</em>&nbsp;</td><td>the heap </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>index</em>&nbsp;</td><td>index of the element to return. The first element is at index 1, and the last element is at the index == the size of the heap.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>an element at the specified index on the heap. This element will <b>not</b> be removed before being returned.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>If this function is being used in combination with <a class="el" href="heap_8h.html#abb3efaa08e2b1e9423bbbd5e3d9d2acc" title="Get the current size of a heap.">ast_heap_size()</a> for purposes of traversing the heap, the heap must be locked for the entire duration of the traversal.</dd></dl>
<p>Example code for a traversal: </p>
<div class="fragment"><pre class="fragment"> <span class="keyword">struct </span><a class="code" href="structast__heap.html">ast_heap</a> *h;

 ...

 <span class="keywordtype">size_t</span> size, i;
 <span class="keywordtype">void</span> *cur_obj;

 <a class="code" href="heap_8h.html#a760eb8f29164fd1531133d8dac69b719" title="Read-Lock a heap.">ast_heap_rdlock</a>(h);

 size = <a class="code" href="heap_8h.html#abb3efaa08e2b1e9423bbbd5e3d9d2acc" title="Get the current size of a heap.">ast_heap_size</a>(h);

 <span class="keywordflow">for</span> (i = 1; i &lt;= size &amp;&amp; (cur_obj = <a class="code" href="heap_8h.html#aaa326b988236a0841d41cf2af8ec9b7e" title="Peek at an element on a heap.">ast_heap_peek</a>(h, i)); i++) {
     ... Do stuff with cur_obj ...
 }

 <a class="code" href="heap_8h.html#a708ec9a605944b90b0ca357ba5ec9f74" title="Unlock a heap.">ast_heap_unlock</a>(h);
</pre></div> <dl class="since"><dt><b>Since:</b></dt><dd>1.6.1 </dd></dl>

<p>Definition at line <a class="el" href="heap_8c_source.html#l00291">291</a> of file <a class="el" href="heap_8c_source.html">heap.c</a>.</p>

<p>References <a class="el" href="heap_8c_source.html#l00038">ast_heap::cur_len</a>, and <a class="el" href="heap_8c_source.html#l00058">heap_get()</a>.</p>

<p>Referenced by <a class="el" href="sched_8c_source.html#l00546">ast_sched_dump()</a>, <a class="el" href="sched_8c_source.html#l00508">ast_sched_report()</a>, <a class="el" href="sched_8c_source.html#l00581">ast_sched_runq()</a>, <a class="el" href="sched_8c_source.html#l00327">ast_sched_wait()</a>, and <a class="el" href="timing_8c_source.html#l00119">ast_timer_open()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00292"></a>00292 {
<a name="l00293"></a>00293    <span class="keywordflow">if</span> (!h-&gt;<a class="code" href="structast__heap.html#a80fdf040f74e47fedc72cda33b40f13b">cur_len</a> || !index || index &gt; h-&gt;<a class="code" href="structast__heap.html#a80fdf040f74e47fedc72cda33b40f13b">cur_len</a>) {
<a name="l00294"></a>00294       <span class="keywordflow">return</span> NULL;
<a name="l00295"></a>00295    }
<a name="l00296"></a>00296 
<a name="l00297"></a>00297    <span class="keywordflow">return</span> <a class="code" href="heap_8c.html#a750aea78f06637acdd54368ac351d25d">heap_get</a>(h, index);
<a name="l00298"></a>00298 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="ad56625488a481df852f0b13d58b15a93"></a><!-- doxytag: member="heap.c::ast_heap_pop" ref="ad56625488a481df852f0b13d58b15a93" args="(struct ast_heap *h)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* ast_heap_pop </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structast__heap.html">ast_heap</a> *&nbsp;</td>
          <td class="paramname"> <em>h</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Pop the max element off of the heap. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>h</em>&nbsp;</td><td>the heap</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>this will return the element on the top of the heap, which has the largest value according to the element comparison function that was provided when the heap was created. The element will be removed before being returned. </dd></dl>
<dl class="since"><dt><b>Since:</b></dt><dd>1.6.1 </dd></dl>

<p>Definition at line <a class="el" href="heap_8c_source.html#l00286">286</a> of file <a class="el" href="heap_8c_source.html">heap.c</a>.</p>

<p>References <a class="el" href="heap_8c_source.html#l00259">_ast_heap_remove()</a>.</p>

<p>Referenced by <a class="el" href="sched_8c_source.html#l00581">ast_sched_runq()</a>, <a class="el" href="loader_8c_source.html#l00883">load_resource_list()</a>, and <a class="el" href="sched_8c_source.html#l00260">sched_context_destroy()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00287"></a>00287 {
<a name="l00288"></a>00288    <span class="keywordflow">return</span> <a class="code" href="heap_8c.html#afb88fdb31b92d8132e3f37813250612d">_ast_heap_remove</a>(h, 1);
<a name="l00289"></a>00289 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a02ac8fc4576c77b09515463858e1d064"></a><!-- doxytag: member="heap.c::ast_heap_push" ref="a02ac8fc4576c77b09515463858e1d064" args="(struct ast_heap *h, void *elm)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ast_heap_push </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structast__heap.html">ast_heap</a> *&nbsp;</td>
          <td class="paramname"> <em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>elm</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Push an element on to a heap. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>h</em>&nbsp;</td><td>the heap being added to </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>elm</em>&nbsp;</td><td>the element being put on the heap</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>0</em>&nbsp;</td><td>success </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>non-zero</em>&nbsp;</td><td>failure </td></tr>
  </table>
  </dd>
</dl>
<dl class="since"><dt><b>Since:</b></dt><dd>1.6.1 </dd></dl>

<p>Definition at line <a class="el" href="heap_8c_source.html#l00235">235</a> of file <a class="el" href="heap_8c_source.html">heap.c</a>.</p>

<p>References <a class="el" href="heap_8c_source.html#l00039">ast_heap::avail_len</a>, <a class="el" href="heap_8c_source.html#l00036">ast_heap::cmp_fn</a>, <a class="el" href="heap_8c_source.html#l00038">ast_heap::cur_len</a>, <a class="el" href="heap_8c_source.html#l00174">grow_heap()</a>, <a class="el" href="heap_8c_source.html#l00058">heap_get()</a>, <a class="el" href="heap_8c_source.html#l00076">heap_set()</a>, <a class="el" href="heap_8c_source.html#l00196">heap_swap()</a>, and <a class="el" href="heap_8c_source.html#l00053">parent_node()</a>.</p>

<p>Referenced by <a class="el" href="timing_8c_source.html#l00071">_ast_register_timing_interface()</a>, <a class="el" href="loader_8c_source.html#l00777">load_resource()</a>, and <a class="el" href="sched_8c_source.html#l00354">schedule()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00237"></a>00237 {
<a name="l00238"></a>00238    <span class="keywordtype">int</span> i;
<a name="l00239"></a>00239 
<a name="l00240"></a>00240    <span class="keywordflow">if</span> (h-&gt;<a class="code" href="structast__heap.html#a80fdf040f74e47fedc72cda33b40f13b">cur_len</a> == h-&gt;<a class="code" href="structast__heap.html#ac426c291ec04f174c48a6065c0bbfb1f">avail_len</a> &amp;&amp; <a class="code" href="heap_8c.html#ae6dbb807fa2a60ce480b99f910ef2a3c" title="Add a row of additional storage for the heap.">grow_heap</a>(h
<a name="l00241"></a>00241 #ifdef MALLOC_DEBUG
<a name="l00242"></a>00242       , file, lineno, func
<a name="l00243"></a>00243 #endif
<a name="l00244"></a>00244       )) {
<a name="l00245"></a>00245       <span class="keywordflow">return</span> -1;
<a name="l00246"></a>00246    }
<a name="l00247"></a>00247 
<a name="l00248"></a>00248    <a class="code" href="heap_8c.html#a0909ef13c9def687699d49e82bb90337">heap_set</a>(h, ++(h-&gt;<a class="code" href="structast__heap.html#a80fdf040f74e47fedc72cda33b40f13b">cur_len</a>), elm);
<a name="l00249"></a>00249 
<a name="l00250"></a>00250    <span class="keywordflow">for</span> (i = h-&gt;<a class="code" href="structast__heap.html#a80fdf040f74e47fedc72cda33b40f13b">cur_len</a>;
<a name="l00251"></a>00251          i &gt; 1 &amp;&amp; h-&gt;<a class="code" href="structast__heap.html#ad4e0020882fab5f0738eee8559ae138e">cmp_fn</a>(<a class="code" href="heap_8c.html#a750aea78f06637acdd54368ac351d25d">heap_get</a>(h, <a class="code" href="heap_8c.html#ae3a5f0397c1d0cf66427c8d5810ac280">parent_node</a>(i)), <a class="code" href="heap_8c.html#a750aea78f06637acdd54368ac351d25d">heap_get</a>(h, i)) &lt; 0;
<a name="l00252"></a>00252          i = <a class="code" href="heap_8c.html#ae3a5f0397c1d0cf66427c8d5810ac280">parent_node</a>(i)) {
<a name="l00253"></a>00253       <a class="code" href="heap_8c.html#a3bee448218fe03b6b23a2c208940a6c3">heap_swap</a>(h, i, <a class="code" href="heap_8c.html#ae3a5f0397c1d0cf66427c8d5810ac280">parent_node</a>(i));
<a name="l00254"></a>00254    }
<a name="l00255"></a>00255 
<a name="l00256"></a>00256    <span class="keywordflow">return</span> 0;
<a name="l00257"></a>00257 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a760eb8f29164fd1531133d8dac69b719"></a><!-- doxytag: member="heap.c::ast_heap_rdlock" ref="a760eb8f29164fd1531133d8dac69b719" args="(struct ast_heap *h)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ast_heap_rdlock </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structast__heap.html">ast_heap</a> *&nbsp;</td>
          <td class="paramname"> <em>h</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Read-Lock a heap. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>h</em>&nbsp;</td><td>the heap</td></tr>
  </table>
  </dd>
</dl>
<p>A lock is provided for convenience. It can be assumed that none of the <a class="el" href="structast__heap.html">ast_heap</a> API calls are thread safe. This lock does not have to be used if another one is already available to protect the heap.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>see the documentation for pthread_rwlock_rdlock() </dd></dl>
<dl class="since"><dt><b>Since:</b></dt><dd>1.6.1 </dd></dl>

<p>Definition at line <a class="el" href="heap_8c_source.html#l00312">312</a> of file <a class="el" href="heap_8c_source.html">heap.c</a>.</p>

<p>References <a class="el" href="lock_8h_source.html#l01796">ast_rwlock_rdlock()</a>, and <a class="el" href="heap_8c_source.html#l00035">ast_heap::lock</a>.</p>

<p>Referenced by <a class="el" href="timing_8c_source.html#l00119">ast_timer_open()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00313"></a>00313 {
<a name="l00314"></a>00314    <span class="keywordflow">return</span> <a class="code" href="lock_8h.html#ae6703edce409c34119e27bdca1186d10">ast_rwlock_rdlock</a>(&amp;h-&gt;<a class="code" href="structast__heap.html#ace4e0066a5b24f84b90536e9906619f6">lock</a>);
<a name="l00315"></a>00315 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="ac68d03b30bb0adc489ccd67a11873b59"></a><!-- doxytag: member="heap.c::ast_heap_remove" ref="ac68d03b30bb0adc489ccd67a11873b59" args="(struct ast_heap *h, void *elm)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* ast_heap_remove </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structast__heap.html">ast_heap</a> *&nbsp;</td>
          <td class="paramname"> <em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>elm</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Remove a specific element from a heap. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>h</em>&nbsp;</td><td>the heap to remove from </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>elm</em>&nbsp;</td><td>the element to remove</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>elm, if the removal was successful, or NULL if it failed</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>the index_offset parameter to <a class="el" href="heap_8h.html#a2b4b738c784e05941437ff369a399712" title="Create a max heap.">ast_heap_create()</a> is required to be able to use this function. </dd></dl>
<dl class="since"><dt><b>Since:</b></dt><dd>1.6.1 </dd></dl>

<p>Definition at line <a class="el" href="heap_8c_source.html#l00275">275</a> of file <a class="el" href="heap_8c_source.html">heap.c</a>.</p>

<p>References <a class="el" href="heap_8c_source.html#l00259">_ast_heap_remove()</a>, and <a class="el" href="heap_8c_source.html#l00063">get_index()</a>.</p>

<p>Referenced by <a class="el" href="sched_8c_source.html#l00461">ast_sched_del()</a>, and <a class="el" href="timing_8c_source.html#l00101">ast_unregister_timing_interface()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00276"></a>00276 {
<a name="l00277"></a>00277    ssize_t i = <a class="code" href="heap_8c.html#a5590485773cb3d3213bedc1d39201c50">get_index</a>(h, elm);
<a name="l00278"></a>00278 
<a name="l00279"></a>00279    <span class="keywordflow">if</span> (i == -1) {
<a name="l00280"></a>00280       <span class="keywordflow">return</span> NULL;
<a name="l00281"></a>00281    }
<a name="l00282"></a>00282 
<a name="l00283"></a>00283    <span class="keywordflow">return</span> <a class="code" href="heap_8c.html#afb88fdb31b92d8132e3f37813250612d">_ast_heap_remove</a>(h, i);
<a name="l00284"></a>00284 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="abb3efaa08e2b1e9423bbbd5e3d9d2acc"></a><!-- doxytag: member="heap.c::ast_heap_size" ref="abb3efaa08e2b1e9423bbbd5e3d9d2acc" args="(struct ast_heap *h)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t ast_heap_size </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structast__heap.html">ast_heap</a> *&nbsp;</td>
          <td class="paramname"> <em>h</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the current size of a heap. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>h</em>&nbsp;</td><td>the heap</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the <a class="el" href="structnumber.html" title="Number structure.">number</a> of elements currently in the heap </dd></dl>
<dl class="since"><dt><b>Since:</b></dt><dd>1.6.1 </dd></dl>

<p>Definition at line <a class="el" href="heap_8c_source.html#l00300">300</a> of file <a class="el" href="heap_8c_source.html">heap.c</a>.</p>

<p>References <a class="el" href="heap_8c_source.html#l00038">ast_heap::cur_len</a>.</p>

<p>Referenced by <a class="el" href="sched_8c_source.html#l00546">ast_sched_dump()</a>, and <a class="el" href="sched_8c_source.html#l00508">ast_sched_report()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00301"></a>00301 {
<a name="l00302"></a>00302    <span class="keywordflow">return</span> h-&gt;<a class="code" href="structast__heap.html#a80fdf040f74e47fedc72cda33b40f13b">cur_len</a>;
<a name="l00303"></a>00303 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a708ec9a605944b90b0ca357ba5ec9f74"></a><!-- doxytag: member="heap.c::ast_heap_unlock" ref="a708ec9a605944b90b0ca357ba5ec9f74" args="(struct ast_heap *h)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ast_heap_unlock </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structast__heap.html">ast_heap</a> *&nbsp;</td>
          <td class="paramname"> <em>h</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Unlock a heap. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>h</em>&nbsp;</td><td>the heap</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>see the documentation for pthread_rwlock_unlock() </dd></dl>
<dl class="since"><dt><b>Since:</b></dt><dd>1.6.1 </dd></dl>

<p>Definition at line <a class="el" href="heap_8c_source.html#l00317">317</a> of file <a class="el" href="heap_8c_source.html">heap.c</a>.</p>

<p>References <a class="el" href="lock_8h_source.html#l01791">ast_rwlock_unlock()</a>, and <a class="el" href="heap_8c_source.html#l00035">ast_heap::lock</a>.</p>

<p>Referenced by <a class="el" href="timing_8c_source.html#l00071">_ast_register_timing_interface()</a>, <a class="el" href="timing_8c_source.html#l00119">ast_timer_open()</a>, and <a class="el" href="timing_8c_source.html#l00101">ast_unregister_timing_interface()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00318"></a>00318 {
<a name="l00319"></a>00319    <span class="keywordflow">return</span> <a class="code" href="lock_8h.html#a21ce13cd6c771d5855f47ae7a1dd50b6">ast_rwlock_unlock</a>(&amp;h-&gt;<a class="code" href="structast__heap.html#ace4e0066a5b24f84b90536e9906619f6">lock</a>);
<a name="l00320"></a>00320 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a0d46015f282b349a9b3d0560b5bc07c3"></a><!-- doxytag: member="heap.c::ast_heap_verify" ref="a0d46015f282b349a9b3d0560b5bc07c3" args="(struct ast_heap *h)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ast_heap_verify </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structast__heap.html">ast_heap</a> *&nbsp;</td>
          <td class="paramname"> <em>h</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Verify that a heap has been properly constructed. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>h</em>&nbsp;</td><td>a heap</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>0</em>&nbsp;</td><td>success </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>non-zero</em>&nbsp;</td><td>failure</td></tr>
  </table>
  </dd>
</dl>
<dl class="note"><dt><b>Note:</b></dt><dd>This function is mostly for debugging purposes. It traverses an existing heap and verifies that every node is properly placed relative to its children. </dd></dl>
<dl class="since"><dt><b>Since:</b></dt><dd>1.6.1 </dd></dl>

<p>Definition at line <a class="el" href="heap_8c_source.html#l00086">86</a> of file <a class="el" href="heap_8c_source.html">heap.c</a>.</p>

<p>References <a class="el" href="heap_8c_source.html#l00036">ast_heap::cmp_fn</a>, <a class="el" href="heap_8c_source.html#l00038">ast_heap::cur_len</a>, <a class="el" href="heap_8c_source.html#l00058">heap_get()</a>, <a class="el" href="heap_8c_source.html#l00043">left_node()</a>, and <a class="el" href="heap_8c_source.html#l00048">right_node()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00087"></a>00087 {
<a name="l00088"></a>00088    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i;
<a name="l00089"></a>00089 
<a name="l00090"></a>00090    <span class="keywordflow">for</span> (i = 1; i &lt;= (h-&gt;<a class="code" href="structast__heap.html#a80fdf040f74e47fedc72cda33b40f13b">cur_len</a> / 2); i++) {
<a name="l00091"></a>00091       <span class="keywordtype">int</span> l = <a class="code" href="heap_8c.html#a82847ffec208b4ed490b40e30b139fe6">left_node</a>(i);
<a name="l00092"></a>00092       <span class="keywordtype">int</span> r = <a class="code" href="heap_8c.html#ac8e0bba7e2f40ea2771f593447eba705">right_node</a>(i);
<a name="l00093"></a>00093 
<a name="l00094"></a>00094       <span class="keywordflow">if</span> (l &lt;= h-&gt;<a class="code" href="structast__heap.html#a80fdf040f74e47fedc72cda33b40f13b">cur_len</a>) {
<a name="l00095"></a>00095          <span class="keywordflow">if</span> (h-&gt;<a class="code" href="structast__heap.html#ad4e0020882fab5f0738eee8559ae138e">cmp_fn</a>(<a class="code" href="heap_8c.html#a750aea78f06637acdd54368ac351d25d">heap_get</a>(h, i), <a class="code" href="heap_8c.html#a750aea78f06637acdd54368ac351d25d">heap_get</a>(h, l)) &lt;= 0) {
<a name="l00096"></a>00096             <span class="keywordflow">return</span> -1;
<a name="l00097"></a>00097          }
<a name="l00098"></a>00098       }
<a name="l00099"></a>00099 
<a name="l00100"></a>00100       <span class="keywordflow">if</span> (r &lt;= h-&gt;cur_len) {
<a name="l00101"></a>00101          <span class="keywordflow">if</span> (h-&gt;<a class="code" href="structast__heap.html#ad4e0020882fab5f0738eee8559ae138e">cmp_fn</a>(<a class="code" href="heap_8c.html#a750aea78f06637acdd54368ac351d25d">heap_get</a>(h, i), <a class="code" href="heap_8c.html#a750aea78f06637acdd54368ac351d25d">heap_get</a>(h, r)) &lt;= 0) {
<a name="l00102"></a>00102             <span class="keywordflow">return</span> -1;
<a name="l00103"></a>00103          }
<a name="l00104"></a>00104       }
<a name="l00105"></a>00105    }
<a name="l00106"></a>00106 
<a name="l00107"></a>00107    <span class="keywordflow">return</span> 0;
<a name="l00108"></a>00108 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a690f90705aed40a7de352f0071ed7a58"></a><!-- doxytag: member="heap.c::ast_heap_wrlock" ref="a690f90705aed40a7de352f0071ed7a58" args="(struct ast_heap *h)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ast_heap_wrlock </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structast__heap.html">ast_heap</a> *&nbsp;</td>
          <td class="paramname"> <em>h</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Write-Lock a heap. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>h</em>&nbsp;</td><td>the heap</td></tr>
  </table>
  </dd>
</dl>
<p>A lock is provided for convenience. It can be assumed that none of the <a class="el" href="structast__heap.html">ast_heap</a> API calls are thread safe. This lock does not have to be used if another one is already available to protect the heap.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>see the documentation for pthread_rwlock_wrlock() </dd></dl>
<dl class="since"><dt><b>Since:</b></dt><dd>1.6.1 </dd></dl>

<p>Definition at line <a class="el" href="heap_8c_source.html#l00307">307</a> of file <a class="el" href="heap_8c_source.html">heap.c</a>.</p>

<p>References <a class="el" href="lock_8h_source.html#l01827">ast_rwlock_wrlock()</a>, and <a class="el" href="heap_8c_source.html#l00035">ast_heap::lock</a>.</p>

<p>Referenced by <a class="el" href="timing_8c_source.html#l00071">_ast_register_timing_interface()</a>, and <a class="el" href="timing_8c_source.html#l00101">ast_unregister_timing_interface()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00308"></a>00308 {
<a name="l00309"></a>00309    <span class="keywordflow">return</span> <a class="code" href="lock_8h.html#a952527792bba2a323118ae911f9aa1f7">ast_rwlock_wrlock</a>(&amp;h-&gt;<a class="code" href="structast__heap.html#ace4e0066a5b24f84b90536e9906619f6">lock</a>);
<a name="l00310"></a>00310 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a5590485773cb3d3213bedc1d39201c50"></a><!-- doxytag: member="heap.c::get_index" ref="a5590485773cb3d3213bedc1d39201c50" args="(struct ast_heap *h, void *elm)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static ssize_t get_index </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structast__heap.html">ast_heap</a> *&nbsp;</td>
          <td class="paramname"> <em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>elm</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="heap_8c_source.html#l00063">63</a> of file <a class="el" href="heap_8c_source.html">heap.c</a>.</p>

<p>References <a class="el" href="heap_8c_source.html#l00037">ast_heap::index_offset</a>.</p>

<p>Referenced by <a class="el" href="heap_8c_source.html#l00275">ast_heap_remove()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00064"></a>00064 {
<a name="l00065"></a>00065    ssize_t *index;
<a name="l00066"></a>00066 
<a name="l00067"></a>00067    <span class="keywordflow">if</span> (h-&gt;<a class="code" href="structast__heap.html#a343df1831d4c9543871a5bc4320a3d18">index_offset</a> &lt; 0) {
<a name="l00068"></a>00068       <span class="keywordflow">return</span> -1;
<a name="l00069"></a>00069    }
<a name="l00070"></a>00070 
<a name="l00071"></a>00071    index = elm + h-&gt;<a class="code" href="structast__heap.html#a343df1831d4c9543871a5bc4320a3d18">index_offset</a>;
<a name="l00072"></a>00072 
<a name="l00073"></a>00073    <span class="keywordflow">return</span> *index;
<a name="l00074"></a>00074 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="ae6dbb807fa2a60ce480b99f910ef2a3c"></a><!-- doxytag: member="heap.c::grow_heap" ref="ae6dbb807fa2a60ce480b99f910ef2a3c" args="(struct ast_heap *h)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int grow_heap </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structast__heap.html">ast_heap</a> *&nbsp;</td>
          <td class="paramname"> <em>h</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Add a row of additional storage for the heap. </p>

<p>Definition at line <a class="el" href="heap_8c_source.html#l00174">174</a> of file <a class="el" href="heap_8c_source.html">heap.c</a>.</p>

<p>References <a class="el" href="astmm_8c_source.html#l00229">__ast_realloc()</a>, and <a class="el" href="astmm_8h_source.html#l00093">ast_realloc</a>.</p>

<p>Referenced by <a class="el" href="heap_8c_source.html#l00235">ast_heap_push()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00179"></a>00179 {
<a name="l00180"></a>00180    h-&gt;<a class="code" href="structast__heap.html#ac426c291ec04f174c48a6065c0bbfb1f">avail_len</a> = h-&gt;<a class="code" href="structast__heap.html#ac426c291ec04f174c48a6065c0bbfb1f">avail_len</a> * 2 + 1;
<a name="l00181"></a>00181 
<a name="l00182"></a>00182    <span class="keywordflow">if</span> (!(h-&gt;<a class="code" href="structast__heap.html#a58a9e32eac038c7231ab379249122f64">heap</a> =
<a name="l00183"></a>00183 #ifdef MALLOC_DEBUG
<a name="l00184"></a>00184          <a class="code" href="astmm_8h.html#a6fb2a532b8ed08d248b7326abf218c5e">__ast_realloc</a>(h-&gt;<a class="code" href="structast__heap.html#a58a9e32eac038c7231ab379249122f64">heap</a>, h-&gt;<a class="code" href="structast__heap.html#ac426c291ec04f174c48a6065c0bbfb1f">avail_len</a> * <span class="keyword">sizeof</span>(<span class="keywordtype">void</span> *), file, lineno, func)
<a name="l00185"></a>00185 #<span class="keywordflow">else</span>
<a name="l00186"></a>00186          <a class="code" href="astmm_8h.html#aa852314efa0cfeecee97ffc51b649734">ast_realloc</a>(h-&gt;<a class="code" href="structast__heap.html#a58a9e32eac038c7231ab379249122f64">heap</a>, h-&gt;<a class="code" href="structast__heap.html#ac426c291ec04f174c48a6065c0bbfb1f">avail_len</a> * <span class="keyword">sizeof</span>(<span class="keywordtype">void</span> *))
<a name="l00187"></a>00187 #endif
<a name="l00188"></a>00188       )) {
<a name="l00189"></a>00189       h-&gt;<a class="code" href="structast__heap.html#a80fdf040f74e47fedc72cda33b40f13b">cur_len</a> = h-&gt;<a class="code" href="structast__heap.html#ac426c291ec04f174c48a6065c0bbfb1f">avail_len</a> = 0;
<a name="l00190"></a>00190       <span class="keywordflow">return</span> -1;
<a name="l00191"></a>00191    }
<a name="l00192"></a>00192 
<a name="l00193"></a>00193    <span class="keywordflow">return</span> 0;
<a name="l00194"></a>00194 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a750aea78f06637acdd54368ac351d25d"></a><!-- doxytag: member="heap.c::heap_get" ref="a750aea78f06637acdd54368ac351d25d" args="(struct ast_heap *h, int i)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void* heap_get </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structast__heap.html">ast_heap</a> *&nbsp;</td>
          <td class="paramname"> <em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>i</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="heap_8c_source.html#l00058">58</a> of file <a class="el" href="heap_8c_source.html">heap.c</a>.</p>

<p>References <a class="el" href="heap_8c_source.html#l00040">ast_heap::heap</a>.</p>

<p>Referenced by <a class="el" href="heap_8c_source.html#l00259">_ast_heap_remove()</a>, <a class="el" href="heap_8c_source.html#l00291">ast_heap_peek()</a>, <a class="el" href="heap_8c_source.html#l00235">ast_heap_push()</a>, <a class="el" href="heap_8c_source.html#l00086">ast_heap_verify()</a>, <a class="el" href="heap_8c_source.html#l00196">heap_swap()</a>, and <a class="el" href="heap_8c_source.html#l00205">max_heapify()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00059"></a>00059 {
<a name="l00060"></a>00060    <span class="keywordflow">return</span> h-&gt;<a class="code" href="structast__heap.html#a58a9e32eac038c7231ab379249122f64">heap</a>[i - 1];
<a name="l00061"></a>00061 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a0909ef13c9def687699d49e82bb90337"></a><!-- doxytag: member="heap.c::heap_set" ref="a0909ef13c9def687699d49e82bb90337" args="(struct ast_heap *h, int i, void *elm)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void heap_set </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structast__heap.html">ast_heap</a> *&nbsp;</td>
          <td class="paramname"> <em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>elm</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="heap_8c_source.html#l00076">76</a> of file <a class="el" href="heap_8c_source.html">heap.c</a>.</p>

<p>References <a class="el" href="heap_8c_source.html#l00040">ast_heap::heap</a>, and <a class="el" href="heap_8c_source.html#l00037">ast_heap::index_offset</a>.</p>

<p>Referenced by <a class="el" href="heap_8c_source.html#l00259">_ast_heap_remove()</a>, <a class="el" href="heap_8c_source.html#l00235">ast_heap_push()</a>, and <a class="el" href="heap_8c_source.html#l00196">heap_swap()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00077"></a>00077 {
<a name="l00078"></a>00078    h-&gt;<a class="code" href="structast__heap.html#a58a9e32eac038c7231ab379249122f64">heap</a>[i - 1] = elm;
<a name="l00079"></a>00079 
<a name="l00080"></a>00080    <span class="keywordflow">if</span> (h-&gt;<a class="code" href="structast__heap.html#a343df1831d4c9543871a5bc4320a3d18">index_offset</a> &gt;= 0) {
<a name="l00081"></a>00081       ssize_t *index = elm + h-&gt;<a class="code" href="structast__heap.html#a343df1831d4c9543871a5bc4320a3d18">index_offset</a>;
<a name="l00082"></a>00082       *index = i;
<a name="l00083"></a>00083    }
<a name="l00084"></a>00084 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a3bee448218fe03b6b23a2c208940a6c3"></a><!-- doxytag: member="heap.c::heap_swap" ref="a3bee448218fe03b6b23a2c208940a6c3" args="(struct ast_heap *h, int i, int j)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void heap_swap </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structast__heap.html">ast_heap</a> *&nbsp;</td>
          <td class="paramname"> <em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>j</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="heap_8c_source.html#l00196">196</a> of file <a class="el" href="heap_8c_source.html">heap.c</a>.</p>

<p>References <a class="el" href="heap_8c_source.html#l00058">heap_get()</a>, and <a class="el" href="heap_8c_source.html#l00076">heap_set()</a>.</p>

<p>Referenced by <a class="el" href="heap_8c_source.html#l00235">ast_heap_push()</a>, and <a class="el" href="heap_8c_source.html#l00205">max_heapify()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00197"></a>00197 {
<a name="l00198"></a>00198    <span class="keywordtype">void</span> *tmp;
<a name="l00199"></a>00199 
<a name="l00200"></a>00200    tmp = <a class="code" href="heap_8c.html#a750aea78f06637acdd54368ac351d25d">heap_get</a>(h, i);
<a name="l00201"></a>00201    <a class="code" href="heap_8c.html#a0909ef13c9def687699d49e82bb90337">heap_set</a>(h, i, <a class="code" href="heap_8c.html#a750aea78f06637acdd54368ac351d25d">heap_get</a>(h, j));
<a name="l00202"></a>00202    <a class="code" href="heap_8c.html#a0909ef13c9def687699d49e82bb90337">heap_set</a>(h, j, tmp);
<a name="l00203"></a>00203 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a82847ffec208b4ed490b40e30b139fe6"></a><!-- doxytag: member="heap.c::left_node" ref="a82847ffec208b4ed490b40e30b139fe6" args="(int i)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int left_node </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>i</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="heap_8c_source.html#l00043">43</a> of file <a class="el" href="heap_8c_source.html">heap.c</a>.</p>

<p>Referenced by <a class="el" href="heap_8c_source.html#l00086">ast_heap_verify()</a>, and <a class="el" href="heap_8c_source.html#l00205">max_heapify()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00044"></a>00044 {
<a name="l00045"></a>00045    <span class="keywordflow">return</span> 2 * i;
<a name="l00046"></a>00046 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a278188a6240552e1c40bd58ba9417902"></a><!-- doxytag: member="heap.c::max_heapify" ref="a278188a6240552e1c40bd58ba9417902" args="(struct ast_heap *h, int i)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void max_heapify </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structast__heap.html">ast_heap</a> *&nbsp;</td>
          <td class="paramname"> <em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>i</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="heap_8c_source.html#l00205">205</a> of file <a class="el" href="heap_8c_source.html">heap.c</a>.</p>

<p>References <a class="el" href="heap_8c_source.html#l00036">ast_heap::cmp_fn</a>, <a class="el" href="heap_8c_source.html#l00038">ast_heap::cur_len</a>, <a class="el" href="heap_8c_source.html#l00058">heap_get()</a>, <a class="el" href="heap_8c_source.html#l00196">heap_swap()</a>, <a class="el" href="heap_8c_source.html#l00043">left_node()</a>, and <a class="el" href="heap_8c_source.html#l00048">right_node()</a>.</p>

<p>Referenced by <a class="el" href="heap_8c_source.html#l00259">_ast_heap_remove()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00206"></a>00206 {
<a name="l00207"></a>00207    <span class="keywordflow">for</span> (;;) {
<a name="l00208"></a>00208       <span class="keywordtype">int</span> l = <a class="code" href="heap_8c.html#a82847ffec208b4ed490b40e30b139fe6">left_node</a>(i);
<a name="l00209"></a>00209       <span class="keywordtype">int</span> r = <a class="code" href="heap_8c.html#ac8e0bba7e2f40ea2771f593447eba705">right_node</a>(i);
<a name="l00210"></a>00210       <span class="keywordtype">int</span> max;
<a name="l00211"></a>00211 
<a name="l00212"></a>00212       <span class="keywordflow">if</span> (l &lt;= h-&gt;<a class="code" href="structast__heap.html#a80fdf040f74e47fedc72cda33b40f13b">cur_len</a> &amp;&amp; h-&gt;<a class="code" href="structast__heap.html#ad4e0020882fab5f0738eee8559ae138e">cmp_fn</a>(<a class="code" href="heap_8c.html#a750aea78f06637acdd54368ac351d25d">heap_get</a>(h, l), <a class="code" href="heap_8c.html#a750aea78f06637acdd54368ac351d25d">heap_get</a>(h, i)) &gt; 0) {
<a name="l00213"></a>00213          max = l;
<a name="l00214"></a>00214       } <span class="keywordflow">else</span> {
<a name="l00215"></a>00215          max = i;
<a name="l00216"></a>00216       }
<a name="l00217"></a>00217 
<a name="l00218"></a>00218       <span class="keywordflow">if</span> (r &lt;= h-&gt;<a class="code" href="structast__heap.html#a80fdf040f74e47fedc72cda33b40f13b">cur_len</a> &amp;&amp; h-&gt;<a class="code" href="structast__heap.html#ad4e0020882fab5f0738eee8559ae138e">cmp_fn</a>(<a class="code" href="heap_8c.html#a750aea78f06637acdd54368ac351d25d">heap_get</a>(h, r), <a class="code" href="heap_8c.html#a750aea78f06637acdd54368ac351d25d">heap_get</a>(h, max)) &gt; 0) {
<a name="l00219"></a>00219          max = r;
<a name="l00220"></a>00220       }
<a name="l00221"></a>00221 
<a name="l00222"></a>00222       <span class="keywordflow">if</span> (max == i) {
<a name="l00223"></a>00223          <span class="keywordflow">break</span>;
<a name="l00224"></a>00224       }
<a name="l00225"></a>00225 
<a name="l00226"></a>00226       <a class="code" href="heap_8c.html#a3bee448218fe03b6b23a2c208940a6c3">heap_swap</a>(h, i, max);
<a name="l00227"></a>00227 
<a name="l00228"></a>00228       i = max;
<a name="l00229"></a>00229    }
<a name="l00230"></a>00230 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="ae3a5f0397c1d0cf66427c8d5810ac280"></a><!-- doxytag: member="heap.c::parent_node" ref="ae3a5f0397c1d0cf66427c8d5810ac280" args="(int i)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int parent_node </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>i</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="heap_8c_source.html#l00053">53</a> of file <a class="el" href="heap_8c_source.html">heap.c</a>.</p>

<p>Referenced by <a class="el" href="heap_8c_source.html#l00235">ast_heap_push()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00054"></a>00054 {
<a name="l00055"></a>00055    <span class="keywordflow">return</span> i / 2;
<a name="l00056"></a>00056 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="ac8e0bba7e2f40ea2771f593447eba705"></a><!-- doxytag: member="heap.c::right_node" ref="ac8e0bba7e2f40ea2771f593447eba705" args="(int i)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int right_node </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>i</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="heap_8c_source.html#l00048">48</a> of file <a class="el" href="heap_8c_source.html">heap.c</a>.</p>

<p>Referenced by <a class="el" href="heap_8c_source.html#l00086">ast_heap_verify()</a>, and <a class="el" href="heap_8c_source.html#l00205">max_heapify()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00049"></a>00049 {
<a name="l00050"></a>00050    <span class="keywordflow">return</span> 2 * i + 1;
<a name="l00051"></a>00051 }
</pre></div></p>

</div>
</div>
</div>
<hr size="1"/><address style="text-align: right;"><small>Generated on Wed May 5 15:22:11 2010 for Asterisk - the Open Source PBX by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.1 </small></address>
</body>
</html>
