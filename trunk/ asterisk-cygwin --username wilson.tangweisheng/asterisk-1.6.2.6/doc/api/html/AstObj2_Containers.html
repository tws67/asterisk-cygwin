<HTML>
    <HEAD>
      <TITLE>Asterisk.org: Developer Documentation (5 May 2010)</TITLE>
      <LINK HREF="doxygen.css" REL="stylesheet" TYPE="text/css">
    </HEAD>
    <BODY BGCOLOR="#FFFFFF">
<div><font size="2" align="right">Wed May 5 15:23:35 2010</font></div>

<h2>Asterisk developer's documentation</h2>
<hr/>
<!-- Generated by Doxygen 1.6.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">


<h1><a class="anchor" id="AstObj2_Containers">AstObj2 Containers </a></h1><p>Containers are data structures meant to store several objects, and perform various operations on them. Internally, objects are stored in lists, hash <a class="el" href="structtables.html">tables</a> or other data structures depending on the needs.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>NOTA BENE: at the moment the only container we support is the hash table and its degenerate form, the list.</dd></dl>
<p>Operations on container include:</p>
<ul>
<li>c = <b><a class="el" href="astobj2_8h.html#a82534c91be59ec9a3d3318ec85ac5695">ao2_container_alloc(size, hash_fn, cmp_fn)</a></b> allocate a container with desired size and default compare and hash function -The compare function returns an int, which can be 0 for not found, CMP_STOP to stop end a traversal, or CMP_MATCH if they are equal -The hash function returns an int. The hash function takes two argument, the object pointer and a flags field,</li>
</ul>
<ul>
<li><b><a class="el" href="astobj2_8h.html#a618587b42226725315b96db394b13673">ao2_find(c, arg, flags)</a></b> returns zero or more element matching a given criteria (specified as arg). 'c' is the container pointer. Flags can be: OBJ_UNLINK - to remove the object, once found, from the container. OBJ_NODATA - don't return the object if found (no ref count change) OBJ_MULTIPLE - don't stop at first match (not fully implemented) OBJ_POINTER - if set, 'arg' is an object pointer, and a hashtable search will be done. If not, a traversal is done.</li>
</ul>
<ul>
<li><b><a class="el" href="astobj2_8h.html#a47857055118a703ae87ea5ebaf4842ed">ao2_callback(c, flags, fn, arg)</a></b> apply fn(obj, arg) to all objects in the container. Similar to find. fn() can tell when to stop, and do anything with the object including unlinking it.<ul>
<li>c is the container;<ul>
<li>flags can be OBJ_UNLINK - to remove the object, once found, from the container. OBJ_NODATA - don't return the object if found (no ref count change) OBJ_MULTIPLE - don't stop at first match (not fully implemented) OBJ_POINTER - if set, 'arg' is an object pointer, and a hashtable search will be done. If not, a traversal is done through all the hashtable 'buckets'..</li>
<li>fn is a func that returns int, and takes 3 args: (void *obj, void *arg, int flags); obj is an object arg is the same as arg passed into ao2_callback flags is the same as flags passed into ao2_callback fn returns: 0: no match, keep going CMP_STOP: stop search, no match CMP_MATCH: This object is matched.</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>Note that the entire operation is run with the container locked, so noone else can change its content while we work on it. However, we pay this with the fact that doing anything blocking in the callback keeps the container blocked. The mechanism is very flexible because the callback function fn() can do basically anything e.g. counting, deleting records, etc. possibly using arg to store the results.</p>
<ul>
<li><b>iterate</b> on a container this is done with the following sequence</li>
</ul>
<div class="fragment"><pre class="fragment">       <span class="keyword">struct </span><a class="code" href="structao2__container.html">ao2_container</a> *c = ... <span class="comment">// our container</span>
       <span class="keyword">struct </span><a class="code" href="structao2__iterator.html" title="When we need to walk through a container, we use an ao2_iterator to keep track of...">ao2_iterator</a> i;
       <span class="keywordtype">void</span> *o;

       i = <a class="code" href="astobj2_8h.html#a288075de687152d297308ea1ea963edb" title="Create an iterator for a container.">ao2_iterator_init</a>(c, <a class="code" href="structao2__iterator.html#ac8bf36fe0577cba66bccda3a6f7e80a4">flags</a>);

       <span class="keywordflow">while</span> ( (o = <a class="code" href="astobj2_8h.html#a1cf2fe1aafd3cb9e613eb48535a37ad5">ao2_iterator_next</a>(&amp;i)) ) {
      ... <span class="keywordflow">do</span> something on o ...
      <a class="code" href="astobj2_8h.html#aaca5e8eac39a22f9da1c36fc6c922270">ao2_ref</a>(o, -1);
       }

       <a class="code" href="astobj2_8h.html#a62d5d9e9d0fa281168e6a08ef4a52450" title="Destroy a container iterator.">ao2_iterator_destroy</a>(&amp;i);
</pre></div><p>The difference with the callback is that the control on how to iterate is left to us.</p>
<ul>
<li><b>ao2_ref</b>(c, -1) dropping a reference to a container destroys it, very simple!</li>
</ul>
<p>Containers are ao2 objects themselves, and this is why their implementation is simple too.</p>
<p>Before declaring containers, we need to declare the types of the arguments passed to the constructor - in turn, this requires to define callback and hash functions and their arguments.</p>
<ul>
<li><a class="el" href="AstObj2.html">Object Model implementing objects and containers.</a></li>
<li><a class="el" href="astobj2_8h.html">astobj2.h</a> </li>
</ul>
</div>
<hr size="1"/><address style="text-align: right;"><small>Generated on Wed May 5 15:23:35 2010 for Asterisk - the Open Source PBX by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.1 </small></address>
</body>
</html>
